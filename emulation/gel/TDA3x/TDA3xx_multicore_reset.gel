/*******************************************************************/
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/* TDA3xx multicore reset config                                   */
/*                                                                 */
/*                                                                 */
/*******************************************************************/

#define WR_MEM_32(addr, data)   *(unsigned int*)(addr) =(unsigned int)(data)
#define RD_MEM_32(addr)         *(unsigned int*)(addr)
#define uint32_t                unsigned int

#define DEBUG_PRINT          1
#define VISION_SDK_CONFIG    0 /* Applicable for Vision SDK users only */

/*******************************************************************************
        TDA3xx Registers Map Defines: IPU view
*******************************************************************************/
#define DSP1_L2_SRAM_TARG            0x40800000
#define DSP1_SYSTEM_TARG             0x40D00000
#define DSP1_MMU0CFG_TARG            0x40D01000
#define DSP1_MMU1CFG_TARG            0x40D02000
#define DSP1_EDMA_CC_TARG            0x40D10000
#define DSP2_L2_SRAM_TARG            0x41000000
#define EVE_TARG                     0x62000000
#define L4_CFG_TARG                  0x4A000000
#define L4_WKUP_TARG                 0x4AE00000

/*******************************************************************************
        L4_CFG Registers Map Defines: IPU view
*******************************************************************************/
#define CTRL_MODULE_CORE             (L4_CFG_TARG + 0x2000)
#define CM_CORE_AON                  (L4_CFG_TARG + 0x5000)
#define CM_CORE                      (L4_CFG_TARG + 0x8000)

/*******************************************************************************
        L4_WKUP Registers Map Defines: IPU view
*******************************************************************************/
#define PRM                          (L4_WKUP_TARG + 0x6000)

/*******************************************************************************
        PRCM Registers Map Defines: IPU view
*******************************************************************************/
#define IPU_CM_CORE_AON              (CM_CORE_AON + 0x500)
#define DSP1_CM_CORE_AON             (CM_CORE_AON + 0x400)
#define DSP2_CM_CORE_AON             (CM_CORE_AON + 0x600)
#define EVE_CM_CORE_AON              (CM_CORE_AON + 0x640)
#define DSP1_PRM                     (PRM + 0x400)
#define DSP2_PRM                     (PRM + 0x1B00)
#define EVE_PRM                      (PRM + 0x1B40)

#define IPU1_BASE_ADDR               (IPU1_TARGET_TARG + 0x20000)
#define IPU1_MMU_CFG                 (IPU1_TARGET_TARG + 0x80000)
#define IPU_BASE_ADDR                (0x55020000)

/*******************************************************************************
        DSPSS1 Address Map defines: IPU view
*******************************************************************************/
#define CM_DSP1_CLKSTCTRL            (DSP1_CM_CORE_AON + 0x0)
#define CM_DSP1_DSP1_CLKCTRL         (DSP1_CM_CORE_AON + 0x20)
#define RM_DSP1_RSTCTRL              (DSP1_PRM + 0x10)
#define RM_DSP1_RSTST                (DSP1_PRM + 0x14)

#define DSPSS1BOOTADDR               (CTRL_MODULE_CORE + 0x55C)
#define DSPSS1BOOTADDRVALUE          (DSP1_L2_SRAM_TARG - 0x40000000)

/*******************************************************************************
        DSPSS2 Address Map defines: IPU view
*******************************************************************************/
#define CM_DSP2_CLKSTCTRL            (DSP2_CM_CORE_AON + 0x0)
#define CM_DSP2_DSP2_CLKCTRL         (DSP2_CM_CORE_AON + 0x20)
#define RM_DSP2_RSTCTRL              (DSP2_PRM + 0x10)
#define RM_DSP2_RSTST                (DSP2_PRM + 0x14)

#define DSPSS2BOOTADDR               (CTRL_MODULE_CORE + 0x560)
#define DSPSS2BOOTADDRVALUE          (DSP2_L2_SRAM_TARG - 0x40800000)

/*******************************************************************************
            DSPSS CPU Independent defines
*******************************************************************************/
#define CM_DSP_CLKSTCTRL             ((cpu_num == 1) ? (CM_DSP1_CLKSTCTRL) : (CM_DSP2_CLKSTCTRL))
#define CM_DSP_DSP_CLKCTRL           ((cpu_num == 1) ? (CM_DSP1_DSP1_CLKCTRL) : (CM_DSP2_DSP2_CLKCTRL))
#define RM_DSP_RSTCTRL               ((cpu_num == 1) ? (RM_DSP1_RSTCTRL) : (RM_DSP2_RSTCTRL))
#define RM_DSP_RSTST                 ((cpu_num == 1) ? (RM_DSP1_RSTST) : (RM_DSP2_RSTST))

#define DSPSSBOOTADDR                ((cpu_num == 1) ? (DSPSS1BOOTADDR) : (DSPSS2BOOTADDR))
#define DSPSSBOOTADDRVALUE           ((cpu_num == 1) ? (DSPSS1BOOTADDRVALUE) : (DSPSS2BOOTADDRVALUE))

#define DSP_L2_SRAM_TARG             ((cpu_num == 1) ? (DSP1_L2_SRAM_TARG) : (DSP2_L2_SRAM_TARG))

/*******************************************************************************
        EVESS1 Address Map defines: IPU view
*******************************************************************************/
#define CM_EVE_CLKSTCTRL            (EVE_CM_CORE_AON + 0x0)
#define CM_EVE_EVE_CLKCTRL         (EVE_CM_CORE_AON + 0x20)
#define RM_EVE_RSTCTRL              (EVE_PRM + 0x10)
#define RM_EVE_RSTST                (EVE_PRM + 0x14)
#define EVE_MMU0_BASE               (EVE_TARG + 0x81000)
#define EVE_MMU1_BASE               (EVE_TARG + 0x82000)

#define EVE_MMU_PAGESIZE_1M          0
#define EVE_MMU_PAGESIZE_64K         1
#define EVE_MMU_PAGESIZE_4K          2
#define EVE_MMU_PAGESIZE_16M         3
#define EVE_MMU_BASE                ((mmu_num == 0) ? (EVE_MMU0_BASE) : (EVE_MMU1_BASE))
#define EVE_MMU_SYSCONFIG           ( EVE_MMU_BASE + 0x10 )
#define EVE_MMU_SYSSTATUS           ( EVE_MMU_BASE + 0x14 )
#define EVE_MMU_CNTL                ( EVE_MMU_BASE + 0x44 )
#define EVE_MMU_FAULT_AD            ( EVE_MMU_BASE + 0x48 )
#define EVE_MMU_CAM                 ( EVE_MMU_BASE + 0x58 )
#define EVE_MMU_RAM                 ( EVE_MMU_BASE + 0x5c )
#define EVE_MMU_LOCK                ( EVE_MMU_BASE + 0x50 )
#define EVE_MMU_LD_TLB              ( EVE_MMU_BASE + 0x54 )
#define EVE_MMU_EMU_FAULT_AD        ( EVE_MMU_BASE + 0x70 )

menuitem "TDA3xx MULTICORE Initialization"

/************ Enable all slave cores ***************/
hotmenu TDA3xx_MULTICORE_EnableAllCores()
{
    DSP1SSClkEnable_API();
    DSP2SSClkEnable_API();
    EVESSClkEnable_API();
}

/************ Enable the DSP1 Clocks ***************/
hotmenu DSP1SSClkEnable_API()
{
    DSPSSClkEnable(1);
}

/************ Enable the DSP2 Clocks ***************/
hotmenu DSP2SSClkEnable_API()
{
    DSPSSClkEnable(2);
}

/************ Enable the EVE Clocks ***************/
hotmenu EVESSClkEnable_API()
{
    GEL_TextOut("--->>> Starting A-MMU config for EVE Config space access  <<<---\n");

    EVESSClkEnable(1);
}


#define IPU_MMU_CFG                   0x55080000

/******************************************************************
* A-MMU configuration starts here...
******************************************************************/

menuitem "IPU Unicache and A-MMU configurations "

/******************************************************************
*A-MMU initialization.
******************************************************************/
hotmenu Config_AMMU(){
    AMMU_config();
}

hotmenu DummyLoopM4()
{
    WR_MEM_32(IPU_BASE_ADDR, 0x10000);
    WR_MEM_32(IPU_BASE_ADDR + 0x4, 0x9);
    WR_MEM_32(IPU_BASE_ADDR + 0x8, 0xE7FEE7FE);
    while (RD_MEM_32(IPU_BASE_ADDR) != 0x10000);
    while (RD_MEM_32(IPU_BASE_ADDR + 0x4) != 0x9);
    while (RD_MEM_32(IPU_BASE_ADDR + 0x8) != 0xE7FEE7FE);
}

AMMU_config()
{
    uint32_t regVal, regAddr;

    GEL_TextOut("--->>> Starting  IPU A-MMU configurations... <<<---\n");

    if(VISION_SDK_CONFIG == 1)
    {
        /*---------------- Setup the UNICACHE MMU -----------------*/
        /*Large Page Translations */
        /*Large Page 0 is mapped by RBL from P.A. 0x08000000 to L.A. 0x08000000*/
        /* Logical Address */
        regAddr = IPU_MMU_CFG;
        regAddr += 0x800;
        WR_MEM_32(regAddr,         0x08000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0xA0000000); regAddr += 0x4;

        /* Physical Address */
        regAddr = IPU_MMU_CFG;
        regAddr += 0x820;
        WR_MEM_32(regAddr,         0x08000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;

        /* Policy Register */
        regAddr = IPU_MMU_CFG;
        regAddr += 0x840;
        WR_MEM_32(regAddr,         0x00030001); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x000F0007); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;

        /*Medium Page*/
        /*Medium Page 0 is mapped by RBL from P.A. 0x40300000 to L.A. 0x00300000*/
        regAddr = IPU_MMU_CFG;
        regAddr += 0x860;
        WR_MEM_32(regAddr,         0x00300000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;

        regAddr = IPU_MMU_CFG;
        regAddr += 0x8A0;
        WR_MEM_32(regAddr,         0x40300000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x55020000); regAddr += 0x4;

        regAddr = IPU_MMU_CFG;
        regAddr += 0x8E0;
        WR_MEM_32(regAddr,         0x00030003); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00010009); regAddr += 0x4;

        /*Small Page*/
        /*Small Page 1 is mapped by Design from P.A. 0x55080000 to L.A. 0x40000000*/
        /*change the policy register of this page*/

        //Small page Physical Address
        regAddr = IPU_MMU_CFG;
        regAddr += 0x920;
        WR_MEM_32(regAddr,         0x63300000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x63304000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x62081000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x6208B000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x6208C000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x6883A000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x620A0000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x62086000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;

        //Small page Virtual Address
        regAddr = IPU_MMU_CFG;
        regAddr += 0x9A0;
        WR_MEM_32(regAddr,         0x43300000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x55080000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x43304000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x42081000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x4208B000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x4208C000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x4883A000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x420A0000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x42086000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;

        regAddr = IPU_MMU_CFG;
        regAddr += 0xA20;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
    }
    else
    {
        /*---------------- Setup the UNICACHE MMU -----------------*/
        /*Large Page Translations */
        /* Logical Address */
        regAddr = IPU_MMU_CFG;
        regAddr += 0x800;
        WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0xA0000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x60000000); regAddr += 0x4;

        /* Physical Address */
        regAddr = IPU_MMU_CFG;
        regAddr += 0x820;
        WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;

        /* Policy Register */
        regAddr = IPU_MMU_CFG;
        regAddr += 0x840;
        WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x000B0007); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;

        /*Medium Page*/
        regAddr = IPU_MMU_CFG;
        regAddr += 0x860;
        WR_MEM_32(regAddr,         0x00300000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00340000); regAddr += 0x4;

        regAddr = IPU_MMU_CFG;
        regAddr += 0x8A0;
        WR_MEM_32(regAddr,         0x40300000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x40340000); regAddr += 0x4;

        regAddr = IPU_MMU_CFG;
        regAddr += 0x8E0;
        WR_MEM_32(regAddr,         0x00030003); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00030003); regAddr += 0x4;

         /*Small Page*/
        //Small page Physical Address
        regAddr = IPU_MMU_CFG;
        regAddr += 0x920;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00004000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00008000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000C000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;

        //Small page Virtual Address
        regAddr = IPU_MMU_CFG;
        regAddr += 0x9A0;
        WR_MEM_32(regAddr,         0x55020000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x55080000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x55024000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x55028000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x5502C000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;

        regAddr = IPU_MMU_CFG;
        regAddr += 0xA20;
        WR_MEM_32(regAddr,         0x0001000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x0001000B); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
        WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
    }
    GEL_TextOut("--->>> IPU A-MMU configuration completed. <<<---\n");

}

/******************************************************************
* A-MMU configuration ends here...
******************************************************************/

hotmenu Enable_UniCache()
{

    GEL_TextOut("--->>> enter Enable_UniCache <<<---\n");

    /* Enalble Unicache */
    WR_MEM_32(0x40000004, 0x0000001F);


    GEL_TextOut("--->>> exit Enable_UniCache <<<---\n");
}

hotmenu Disable_UniCache()
{

    GEL_TextOut("--->>> enter Disable_UniCache <<<---\n");

    /* Disable Unicache */
    WR_MEM_32(0x40000004, 0x0000001C);


    GEL_TextOut("--->>> exit Disable_UniCache <<<---\n");
}

/******************************************************************
* Unicache enable completed.
******************************************************************/


DSPSSClkEnable(uint32_t cpu_num)
{
    uint32_t i, fail = 0;
    uint32_t frequency = 0;

    GEL_TextOut("--->>> DSP%dSS Initialization is in progress ... <<<---\n",,,,,cpu_num);
    /* PRCM Setting for DSP should not be performed at 1 GHz operation */
    frequency = dpll_get_clkout_speed(CM_CLKMODE_DPLL_DSP_GMAC, GENERIC_DPLL_CLKOUTX2_M3, 0);
    if (frequency == 1000)
    {
        GEL_TextOut("\n----------------------------------------------\n");
        /* Relock the DPLL at OPP_HIGH  */
        /* Configure the DSP/EVE clock mux */
        dsp_eve_clock_mux_sel(OPP_HIGH, DEVICE_TDA3XX_15x15);

        /* DSP_GMAC DPLL programming */
        dpll_dsp_gmac_config(OPP_HIGH, DEVICE_TDA3XX_15x15);

        /* DSP DPLL programming */
        dpll_eve_vid_dsp_config(OPP_HIGH, DEVICE_TDA3XX_15x15);
        GEL_TextOut("\n----------------------------------------------\n");
    }

    /* DSPSS Boot Address */
    WR_MEM_32(DSPSSBOOTADDR, (DSPSSBOOTADDRVALUE >> 10));

    /* Ware reset asserted for DSP_LRST, DSP Cache and Slave */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x3);

    /* Start a SW force wakeup for DSPSS */
    WR_MEM_32(CM_DSP_CLKSTCTRL, 0x2);
    /* Enable DSPSS clock */
    WR_MEM_32(CM_DSP_DSP_CLKCTRL, 0x1);

    /* Check whether GFCLK is gated or not */
    while ((RD_MEM_32(CM_DSP_CLKSTCTRL) & 0x100) != 0x100);
    if (DEBUG_PRINT)
    {
        GEL_TextOut("DEBUG: Clock is active ... \n");
    }

    /* Reset de-assertion for DSPSS */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x1);
    /* Check the reset state: DSPSS */
    while ((RD_MEM_32(RM_DSP_RSTST) & 0x2) != 0x2);

    WR_MEM_32(DSP_L2_SRAM_TARG, 0x0000A120); //Self branch loop for DSP

    /* Reset de-assertion for DSP CPUs */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x0);
    /* Check the reset state: DSPSS Core, Cache and Slave interface */
    while ((RD_MEM_32(RM_DSP_RSTST) & 0x3) != 0x3);
    /* Check module mode */
    while ((RD_MEM_32(CM_DSP_DSP_CLKCTRL) & 0x30000) != 0x0);

    if (DEBUG_PRINT)
    {
        GEL_TextOut("DEBUG: Checking for data integrity in DSPSS L2RAM ... \n");
    }
    for (i = 1; i < 16; i++)
    {
        WR_MEM_32((DSP_L2_SRAM_TARG + (i << 2)), 0x12345678);
    }

    for (i = 1; i < 16; i++)
    {
        if (RD_MEM_32(DSP_L2_SRAM_TARG + (i << 2)) != 0x12345678)
        {
            fail++;
            break;
        }
    }

    if (fail)
    {
        GEL_TextOut("ERROR: Data integrity check in GEM L2RAM has failed! \n");
    }
    else
    {
        if (DEBUG_PRINT)
        {
            GEL_TextOut("DEBUG: Data integrity check in GEM L2RAM is sucessful! \n");
        }
    }
    if (frequency == 1000)
    {
        GEL_TextOut("\n----------------------------------------------\n");
        /* Relock the DPLL at OPP_PLUS  */
        /* Configure the DSP/EVE clock mux */
        dsp_eve_clock_mux_sel(OPP_PLUS, DEVICE_TDA3XX_15x15);

        /* DSP_GMAC DPLL programming */
        dpll_dsp_gmac_config(OPP_PLUS, DEVICE_TDA3XX_15x15);

        /* DSP DPLL programming */
        dpll_eve_vid_dsp_config(OPP_PLUS, DEVICE_TDA3XX_15x15);
        GEL_TextOut("\n----------------------------------------------\n");
    }
    GEL_TextOut("--->>> DSP%dSS Initialization is DONE! <<<---\n",,,,,cpu_num);
}

EVESSClkEnable(uint32_t cpu_num)
{
    uint32_t frequency = 0;

    GEL_TextOut("--->>> EVESS Initialization is in progress ... <<<---\n",,,,, cpu_num);
    /* PRCM Setting for EVE should not be performed at 900 MHz operation */
    frequency = dpll_get_clkout_speed(CM_CLKMODE_DPLL_DSP_GMAC, GENERIC_DPLL_CLKOUTX2_M3, 0);
    if (frequency == 1000)
    {
        GEL_TextOut("\n----------------------------------------------\n");
        /* Relock the DPLL at OPP_HIGH  */
        /* Configure the DSP/EVE clock mux */
        dsp_eve_clock_mux_sel(OPP_HIGH, DEVICE_TDA3XX_15x15);

        /* DSP_GMAC DPLL programming */
        dpll_dsp_gmac_config(OPP_HIGH, DEVICE_TDA3XX_15x15);

        /* DSP DPLL programming */
        dpll_eve_vid_dsp_config(OPP_HIGH, DEVICE_TDA3XX_15x15);
        GEL_TextOut("\n----------------------------------------------\n");
    }
    /* Ware reset asserted for EVE_LRST, EVE Cache and Slave */
    WR_MEM_32(RM_EVE_RSTCTRL, 0x3);

    /* Start a SW force wakeup for EVESS */
    WR_MEM_32(CM_EVE_CLKSTCTRL, 0x2);
    /* Enable EVESS clock */
    WR_MEM_32(CM_EVE_EVE_CLKCTRL, 0x1);

    /* Check whether GFCLK is gated or not */
    while ((RD_MEM_32(CM_EVE_CLKSTCTRL) & 0x100) != 0x100);
    if (DEBUG_PRINT)
    {
        GEL_TextOut("DEBUG: Clock is active ... \n");
    }

    /* Reset de-assertion for EVESS */
    WR_MEM_32(RM_EVE_RSTCTRL, 0x1);
    /* Check the reset state: EVESS */
    while ((RD_MEM_32(RM_EVE_RSTST) & 0x2) != 0x2);

    EVE_MMU0_Config(cpu_num);

    /* Reset de-assertion for EVESS CPUs */
    WR_MEM_32(RM_EVE_RSTCTRL, 0x0);
    /* Check the reset state: EVESS Core, Cache and Slave interface */
    while ((RD_MEM_32(RM_EVE_RSTST) & 0x3) != 0x3);
    /* Check module mode */
    while ((RD_MEM_32(CM_EVE_EVE_CLKCTRL) & 0x30000) != 0x0);

    WR_MEM_32(RM_EVE_RSTST, 0x3);

    if (frequency == 1000)
    {
        GEL_TextOut("\n----------------------------------------------\n");
        /* Relock the DPLL at OPP_PLUS  */
        /* Configure the DSP/EVE clock mux */
        dsp_eve_clock_mux_sel(OPP_PLUS, DEVICE_TDA3XX_15x15);

        /* DSP_GMAC DPLL programming */
        dpll_dsp_gmac_config(OPP_PLUS, DEVICE_TDA3XX_15x15);

        /* DSP DPLL programming */
        dpll_eve_vid_dsp_config(OPP_PLUS, DEVICE_TDA3XX_15x15);
        GEL_TextOut("\n----------------------------------------------\n");
    }
    GEL_TextOut("--->>> EVESS Initialization is DONE! <<<---\n",,,,, cpu_num);
}

SetupEveMmuEntry(uint32_t cpu_num, uint32_t mmu_num, uint32_t entryNum, uint32_t virtAddr, uint32_t physAddr, uint32_t pageSize)
{
    GEL_TextOut("DEBUG: Configuring EVE MMU%d TLB entry %u: %x --> %x  \n",,,,, cpu_num, mmu_num, entryNum, virtAddr, physAddr);

    WR_MEM_32(EVE_MMU_CAM, 0x0000000c | (pageSize & 3) | (virtAddr & 0xFFFFE000));
    WR_MEM_32(EVE_MMU_RAM, 0x000001c0 | (physAddr  & 0xFFFFE000));
    WR_MEM_32(EVE_MMU_LOCK, ((RD_MEM_32(EVE_MMU_LOCK)) & 0xFFFFFE0F) | ( entryNum << 4 ));
    WR_MEM_32(EVE_MMU_LD_TLB, 1);
}

add_while1_at_resetVector(uint32_t addr)
{
    /* Writing a Self branch loop at reset address (required for the CPU to connect reliably) */
    WR_MEM_32(addr, 0x00000100);
    WR_MEM_32(addr + 0x100, 0x004a03FF);
    WR_MEM_32(addr + 0x104, 0x03FF03FF);
}

EVE_MMU0_Config(uint32_t cpu_num)
{
    uint32_t mmu_num = 0;
    uint32_t vec_base = 0;

    /* Reset the MMU */
    GEL_TextOut("DEBUG: Resetting EVE MMU ... \n",,,,,,);
    WR_MEM_32(EVE_MMU_SYSCONFIG, 2);

    /* Wait until MMU reset finished */
    while((RD_MEM_32(EVE_MMU_SYSSTATUS) & 1) == 0);

    /* Configure the MMU */

    /* CAM[1:0]   - Page Size: 0=1MB, 1=64kB, 2=4kB, 3=16MB */
    /* CAM[2]     - Valid bit */
    /* CAM[3]     - Preserved (protected against flushs) */
    /* CAM[31:12] - Virtual address tag */

    /* CAM = 0xC -->  1 MB   */
    /* CAM = 0xF --> 16 MB   */

    /* RAM[6]     - Mixed page attribute: 0 use TLB element size, 1 use CPU element size */
    /* RAM[8:7]   - Element size 0=8 bits, 1=16 bits, 2=32 bits, 3=no translation */
    /* RAM[9]     - Endianness of the page (0=little, 1=big) */
    /* RAM[31:12] - Physical address of the page */

    /* RAM = 0x1C0 --> CPU element size, no translation */

    if(VISION_SDK_CONFIG == 0)
    {
        /* TLB 1 is zero virtual address mapped to OCMC3 (required for the CPU to work) */
        /* Translate only small page (4kB) for reset vector */
        SetupEveMmuEntry(cpu_num, mmu_num, 1, 0x00000000, 0x80000000, EVE_MMU_PAGESIZE_4K);

        /* Writing a Self branch loop at reset address (required for the CPU to connect reliably) */
        add_while1_at_resetVector(0x80000000);

        /* Enable access to entire DDR */
        SetupEveMmuEntry(cpu_num, mmu_num,  2, 0x80000000, 0x80000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  3, 0x81000000, 0x81000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  4, 0x82000000, 0x82000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  5, 0x83000000, 0x83000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  6, 0x84000000, 0x84000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  7, 0x85000000, 0x85000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  8, 0x86000000, 0x86000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  9, 0x87000000, 0x87000000, EVE_MMU_PAGESIZE_16M);

        /* Enable access to some of configuration space and OCMC memories */
        SetupEveMmuEntry(cpu_num, mmu_num, 10, 0x40000000, 0x40000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num, 11, 0x4A000000, 0x4A000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num, 12, 0x45000000, 0x45000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num, 13, 0x48000000, 0x48000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num, 14, 0x42000000, 0x42000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num, 15, 0x54000000, 0x54000000, EVE_MMU_PAGESIZE_16M);
    }
    else
    {
        if(cpu_num == 1)
        {
            vec_base = 0x80000000;
        }
        add_while1_at_resetVector(vec_base);
        SetupEveMmuEntry(cpu_num, mmu_num,  1, 0x00000000,   vec_base, EVE_MMU_PAGESIZE_4K);
        SetupEveMmuEntry(cpu_num, mmu_num,  2, vec_base,     vec_base, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  3, 0x40000000, 0x40000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  4, 0x48000000, 0x48000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  5, 0x42000000, 0x42000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num,  6, 0x4A000000, 0x4A000000, EVE_MMU_PAGESIZE_16M);
        SetupEveMmuEntry(cpu_num, mmu_num, 31, 0x54000000, 0x54000000, EVE_MMU_PAGESIZE_16M);
    }

    /* Enable MMU */
    WR_MEM_32(EVE_MMU_CNTL, ((RD_MEM_32(EVE_MMU_CNTL)) & 0xFFFFFFFD) | 0x2);

    /********************/
    if(VISION_SDK_CONFIG == 1)
    {
        GEL_TextOut("DEBUG: EVE%d MMU0 configured as per VisionSDK requirements!!!!\n",,,,,, cpu_num);
    }
    else
    {
        GEL_TextOut("DEBUG: EVE%d MMU0 configured as per EVE_SW_LIBRARY requirements!!!!\n",,,,,, cpu_num);
    }
    GEL_TextOut("DEBUG: MMU0 configured for EVE%d \n",,,,,, cpu_num);
}
