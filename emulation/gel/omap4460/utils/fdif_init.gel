menuitem "FDIF_init"
/* now this function is loaded by ccs "official" GEL
hotmenu FDIF_SW_change_EFUSE()
 {
 unsigned reg=1;
 
  GEL_TextOut("Change MEM_RW_GWG (bits field 13:12)",,0);
 *(unsigned *)(unsigned)0x4a002338 = 0x8000baaa;
 GEL_TextOut("New register value must be equal to 0x8000BAAA",,0);
  // read back value.. 
 reg = *(unsigned *)(unsigned)0x4a002338;
  GEL_TextOut("New register value: %x",,0,,,reg);
 
 }
 */
 
 menuitem "FDIF_init"
 hotmenu FDIF_LoadTest()
{
     GEL_Load ("S:/cdb/tcomap4440/tc_fdif/fdif_get_coord_board/cortexa9_cpu0_ape/cortexa9_cpu0_ape_silicon_image.axf");
}

hotmenu FDIF_Go_TestEntry()
{
	GEL_Go(FDGETCOORD_TestFunction);
}
dialog FDIF_InitParam(work_addr "FDIF working buffer address",
                       face_size "FDIF min face size to be detected in pixel(20,25,32 or 40)",
                       orient  "ïmage orientation: 0 UP 1 RIGTH 2 LEFT",
				       x0 "horizontal offset",
				       y0 "vertical offset",
				       x_max "bottom rigth absciss",
				       y_max "bottom rigth ordinate",
				       thresh "Deectection theshold (0 t0 9)"
				       )
{
GEL_Go(FDGETCOORD_TestFunction);
fdif_working_addr = work_addr; // external woeking buffer
if (face_size == 20)
   fdif_face_size = 0; 
if (face_size == 25)
   fdif_face_size = 1; 
if (face_size == 32)
   fdif_face_size = 2; 
if (face_size == 40)
   fdif_face_size = 3; 
   
fdif_image_direction= dir;  // rigth, up or left
fdif_horiz_offset = x0;
fdif_vert_offset = y0;
fdif_x_max = x_max; // end of region of interest
fdif_y_max= y_max;
fdif_threshold = thresh; 

}

dialog FDIF_InitTest (image_idx "Image library BD index(0 to 100, -1 if sl2)",
				       db_idx "Database index (1 to 4)",
				       Check_mode "0: pool status register;1: use interrupt",
				       Image_src "Image from:1: DDR,2:MMC,3:GEL,4:Camera",
					   target "Execution on : 1: A9; 2: M3 sys; 3: C64"
					   )
{
 image_lib_idx = image_idx;
image_db_idx =db_idx;

flag_input_source = Image_src;
if (Image_src == 3)
	flag_data_load = 2;
fdif_int_enabled = Check_mode;
fdif_run_core= target;
gel_init_done = 1;
use_sw_uart = 0;

}

hotmenu FDIF_InitTestParam(work_addr,face_size, orient, x0, y0 , x_max,y_max ,thresh , image_idx )
{
fdif_working_addr = work_addr; // external woeking buffer
if (face_size == 20)
   fdif_face_size = 0; 
else if (face_size == 25)
   fdif_face_size = 1; 
else if (face_size == 32)
   fdif_face_size = 2; 
else if (face_size == 40)
   fdif_face_size = 3; 
else // default value to 20x20
   fdif_face_size = 0; 
   
fdif_image_direction= orient;  // rigth, up or left
fdif_horiz_offset = x0;
fdif_vert_offset = y0;
fdif_x_max = x_max; // end of region of interest
fdif_y_max= y_max;
fdif_threshold = thresh; 

// if input file contains several images
image_lib_idx = image_idx;

image_db_idx =0;

// test on single picture
fdif_test = 0x100; 
flag_input_source = 3; // load from gel
flag_data_load = 2; // load in DDR
fdif_int_enabled = 1; // use interrupt
fdif_run_core = 1; // run on a9 0
flag_display_results =1; 
flag_print_results = 0;
gel_init_done = 1;
}


dialog  FDIF_InitTest_WakeUP( fd_core "Run on: A9-1;M3_0- 2;M3_1-3; C64-4",
                              use_int "End Of Detect:0:polling - 1:Interrupt",
                              uart_out "Trace on UART- 0 ; DDR - 1" )
{
fdif_run_core = fd_core;
// use interrupt handler to wait end of FD or poll register
fdif_int_enabled = use_int;
use_sw_uart = uart_out;

fdif_test = 0x10; // test wake-up
image_lib_idx = 1;
image_db_idx =0; // default, useless here
flag_input_source = 1; // load from DDR


// to kick off execution
gel_init_done = 1;
}

dialog FDIF_InitTest_DataBase(db_idx "databse index(1-7)",
                              uart_out "Trace on UART- 0 ; DDR - 1" )
{

use_sw_uart = uart_out;
fdif_test = 0x20;

image_lib_idx = 1;
if ((db_idx > 0) && (db_idx < 8)) {// max database index 
	image_db_idx =db_idx;
	image_db_idx_max = db_idx;
}	
else { // loop on all DBs
	image_db_idx = 1;
	image_db_idx_max = 7;
}
flag_input_source = 3; // load from GEL
flag_data_load = 2; // working data buffer in DDR
fdif_int_enabled = 1;
fdif_run_core = 1;
gel_init_done = image_db_idx_max - image_db_idx + 1;
}

dialog FDIF_InitTest_PerfStat(uart_out "Trace on UART- 0 ; DDR - 1" )
{
use_sw_uart = uart_out;

fdif_test = 0x50;

image_lib_idx = 1;
image_db_idx =0;

flag_input_source = 1; // load from DDR
flag_data_load = 2; // working data buffer in DDR
fdif_int_enabled = 1;
fdif_run_core = 1;
fdif_face_size = 0;
fdif_test_perf = 1; // start by size min sub test

gel_init_done = 1;

}

dialog FDIF_InitTest_Iss(nb_frames "Number of frames",
                          uart_out "Trace on UART- 0 ; DDR - 1" )
{
use_sw_uart = uart_out;
MaxNbFrames = nb_frames;

fdif_test = 0x30;

image_lib_idx = 0;
image_db_idx =0;

flag_input_source = 4; // load from camera
flag_data_load = 2; // working data buffer in DDR
fdif_int_enabled = 1;
fdif_run_core = 1;
fdif_face_size = 2;
init_test_done = 0;

gel_init_done = 1;

}