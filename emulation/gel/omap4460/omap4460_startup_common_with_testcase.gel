/*******************************************************************/ 
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/* OMAP4460 startup common    		     						   */
/*                                                                 */
/*                                                                 */
/*  Author: Salamito thomas				     					   */
/*******************************************************************/

OnTargetConnect()
{ 
    omap4430_startup_sequence();
    GEL_TextOut("--->>> omap4460_startup_sequence DONE !!!!!  <<<---\n");
}

onResetDetected()
{
    GEL_TextOut("--->>> System Reset detected <<<---\n");
    // commented for the moment feature not availablein CCS 
    // omap4430_startup_sequence(); 
}

OnReset()
{

    int device_type;
    
    int silicon_type;
    
    int ID_CODE	  = *(int*)0x4A002204;
    
    silicon_type = (ID_CODE & 0xE0000000) >> 28;
    
    GEL_TextOut("--->>> Reset occurs <<<---\n");
    
    
    device_type = *(int*)0x4A0022C4;
    
    if (((device_type & 0x300)>>8) == 0x3)
    {
        GEL_TextOut("--->>> GP device <<<---\n"); 
        
        if  (silicon_type == 2)
        {
            //PC=0x28000;
            PC=0x28000;
        }
        else
        {  
             PC=0x20000;
        } 
        CPSR=0x193; 
    }
    
    if (((device_type & 0x300) >> 8) == 0x1)
    { 
        GEL_TextOut("--->>> EMU device <<<---\n");
        CPSR=0x1D3; 
    }
    
	//Enter_Secure_Mode();
	//Secure_Watchdog_disable();
	//Enter_Non_Secure_Mode();
    // Watchdog_disable();
}

omap4460_startup_sequence()
{  
    int device_type;
    int reg;
    
    char phoenixVersion;
    
    int ID_CODE	  = *(int*)0x4A002204;
    
    int silicon_type;
    
	GEL_TextOut("--->>> omap4460_startup_sequence <<<---\n");
    
    silicon_type = (ID_CODE & 0xE0000000) >> 28;
	
	if  (silicon_type == 2) 
    {
        GEL_TextOut("--->>> OMAP 4460 ES 2.1 Device <<<---\n");
    }
    else
    {
        GEL_TextOut("--->>> OMAP 4460 ES 2.0 or ES 1.0 Device <<<---\n");
    }
	
    device_type = *(int*)0x4A0022C4;
    
    if (((device_type & 0x300)>>8) == 0x3)
    { 
            GEL_TextOut("--->>> GP device <<<---\n"); 
            
            reconfigure_gpmc();
    }
    
    if (((device_type & 0x300) >> 8) == 0x2)
    { 
            GEL_TextOut("--->>> HS device <<<---\n"); 
    }
    
  	if (((device_type & 0x300) >> 8) == 0x1)
    { 
            GEL_TextOut("--->>> EMU device <<<---\n"); 
    }
    
    if (((device_type & 0x300) >> 8) == 0x0)
    { 
            GEL_TextOut("--->>> TEST device <<<---\n"); 
    }           
    
    if (((device_type & 0x300) >> 8) != 3)
    {  
        //Enter_Secure_Mode();
        //Secure_Watchdog_disable();
	//Enter_Non_Secure_Mode(); /* changed for GPMC access */
    }
   
   /* Disable Watchdog timer WDT2 */
   Watchdog_disable();
 
   /* Setup sys.clk = 38.4MHz       */
   //SelectSysClock_38_4MHz();
   
   /* set CORE3 to 1.1V */
/* with EEPROM 05, default VCORE3 value is OPP50, i.e 0.975V. */
/* This is at risk for LPDDR2 code downloading at OPP100_ES20 speed */
/* (even worst @ OPP100).  uTEB are equipped with Phoenix Power */
/* EEPROM 05, and users are not suffering so much while PAB users are. */

   //omap4460_PHOENIX_Init();

   //PHOENIX_I2C_Read8(PHOENIX_I2C_SLAVE_ADDRESS, 0xDF, phoenixVersion);

   Force_PMIC_VCORE(PHOENIX_PMIC_VCORE1_CFG_FORCE_REG, 1100);
   Force_PMIC_VCORE(PHOENIX_PMIC_VCORE2_CFG_FORCE_REG, 1100);
   Force_PMIC_VCORE(PHOENIX_PMIC_VCORE3_CFG_FORCE_REG, 1100);
   
   /* Fast download set to ON     */
   // Set_AHB_download_ON();
   
   // Initialise I2C config for configuring PHoenix
   // I2C_Init();
   
//   ddr_config_top(OPP100,SAMSUNG);
//   ddr_config_top(OPP50,SAMSUNG);
//   ddr_config_top(OPP25,SAMSUNG);

//   ddr_config_top(OPP100,ELPIDA2X2GBIT);
//   ddr_config_top(OPP50,ELPIDA2X2GBIT);
//   ddr_config_top(OPP25,ELPIDA2X2GBIT);
//   ddr_config_top(OPP100_SDC,ELPIDA2X2GBIT);
//	 ddr_config_top(OPP100_ES20,ELPIDA2X2GBIT);
//   ddr_config_top(OPP50_SDC,ELPIDA2X2GBIT);
//   ddr_config_top(OPP25_SDC,ELPIDA2X2GBIT);

//   ddr_config_top(OPP100,ELPIDA4X2GBIT);
//   ddr_config_top(OPP50,ELPIDA4X2GBIT);
//   ddr_config_top(OPP25,ELPIDA4X2GBIT);
//   ddr_config_top(OPP100_SDC,ELPIDA4X2GBIT);
//   ddr_config_top(OPP100_ES20,ELPIDA4X2GBIT);   
//   ddr_config_top(OPP50_SDC,ELPIDA4X2GBIT);
//   ddr_config_top(OPP25_SDC,ELPIDA4X2GBIT);

//   ddr_config_top(OPP100,HYNIX);
//   ddr_config_top(OPP50,HYNIX);
//   ddr_config_top(OPP25,HYNIX);

//   ddr_config_top(OPP100_SDC,MICRON);
//   ddr_config_top(OPP50_SDC,MICRON);
//   ddr_config_top(OPP25_SDC,MICRON);
   
//   opp_default_config_board(OPP100);	
//   opp_default_config_board(OPP50);	
//   opp_default_config_board(OPP25);	
//   opp_default_config_board(OPP100_SDC);
//	 opp_default_config_board(OPP100_ES20);
//   opp_default_config_board(OPP50_SDC);	
//   opp_default_config_board(OPP25_SDC);	

	/* Set clock config to OPP3 */
	//opp_default_config_zebu();
    
    
    
     /* DDR memory config */
     //zebu_ddr_config();
     //elpida_E1471E10_ddr_config_EMIF4D1_AND_EMIF4D2_wakeUp();
     //elpida_E1471E10_ddr_config_EMIF4D1_AND_EMIF4D2_boot();
     //elpida_E1471E10_ddr_config_EMIF4D1_AND_EMIF4D2_wakeUp(); 

     /* GPMC PSRAM Configuration to access all 26 bits of Address */
     *(int*) 0x4A100060 = 0x01080108; /* PAD0_GPMC_A16_PAD1_GPMC_A17 */
     *(int*) 0x4A100064 = 0x01080108; /* PAD0_GPMC_A18_PAD1_GPMC_A17 */
     *(int*) 0x4A100068 = 0x01080108; /* PAD0_GPMC_A20_PAD1_GPMC_A19 */
     *(int*) 0x4A10006Comap4430_i2c_driver.gel = 0x01080108; /* PAD0_GPMC_A22_PAD1_GPMC_A21 */
     *(int*) 0x4A100070 = 0x01080108; /* PAD0_GPMC_A24_PAD1_GPMC_A23 */
	 *(int*) 0x4A100088 = 0x01180108; /* PAD0_GPMC_NBE1_PAD1_GPMC_WAIT0 */

     /* GPMC Config to remove limited address restriction */
     reg = *(int*) 0x50000050;
     *(int*) 0x50000050 = reg | 0x2;

     GEL_TextOut("--->>> GPMC Reconfiguration Complete <<<---\n");

    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is in SECURE state!\n");
    }

   Activate_Fast_download_using_DAP();
				
	// Force LPDDR2 IO keeper mode & Reset DDR PHYs
	if  (silicon_type != 2)
	{
		force_keeper();
	}		
}

reconfigure_gpmc()
{
      int value;
      
      GEL_TextOut("Reconfigure PSRAM for accessing if device type = GP \n");
      
      value = *(int*) 0x4A004120;
      value &= 0xFFFFFFF8;
      value |= 5;
      *(int*) 0x4A004120 = value;
      
      *(int*) 0x50000060 = 0x1200;
      
      *(int*) 0x50000078 = 0xF48; 
     
     *(int*) 0x4A100040 = 0x01180118; 
       
     *(int*) 0x4A100040 = 0x01180118; 
     *(int*) 0x4A100044 = 0x01180118; 
     *(int*) 0x4A100048 = 0x01180118; 
     *(int*) 0x4A10004C = 0x01180118; 
     *(int*) 0x4A100050 = 0x01180118; 
     *(int*) 0x4A100054 = 0x01180118; 
     *(int*) 0x4A100058 = 0x01180118; 
     *(int*) 0x4A10005c = 0x01180118; 
     

    /* GPMC PSRAM Configuration to access all 26 bits of Address */
     *(int*) 0x4A100060 = 0x01000100; /* PAD0_GPMC_A16_PAD1_GPMC_A17 */
     *(int*) 0x4A100064 = 0x01000100; /* PAD0_GPMC_A18_PAD1_GPMC_A17 */
     *(int*) 0x4A100068 = 0x01000100; /* PAD0_GPMC_A20_PAD1_GPMC_A19 */
     *(int*) 0x4A10006C = 0x01000100; /* PAD0_GPMC_A22_PAD1_GPMC_A21 */
     *(int*) 0x4A100070 = 0x01000100; /* PAD0_GPMC_A24_PAD1_GPMC_A23 */
	 // *(int*) 0x4A100088 = 0x01180108; /* PAD0_GPMC_NBE1_PAD1_GPMC_WAIT0 */

    value = *(int*) 0x4A10007c;
    value &= 0xFFFFFFFE;
    *(int*) 0x4A10007c = value;
    
    value = *(int*) 0x50000050;
    value &= 0xFFFFFFFB;
    *(int*) 0x50000050 = value;
    
     //PC=0x800000;
    
}    

hotmenu Activate_Fast_download_using_DAP()
{

    if ((REG_SYSTEM_TARGET_STATUS & 0x80) != 0x80)
    {
       REG_SYSTEM_TARGET_CONTROL = 0x80; /* Turn on DAP download in CA9 driver */
    }
     
     GEL_TextOut("--->>> Using the CA9 driver with DAP download for images <<<---\n");
}



hotmenu Desactivate_Fast_download_using_DAP()
{

    GEL_TextOut("--->>> For loading Internal image in CortexA9 CPU0 (0x402f0000), fast download must be deasactivated  <<<---\n");
    
    if ((REG_SYSTEM_TARGET_STATUS & 0x80) == 0x80)
    {
       REG_SYSTEM_TARGET_CONTROL = 0x80; /* Turn off DAP download in CA9 driver */
    }
     
     GEL_TextOut("--->>> removing the CA9 driver with DAP download for images <<<---\n");
}


hotmenu Enter_Non_Secure_Mode()
{
    int reg;
    GEL_TextOut("--->>> Enter Non secure Mode <<<---\n");

    REG_TZ_SECURE = 0;
    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is still in SECURE state!\n");
    }
}

hotmenu Enter_Secure_Mode()
{
    int reg;
    GEL_TextOut("--->>> Enter secure Mode <<<---\n");

    REG_TZ_SECURE = 1;
    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is still in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is in SECURE state!\n");
    }
}

hotmenu Watchdog_disable()
{
	GEL_TextOut("--->>> Start WDT2 Watchdog Timer is disabled <<<---\n");
	 
   /* Enable clock */
   *(int*)0x4A307830 = 0x02;

   /* Check that module is Idle */
   while (((*(int *)0x4A307830) & 0x20000));
       
   /* Disable  watchdog 2 */
   /* Wait until reset complete */
   while (!((*(int *)0x4A314014) & 0x01));

   /* Disable watchdog timer */
   *(int*)0x4A314048 = 0x0000AAAA;

   while (((*(int *)0x4A314034) & 0x10));

   /* Disable 32Khz watchdog timer */
   *(int*)0x4A314048 = 0x00005555;

   while (((*(int *)0x4A314034) & 0x10));

   GEL_TextOut("--->>> End WDT2 Watchdog Timer is disabled <<<---\n");
}

hotmenu Secure_Watchdog_disable()
{
	GEL_TextOut("--->>> Start Secure Watchdog Timer is disabled <<<---\n");
	
   /* enable clock */
   *(int*)0x4A307828 = 0x02;

   /* Check that module is Idle */
   while (((*(int *)0x4A307828) & 0x20000));
       
   /* Disable  watchdog 2 */
   /* Wait until reset complete */
   while (!((*(int *)0x4A322014) & 0x01));

   /* Disable watchdog timer */
   *(int*)0x4A322048 = 0x0000AAAA;

   while (((*(int *)0x4A322034) & 0x10));

   /* Disable 32Khz watchdog timer */
   *(int*)0x4A322048 = 0x00005555;

   while (((*(int *)0x4A322034) & 0x10));

   GEL_TextOut("--->>> End Secure Watchdog Timer is disabled <<<---\n");
}

hotmenu force_keeper()
{
  int dummy_read;

  GEL_TextOut("--->>> Force DQS pulls to keeper <<<---\n");
  *(int*)0x4A10063C = 0x9E9E9E9C;
  *(int*)0x4A100640 = 0x9C9C9E9C;
  *(int*)0x4A10064C = 0x9E9E9E9C;
  *(int*)0x4A100650 = 0x9C9C9E9C;

  // Dummy read in LPDDR2
  dummy_read = *(int*)0x80000000; //EMIF1
  dummy_read = *(int*)0x80000080; //EMIF2

  *(int*)0x4C000060 = 0x00002411;
  *(int*)0x4D000060 = 0x00002411;

  GEL_TextOut("--->>> Keeper force done <<<---\n");

}
