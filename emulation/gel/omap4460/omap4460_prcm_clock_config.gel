/*******************************************************************/ 
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/* OMAP4460 prcm clock config   		     					   */
/*                                                                 */
/*                                                                 */
/*  Author: Salamito thomas				     					   */
/*******************************************************************/

/**********************************************************************
 *
 *  DEFINITIONS
 *
 **********************************************************************/
 
#define INFO_PRINT	0
 
 
// OPP definitions

#define	OPPBOOT		0
#define	OPP50		1
#define	OPP100		2
#define	OPPTURBO	3
#define	OPPNITRO	4
#define	OPPNITROSB	5


#define SAMSUNG		1
#define ELPIDA2X2GBIT	2
#define ELPIDA4X2GBIT	3
#define HYNIX		4
#define MICRON		5
#define ZEBU		11


//SYS Clock Frequencies definition


// DPLL definitions
#define PRM_BASE        0x4A306100
#define CAM_CM2_BASE    0x4A009000
#define	FREF			38400	// DPLL reference frequency in KHZ

//#define	DPLL_TIMEOUT	5000	// DPLL lock/unlock timeout
#define	DPLL_TIMEOUT	5		// DPLL lock/unlock timeout

// Register definitions
#define CKGEN_CM1_BASE_ADDRESS		0x4A004100

#define CM_CORE_BASE        		(CKGEN_CM1_BASE_ADDRESS + 0x20)
#define CM_MPU_BASE         		(CKGEN_CM1_BASE_ADDRESS + 0x60)
#define CM_IVA_BASE         		(CKGEN_CM1_BASE_ADDRESS + 0xA0)
#define CM_ABE_BASE         		(CKGEN_CM1_BASE_ADDRESS + 0xE0)

#define CM_CLKSEL_CORE				*(unsigned int *)(CKGEN_CM1_BASE_ADDRESS)
#define CM_CLKSEL_ABE                       *(unsigned int *)(CM_ABE_BASE + 0x0C)

#define CM_CLKMODE_DPLL(DPLL_BASE_ADDRESS)  *(unsigned int *)(DPLL_BASE_ADDRESS)
#define CM_IDLEST_DPLL(DPLL_BASE_ADDRESS)   *(unsigned int *)(DPLL_BASE_ADDRESS + 0x04)
#define CM_AUTOIDLE_DPLL(DPLL_BASE_ADDRESS) *(unsigned int *)(DPLL_BASE_ADDRESS + 0x08)

#define CM_CLKSEL_DPLL(DPLL_BASE_ADDRESS)   *(unsigned int *)(DPLL_BASE_ADDRESS + 0x0C)
#define CM_DIV_M2_DPLL(DPLL_BASE_ADDRESS)   *(unsigned int *)(DPLL_BASE_ADDRESS + 0x10)
#define CM_DIV_M3_DPLL(DPLL_BASE_ADDRESS)   *(unsigned int *)(DPLL_BASE_ADDRESS + 0x14)
#define CM_DIV_M4_DPLL(DPLL_BASE_ADDRESS)   *(unsigned int *)(DPLL_BASE_ADDRESS + 0x18)
#define CM_DIV_M5_DPLL(DPLL_BASE_ADDRESS)   *(unsigned int *)(DPLL_BASE_ADDRESS + 0x1C)
#define CM_DIV_M6_DPLL(DPLL_BASE_ADDRESS)   *(unsigned int *)(DPLL_BASE_ADDRESS + 0x20)
#define CM_DIV_M7_DPLL(DPLL_BASE_ADDRESS)   *(unsigned int *)(DPLL_BASE_ADDRESS + 0x24)

#define CM_SYS_CLKSEL       				*(unsigned int *)(PRM_BASE + 0x10)

#define CKGEN_CM2_BASE_ADDRESS				0x4A008100
#define CM_PER_BASE         		CKGEN_CM2_BASE_ADDRESS + 0x40


#define CM_L4PER_CLKSTCTRL 				*(unsigned int *)(CAM_CM2_BASE + 0x400)

#define	dpll_freq(M,N)						(2*FREF*M/(N+1))

//------------------------
//  SYS_CLK definitions.
//------------------------
#define SYS_CLK_38_4     1
#define SYS_CLK_26       2
#define SYS_CLK_19_2     3

//default when no menu used.
int SYSCLKFREQ = SYS_CLK_38_4;

/**********************************************************************
 *
 *  FUNCTIONS
 *
 **********************************************************************/
menuitem "Power config"
hotmenu SelectSysClock_38_4MHz()
{
  GEL_TextOut("Set system clock to 38.4MHz \n");
  CM_SYS_CLKSEL = 0x07;
  SYSCLKFREQ = SYS_CLK_38_4;
}
hotmenu SelectSysClock_19_2MHz()
{
  GEL_TextOut("Set system clock to 19.2MHz \n");
  CM_SYS_CLKSEL = 0x04;
  SYSCLKFREQ = SYS_CLK_19_2;   
}
hotmenu SelectSysClock_26MHz()
{
  GEL_TextOut("Set system clock to 26MHz \n");
  CM_SYS_CLKSEL = 0x05;
  SYSCLKFREQ = SYS_CLK_26;      
}
hotmenu SelectSysClock()
{
  if (SYSCLKFREQ == SYS_CLK_38_4)
    {
      SelectSysClock_38_4MHz();
    }
  if (SYSCLKFREQ == SYS_CLK_26)
    {
      SelectSysClock_26MHz();
    }   
  if (SYSCLKFREQ == SYS_CLK_19_2)
    {
      SelectSysClock_19_2MHz();
    }       
}
non_overide()
{

  if (INFO_PRINT) {
    GEL_TextOut(">> START non_overide \n");
  }
  /* DLL_CTRL  */
  *(int*)0x4A004110 = 0x0;  // set DLL in non-override mode
  if (INFO_PRINT) {    
    GEL_TextOut(">> END non_overide \n");
  }
}
         
freq_update(int OPP)
{
  int test = 0;

  if (INFO_PRINT) {    
    GEL_TextOut(">> START freq_update \n");
  }
       
  // configure MEMIF domain in SW_WKUP
  *(int*)0x4a008b00 = 0x2;
    
  // EMIF1
  while (((*(int*)0x4a008b30)&0x30000)!=0x0);
    
  // EMIF2
  while (((*(int*)0x4a008b38)&0x30000)!=0x0);
    
  // start freq_update in CM_SHADOW_FREQ_CONFIG1 and CM_SHADOW_FREQ_CONFIG2
    
  if (OPP == OPPTURBO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPPNITRO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPPNITROSB)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
    
  if (OPP == OPP100)
    {
      *(int*)0x4a004264 = 0x25;
      *(int*)0x4a004260 = 0xF09;
      //*(int*)0x4a004260 = 0xF0D;
    }
    
  if (OPP == OPP50)
    {
      *(int*)0x4a004264 = 0x45;
      *(int*)0x4a004260 = 0x1709;
      //*(int*)0x4a004260 = 0x170D;
    }
     
  // wait for CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE to be cleared by PRCM
  while ((*(int*)0x4a004260&0x1)==0x1);
    
  // configure MEMIF domain back in HW_AUTO
  *(int*)0x4a008b00 = 0x3;
    
  if (OPP == OPP100)
    {
      *(int*)0x4a004264 = 0x24;
    }
  if (OPP == OPP50)
    {
      *(int*)0x4a004264 = 0x44;
    }
    
  while (test<10000)
    {
      test=test+1;
    }
        
    
 

  if (INFO_PRINT) {               
    GEL_TextOut(">> END freq_update \n");   
  }     
    
}   

hotmenu opp_default_config_board_OPPNITROSB()
{
  GEL_TextOut("-----------------------\n");
  GEL_TextOut("------ Applying OPPNITROSB ------\n");
  GEL_TextOut("-----------------------\n");
  opp_config_board(OPPNITROSB);
}

hotmenu opp_default_config_board_OPPNITRO()
{
  GEL_TextOut("-----------------------\n");
  GEL_TextOut("------ Applying OPPNITRO ------\n");
  GEL_TextOut("-----------------------\n");
  opp_config_board(OPPNITRO);
}

hotmenu opp_default_config_board_OPPTURBO()
{
  GEL_TextOut("-----------------------\n");
  GEL_TextOut("------ Applying OPPTURBO ------\n");
  GEL_TextOut("-----------------------\n");
  opp_config_board(OPPTURBO);
}      

hotmenu opp_default_config_board_OPP100()
{
  GEL_TextOut("-----------------------\n");
  GEL_TextOut("------ Applying OPP100 ------\n");
  GEL_TextOut("-----------------------\n");
  opp_config_board(OPP100);
}

hotmenu opp_default_config_board_OPP50()
{
  GEL_TextOut("-----------------------\n");
  GEL_TextOut("------------ Applying OPP50 ------------\n");
  GEL_TextOut("-----------------------\n");
  opp_config_board(OPP50);
}


hotmenu opp_change_elpida_2x2gbit_4x2gbit_opp100()
{
  elpida_EDB8064B1PB8DF_EMIF4D1_shadow_reg(OPPBOOT);
  elpida_EDB8064B1PB8DF_EMIF4D2_shadow_reg(OPPBOOT);
  core_dpll_unlock();
  elpida_EDB8064B1PB8DF_EMIF4D1_shadow_reg(OPP100);
  elpida_EDB8064B1PB8DF_EMIF4D2_shadow_reg(OPP100);
  core_dpll_set_dividers(OPP100);
  core_dpll_lock(OPP100);
}
hotmenu opp_change_elpida_2x2gbit_4x2gbit_opp50()
{
  elpida_EDB8064B1PB8DF_EMIF4D1_shadow_reg(OPPBOOT);
  elpida_EDB8064B1PB8DF_EMIF4D2_shadow_reg(OPPBOOT);
  core_dpll_unlock();
  elpida_EDB8064B1PB8DF_EMIF4D1_shadow_reg(OPP50);
  elpida_EDB8064B1PB8DF_EMIF4D2_shadow_reg(OPP50);
  core_dpll_set_dividers(OPP50);
  core_dpll_lock(OPP50);
}

/******************************************************************************
 * core_dpll_unlock() : CORE DPLL unlock sequence
 *****************************************************************************/
core_dpll_unlock()
{
  int test = 0;

  if (INFO_PRINT) {    
    GEL_TextOut(">> START setting CORE DPLL in bypass mode \n");
  }
    
  // configure MEMIF domain in SW_WKUP
  *(int*)0x4a008b00 = 0x2;
    
  // EMIF1
  while (((*(int*)0x4a008b30)&0x30000)!=0x0);
    
  // EMIF2
  while (((*(int*)0x4a008b38)&0x30000)!=0x0);

  // CM_SHADOW_FREQ_CONFIG_2 (GPMC FREQ_UPDATE = 1)
  *(int*)0x4a004264 = 0x1;

  // CM_SHADOW_FREQ_CONFIG_1 (start freq update to go to bypass mode)
  *(int*)0x4a004260 = 0x40D;
    
  // wait for CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE to be cleared by PRCM
  while ((*(int*)0x4a004260&0x1)==0x1);
    
  // configure MEMIF domain back in HW_AUTO
  *(int*)0x4a008b00 = 0x3;

  // CM_SHADOW_FREQ_CONFIG_2 (GPMC FREQ_UPDATE back to 0)
  *(int*)0x4a004264 = 0;

  while (test<10000)
    {
      test=test+1;
    }
        
  if (INFO_PRINT) {    
    GEL_TextOut(">> END setting CORE DPLL in bypass mode \n");    
  }    

}

/******************************************************************************
 * core_dpll_lock() : CORE DPLL lock from bypass sequence
 *****************************************************************************/
core_dpll_lock(int OPP)
{

  int test = 0;
    
  if (INFO_PRINT) {
    GEL_TextOut(">> START setting CORE DPLL in lock mode \n");
  }
    
  // configure MEMIF domain in SW_WKUP
  *(int*)0x4a008b00 = 0x2;
    
  // EMIF1
  while (((*(int*)0x4a008b30)&0x30000)!=0x0);
    
  // EMIF2
  while (((*(int*)0x4a008b38)&0x30000)!=0x0);

  // start freq_update in CM_SHADOW_FREQ_CONFIG1 and CM_SHADOW_FREQ_CONFIG2
    
  if (OPP == OPPTURBO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPPNITRO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPPNITROSB)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPP100)
    {
      *(int*)0x4a004264 = 0x25;
      *(int*)0x4a004260 = 0xF09;
      //*(int*)0x4a004260 = 0xF0D;
    }
  if (OPP == OPP50)
    {
      *(int*)0x4a004264 = 0x45;
      *(int*)0x4a004260 = 0x1709;
    }
    
  // wait for CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE to be cleared by PRCM
  if (INFO_PRINT) {    
    GEL_TextOut(">> waiting for FREQ_UPDATE bit to be cleared \n");
  }
  while ((*(int*)0x4a004260&0x1)==0x1);
  if (INFO_PRINT) {    
    GEL_TextOut(">> FREQ_UPDATE bit cleared \n");
  }
    
  // configure MEMIF domain back in HW_AUTO
  *(int*)0x4a008b00 = 0x3;
    
  if (OPP == OPPTURBO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPPNITRO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPPNITROSB)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  // CM_SHADOW_FREQ_CONFIG_2 (GPMC FREQ_UPDATE back to 0)
  if (OPP == OPP100)
    {
      *(int*)0x4a004264 = 0x24;
    }
    
  if (OPP == OPP50)
    {
      *(int*)0x4a004264 = 0x44;
    }
    
  while (test<10000)
    {
      test=test+1;
    }
  if (INFO_PRINT) {
    GEL_TextOut(">> END setting CORE DPLL in lock mode \n");
  }

}


/******************************************************************************
 * core_dpll_set_dividers() : set CORE DPLL dividers
 *****************************************************************************/
core_dpll_set_dividers(int OPP)
{

  int test = 0;
    
  if (INFO_PRINT) {
    GEL_TextOut(">> START setting CORE DPLL dividers \n");
  }
    
  // Program L3 & L4 dividers from CORE DPLL
  // L3 clock = CORE CLK /2; L4 clock = L3 clock /2; CORE_CLK=CORE_X2_CLK/1
  CM_CLKSEL_CORE = 0x110;
    
  if (OPP == OPPTURBO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPPNITRO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if (OPP == OPPNITROSB)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }

  // set HS DIVIDERS
  if (OPP == OPP100)
    {

      // CM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV = 1
      CM_DIV_M2_DPLL(CM_CORE_BASE) = 0x1;
							 
      // CM_DIV_M3_DPLL_CORE.DPLL_CLKOUT_DIV = 5
      CM_DIV_M3_DPLL(CM_CORE_BASE) = 0x5;
    
      // CM_DIV_M4_DPLL_CORE.HSDIVIDER_CLKOUT1_DIV = 8
      CM_DIV_M4_DPLL(CM_CORE_BASE) = 0x8;
    
      // CM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 4
      CM_DIV_M5_DPLL(CM_CORE_BASE) = 0x4;
    
      // CM_DIV_M6_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 6
      // M6 clock is used for debugSS and EMU Clock
      // Should be equals to CORE_DPLL / 0x6 (1322/0x6 -> 220MHzs)
      CM_DIV_M6_DPLL(CM_CORE_BASE) = 0x6;
    
      // CM_DIV_M7_DPLL_CORE.HSDIVIDER_CLKOUT3_DIV = 8
      CM_DIV_M7_DPLL(CM_CORE_BASE) = 0x8;
    }
    
  if (OPP == OPP50)
    {
      // CM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV = 2
      CM_DIV_M2_DPLL(CM_CORE_BASE) = 0x2;
        
      // CM_DIV_M3_DPLL_CORE.DPLL_CLKOUT_DIV = 5
      CM_DIV_M3_DPLL(CM_CORE_BASE) = 0x5;
    
      // CM_DIV_M4_DPLL_CORE.HSDIVIDER_CLKOUT1_DIV = 8
      CM_DIV_M4_DPLL(CM_CORE_BASE) = 0x8;
    
      // CM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 4
      CM_DIV_M5_DPLL(CM_CORE_BASE) = 0x4;
    
      // CM_DIV_M6_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 6
      // M6 clock is oused for debugSS and EMU Clock
      // Should be equals to CORE_DPLL / 0x6 (1322/0x6 -> 220MHzs)
      CM_DIV_M6_DPLL(CM_CORE_BASE) = 0x6;
    
      // CM_DIV_M7_DPLL_CORE.HSDIVIDER_CLKOUT3_DIV = 8
      CM_DIV_M7_DPLL(CM_CORE_BASE) = 0x8;
    }
    
  // set CORE DPLL MUL & DIV parameters
  if((OPP == OPP100)||(OPP == OPP50))
    {
      //	CM_CLKSEL_DPLL(CM_CORE_BASE) = 0x5 | (0x7D << 8);

      //	CM_CLKSEL_DPLL(CM_CORE_BASE) = 0x7D05;
      CM_CLKSEL_DPLL(CM_CORE_BASE) = 0x1F416; // According Greg PRCMLIB_CM.c
    }
    

  if (INFO_PRINT) {          
    GEL_TextOut(">> END setting CORE DPLL dividers \n");
  }

}


/******************************************************************************
 * opp_config_board() : 
 *****************************************************************************/
opp_config_board(int OPP)		
{
  //int debug;
	
  GEL_TextOut("opp_config OPP %d\n",,,,, OPP);

  // Chiron DPLL programming
  dpll_a9_opp_config_board(OPP);
	
  // Core DPLL programming
  dpll_core_opp_config_board(OPP);
	
  // IVA & TESLA clock programming
  dpll_iva_tesla_opp_config_board(OPP);
    
  // PER DPLL programming
  dpll_per_opp_config_board(OPP);
        
  // ABE DPLL programming
  dpll_abe_opp_config_board(OPP);
    
  // Ducati clock programming (using CORE clock)
  //	dpll_ducati_coreclk_opp_config_board(OPP);
        
  if (INFO_PRINT) {
    GEL_TextOut("opp_config OPP FINISHED %d\n",,,,, OPP);
  }
}

/******************************************************************************
 * dpll_lock_board() : DPLL lock_sequence
 *****************************************************************************/
dpll_lock_board(int base_address, int OPP)
{
  unsigned int timer;

  int clksel_dpll_value;

  // Put DPLL into bypass mode
  clksel_dpll_value = CM_CLKMODE_DPLL(base_address);
  clksel_dpll_value &= ~(0x7 << 0);
  clksel_dpll_value |= (0x4 << 0);
  CM_CLKMODE_DPLL(base_address) = clksel_dpll_value;
	
  if (base_address == CM_IVA_BASE)
    {
    
      if(OPP==OPPNITROSB)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");           
        }
      if(OPP==OPPNITRO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");            
        }
        
      if(OPP==OPPTURBO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
        }
        
      if(OPP==OPP100)
        {
	  if (SYSCLKFREQ == SYS_CLK_38_4)
	    { 	
	      // Program DPLL frequency (M = 97)
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	      clksel_dpll_value |= (0x61 << 8);
	    }
	  if (SYSCLKFREQ == SYS_CLK_26)
	    { 	
	      // Program DPLL frequency (M = 394)
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	      clksel_dpll_value |= (0x18A << 8);
	    }	     
	  if (SYSCLKFREQ == SYS_CLK_19_2)
	    { 	
	      // Program DPLL frequency (M = 485)
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	      clksel_dpll_value |= (0x1E5 << 8);
	    }	     
	  CM_CLKSEL_DPLL(CM_IVA_BASE) = clksel_dpll_value;
        }
        
      if(OPP==OPP50)
        {
	  if (SYSCLKFREQ == SYS_CLK_38_4)
	    {
	      // Program DPLL frequency (M = 97)
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	      clksel_dpll_value |= (0x61 << 8);
            }
	  if (SYSCLKFREQ == SYS_CLK_26)
            {
	      // Program DPLL frequency (M = 394)
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	      clksel_dpll_value |= (0x18A << 8);  
            }
	  if (SYSCLKFREQ == SYS_CLK_19_2)
            { 	
	      // Program DPLL frequency (M = 485)
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	      clksel_dpll_value |= (0x1E5 << 8);
	    }
	  CM_CLKSEL_DPLL(CM_IVA_BASE) = clksel_dpll_value;
        }
    }
                        
                        
  if (base_address == CM_ABE_BASE)
    {
    
      if(OPP==OPPNITROSB)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");           
        }
      if(OPP==OPPNITRO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");            
        }
        
      if(OPP==OPPTURBO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
        }
        
      if((OPP==OPP100)||(OPP==OPP50))
        {	

	  // Program DPLL frequency (M = 64)
	  clksel_dpll_value = CM_CLKSEL_DPLL(CM_ABE_BASE);
	  clksel_dpll_value |= (0x40 << 8);
    
	  CM_CLKSEL_DPLL(CM_ABE_BASE) = clksel_dpll_value;
        }
    }
       
  if (base_address == CM_MPU_BASE)
    {
    
      if(OPP==OPPNITROSB)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
	  // Program DPLL frequency (M = 313)
	  //clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	  //clksel_dpll_value |= (0x139 << 8);
            
        }
      if(OPP==OPPNITRO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
	  // Program DPLL frequency (M = 125)
	  //clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	  //clksel_dpll_value |= (0x7D << 8);
        }
        
      if(OPP==OPPTURBO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
	  // Program DPLL frequency (M = 24)
	  //clksel_dpll_value = CM_CLKSEL_DPLL(CM_IVA_BASE);
	  //clksel_dpll_value |= (0x18 << 8);
        }
        
      if(OPP==OPP100)
        {  
        
	  // Program DPLL frequency (M = 73)
	  clksel_dpll_value = CM_CLKSEL_DPLL(CM_MPU_BASE);
	  clksel_dpll_value |= (0x49 << 8);
	}
	         
      if(OPP==OPP50)
        {
	  // Program DPLL frequency (M = 73)
	  clksel_dpll_value = CM_CLKSEL_DPLL(CM_MPU_BASE);
	  clksel_dpll_value |= (0x49 << 8);
        }
      CM_CLKSEL_DPLL(CM_MPU_BASE) = clksel_dpll_value;
    }

  if (base_address == CM_CORE_BASE)
    {
      clksel_dpll_value = CM_CLKSEL_DPLL(CM_CORE_BASE);
        
      if(OPP==OPPNITROSB)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");           
        }
      if(OPP==OPPNITRO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");            
        }
        
      if(OPP==OPPTURBO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
        }
        
      if ((OPP==OPP100)||(OPP==OPP50))
        {
	  if (SYSCLKFREQ == SYS_CLK_38_4)
	    {	    
	      // Program DPLL frequency (M = 500)
	      //clksel_dpll_value |= (0x7D << 8);
	      clksel_dpll_value |= (0x1F4 << 8);
	    }
	  if (SYSCLKFREQ == SYS_CLK_26)
	    {
	      // Program DPLL frequency (M = 800 )
	      clksel_dpll_value |= (0x320 << 8);	       
	    }
	  if (SYSCLKFREQ == SYS_CLK_19_2)
	    {
	      // Program DPLL frequency (M = 500)
	      clksel_dpll_value |= (0x1F4 << 8);	       
	    }	       
	}
      CM_CLKSEL_DPLL(CM_CORE_BASE) = clksel_dpll_value;
    }
    

  if (base_address == CM_PER_BASE)
    {
    
      if(OPP==OPPNITROSB)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");           
        }
      if(OPP==OPPNITRO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");            
        }
        
      if(OPP==OPPTURBO)
        {
	  GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
        }
        
      if((OPP==OPP100)||(OPP==OPP50))
        {
	  if (SYSCLKFREQ == SYS_CLK_38_4)
	    {  	
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_PER_BASE);
	      //clksel_dpll_value |= ( 0xa << 8);
	      clksel_dpll_value |= ( 0x280 << 8);
	    }
	  if (SYSCLKFREQ == SYS_CLK_26)
	    { 	
	      //M=768   
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_PER_BASE);
	      clksel_dpll_value |= ( 0x300 << 8);
	    }	
	  if (SYSCLKFREQ == SYS_CLK_19_2)
	    { 	
	      //M=640   
	      clksel_dpll_value = CM_CLKSEL_DPLL(CM_PER_BASE);
	      clksel_dpll_value |= ( 0x280 << 8);
	    }	   	      
	  CM_CLKSEL_DPLL(CM_PER_BASE) = clksel_dpll_value;
        }
    }  

  // Put DPLL into lock mode
    
  if (base_address != CM_CORE_BASE)
    {
      CM_CLKMODE_DPLL(base_address) = 7;
    }
  else
    {
      freq_update(OPP);
    }
    	
  // Wait for DPLL to be locked
  timer = 0;
  while( ((CM_IDLEST_DPLL(base_address) & 0x1) != 0x1) && (timer++<DPLL_TIMEOUT) );

  if( timer >= DPLL_TIMEOUT )
    {
      GEL_TextOut("ERROR: timeout while locking DPLL \n");
      return -1;
    }
  else
    {
      if (INFO_PRINT) {  		
	GEL_TextOut("Locked board DPLL successfully \n");
      }        		
      return 0;
    }
}

/******************************************************************************
 * dpll_a9_opp_config_board() : Cortex A9 DPLL OPP configurations (OPP100 for SDC)
 *****************************************************************************/
dpll_a9_opp_config_board(int OPP)
{  
  
  if (INFO_PRINT) {   
    GEL_TextOut("> Cortex A9 DPLL BOARD OPP %d\n",,,,, OPP);
  }

  if (OPP == OPPTURBO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
            
      // Program DPLL frequency (D = 0)
      // CM_CLKSEL_DPLL(CM_MPU_BASE) = 0x0;
        
      // Program DPLL_CLKOUT divider (M2 = 1)
      // CM_DIV_M2_DPLL(CM_MPU_BASE) = 0x1;
        
      // dpll_lock_board(CM_MPU_BASE, OPP);
    }
    
  if (OPP == OPPNITRO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
            
      // Program DPLL frequency (D = 7)
      // CM_CLKSEL_DPLL(CM_MPU_BASE) = 0x7;
        
      // Program DPLL_CLKOUT divider (M3 = 1)
      // CM_DIV_M3_DPLL(CM_MPU_BASE) = 0x1;
        
      // dpll_lock_board(CM_MPU_BASE, OPP);
    }
    
  if (OPP == OPPNITROSB)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
            
      // Program DPLL frequency (D = 15)
      // CM_CLKSEL_DPLL(CM_MPU_BASE) = 0xF;
        
      // Program DPLL_CLKOUT divider (M3 = 1)
      // CM_DIV_M3_DPLL(CM_MPU_BASE) = 0x1;
        
      // dpll_lock_board(CM_MPU_BASE, OPP);
    }
    
  // M & N parameters are fixed
  if( OPP == OPP50 )
    {
      // Program DPLL frequency (D = 3)
      CM_CLKSEL_DPLL(CM_MPU_BASE) = 0x3;
        
      // Program DPLL_CLKOUT divider (M2 = 2)
      CM_DIV_M2_DPLL(CM_MPU_BASE) = 0x2;
        
      dpll_lock_board(CM_MPU_BASE, OPP);
    }
  else if( OPP == OPP100)
    {
  	  
      // Program DPLL frequency (D = 3)
      CM_CLKSEL_DPLL(CM_MPU_BASE) = 0x3;
    
      // Program DPLL_CLKOUT divider (M2 = 1)
      CM_DIV_M2_DPLL(CM_MPU_BASE) = 0x1;
    
      dpll_lock_board(CM_MPU_BASE, OPP);
    }
	    	
  if (INFO_PRINT) {
    GEL_TextOut("< Cortex A9 DPLL BOARD OPP %d\n",,,,, OPP);    
  } 
        	  
}


/******************************************************************************
 * dpll_core_opp_config_board() : CORE DPLL OPP configurations (OPP100) for SDC
 *****************************************************************************/
dpll_core_opp_config_board(int OPP)
{
  //int debug; //E.R
  if (INFO_PRINT) {     
    GEL_TextOut("> CORE DPLL BOARD OPP %d\n",,,,, OPP);
  }
	
  // Program L3 & L4 dividers from CORE DPLL
  /* L3 clock = CORE CLK /2; L4 clock = L3 clock /2; CORE_CLK=CORE_X2_CLK/1 */
  CM_CLKSEL_CORE = 0x110;
    
  //---------------------------------------------
  //E.R debug: add Print reg: CM_CLKSEL_DPLL_CORE 
  //---------------------------------------------  

  //debug = (*(int*)0x4a00412C);
  // GEL_TextOut("> Dump register CM_CLKSEL_DPLL_CORE begining dpll_core_opp_config_board: %d\n",,,,, debug);	
  // M & N parameters are fixed
       
  if(OPP==OPPNITROSB)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");           
    }
  if(OPP==OPPNITRO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");            
    }
        
  if(OPP==OPPTURBO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }

  if ((OPP == OPP100)||(OPP == OPP50))
    {
      if (SYSCLKFREQ == SYS_CLK_38_4)
	{	    
	  /* CM_CLKSEL_DPLL_CORE.PLL_DIV = 0xB */
	  //CM_CLKSEL_DPLL(CM_CORE_BASE) = 0x05;
	  //CM_CLKSEL_DPLL(CM_CORE_BASE) = 0xB;
	  //CM_CLKSEL_DPLL(CM_CORE_BASE) = 0x17;
	  CM_CLKSEL_DPLL(CM_CORE_BASE) = 0x14;
	}
      if (SYSCLKFREQ == SYS_CLK_26)
	{	    
	  CM_CLKSEL_DPLL(CM_CORE_BASE) = 0x19;
	}
      if (SYSCLKFREQ == SYS_CLK_19_2)
	{	    
	  CM_CLKSEL_DPLL(CM_CORE_BASE) = 0xB;
	}	       	       
    }
  if ((OPP == OPP100))
    {		 
      // CM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV = 1
      CM_DIV_M2_DPLL(CM_CORE_BASE) = 0x1;
													
													       
      /* CM_DIV_M3_DPLL_CORE.DPLL_CLKOUT_DIV = 5 */
      CM_DIV_M3_DPLL(CM_CORE_BASE) = 0x5;
    
      /* CM_DIV_M4_DPLL_CORE.HSDIVIDER_CLKOUT1_DIV = 8 */
      CM_DIV_M4_DPLL(CM_CORE_BASE) = 0x8;
    
      /* CM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 4 */
      CM_DIV_M5_DPLL(CM_CORE_BASE) = 0x4;
    
      /* CM_DIV_M6_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 6 */
      /* M6 clock is oused for debugSS and EMU Clock */
      CM_DIV_M6_DPLL(CM_CORE_BASE) = 0x6;
    
      /* CM_DIV_M7_DPLL_CORE.HSDIVIDER_CLKOUT3_DIV = 8 */
      CM_DIV_M7_DPLL(CM_CORE_BASE) = 0x8;
    }
  if (OPP == OPP50)
    {
      /* CM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV = 2 */
      CM_DIV_M2_DPLL(CM_CORE_BASE) = 0x2;
        
      /* CM_DIV_M3_DPLL_CORE.DPLL_CLKOUT_DIV = 8 */
      CM_DIV_M3_DPLL(CM_CORE_BASE) = 0x8;
    
      /* CM_DIV_M4_DPLL_CORE.HSDIVIDER_CLKOUT1_DIV = 8 */
      CM_DIV_M4_DPLL(CM_CORE_BASE) = 0x8;
    
      /* CM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 8 */
      CM_DIV_M5_DPLL(CM_CORE_BASE) = 0x8;
    
      /* CM_DIV_M6_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 8 */
      /* M6 clock is oused for debugSS and EMU Clock  */
      CM_DIV_M6_DPLL(CM_CORE_BASE) = 0x8;
    
      /* CM_DIV_M7_DPLL_CORE.HSDIVIDER_CLKOUT3_DIV = 16 */
      CM_DIV_M7_DPLL(CM_CORE_BASE) = 0x10;
    }
            
     	     
  dpll_lock_board(CM_CORE_BASE, OPP);
     		    
  if (INFO_PRINT) {        
    GEL_TextOut(" < CORE DPLL BOARD OPP %d\n",,,,, OPP);
  }	
}


dpll_iva_tesla_opp_config_board(int OPP)
{

  if (INFO_PRINT) {   
    GEL_TextOut("> TESLA IVA BOARD %d\n",,,,, OPP);
  }
    

  // DPLL AUTO control  disabled
  // *(int*)0x4A0041DC = 0x00000001; 
     
  // DPLL AUTO control  disabled
  //*(int*)0x4A0041AC = 0x00006103;
    
  if(OPP==OPPNITROSB)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");           
    }
  if(OPP==OPPNITRO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");            
    }
        
  if(OPP==OPPTURBO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
    
  if( OPP == OPP100)
    {
      if (SYSCLKFREQ == SYS_CLK_38_4)
        {      
	  // CKGEN_CM1.CM_CLKSEL_DPLL_IVA D =3
	  *(int*)0x4A0041AC = 0x00000003;
        }
      if (SYSCLKFREQ == SYS_CLK_26)
        {      
	  // CKGEN_CM1.CM_CLKSEL_DPLL_IVA D =10
	  *(int*)0x4A0041AC = 0x0000000A;
        }	
      if (SYSCLKFREQ == SYS_CLK_19_2)
        {      
	  // CKGEN_CM1.CM_CLKSEL_DPLL_IVA D =9
	  *(int*)0x4A0041AC = 0x00000009;
        }	
	
	
      // CKGEN_CM1.CM_DIV_M4_DPLL_IVA.HSDIVIDER_CLKOUT1_DIV = 4
      *(int*)0x4A0041B8 = 0x00000004;
        
      // CKGEN_CM1.CM_DIV_M5_DPLL_IVA.HSDIVIDER_CLKOUT2_DIV = 7
      *(int*)0x4A0041BC = 0x00000007;
    }  
     
  if( OPP == OPP50)
    {
     
      // CKGEN_CM1.CM_CLKSEL_DPLL_IVA D =3
      *(int*)0x4A0041AC = 0x00000003;
        
      // CKGEN_CM1.CM_DIV_M4_DPLL_IVA.HSDIVIDER_CLKOUT1_DIV = 8
      *(int*)0x4A0041B8 = 0x00000008;
        
      // CKGEN_CM1.CM_DIV_M5_DPLL_IVA.HSDIVIDER_CLKOUT2_DIV = 14
      *(int*)0x4A0041BC = 0x0000000E;
    }   
    
  // LOCK_DPLL
  // Need to lock it
  dpll_lock_board(CM_IVA_BASE, OPP); 
    
  *(int*)0x4A0041A0 = 0x00000007;

  // IVAHD WAKEUP (after IVAHD dpll)
  // Configure IVAHD and SL2 modules into "Auto" mode
  // IVAHD_CM2:CM_IVAHD_IVAHD_CLKCTRL
  //*(int*)0x4A008F20 = 0x00000001; // TO KEEP NEED TO TEST
  // IVAHD_CM2:CM_IVAHD_SL2_CLKCTRL
  //*(int*)0x4A008F28 = 0x00000001; // TO KEEP NEED TO TEST
    
  // Set Force wakeUp domain transition
  // IVAHD_CM2:CM_IVAHD_CLKSTCTRL = SW_WKUP
  //*(int*)0x4A008F00 = 0x00000002; // TO KEEP NEED TO TEST
    
  // Read1 IVAHD_ROOT_CLK is running or gatng/ungating transition is on-going
  // while (((*(int*)0x4A008F00) & 0x100)& ~0x100);
        
  // Configure Tesla mode into Auto mode
  // TESLA_CM1:CM_TESLA_TESLA_CLKCTRL
  //*(int*)0x4A004420 = 0x00000001;    
    
  // Set force-wakeup domain transition
  // TESLA_CM1:CM_TESLA_CLKSTCTRL = SW_WKUP
  //*(int*)0x4A004400 = 0x00000002;
    
  // Reading 1 : clock is running ir gating/ungating transition is on-going.
  //while (((*(int*)0x4A004400) & 0x100)& ~0x100);
  //debug = (*(int*)0x4a0041AC);
  //GEL_TextOut("> Dump register CM_CLKSEL_DPLL_IVA  end dpll_a9_opp_config_board: %d\n",,,,, debug);     
  if (INFO_PRINT) {
    GEL_TextOut("< TESLA IVA BOARD OPP %d\n",,,,, OPP);
  }  
}


/******************************************************************************
 * dpll_abe_opp_config_board() : ABE DPLL OPP configurations
 *****************************************************************************/
dpll_abe_opp_config_board(int OPP)
{
  if (INFO_PRINT) {
    GEL_TextOut("> ABE DPLL BOARD OPP %d\n",,,,, OPP);
  }
        			
  *(int*)0x4A0041ec = 0x18;         
  *(int*)0x4A30610c = 0x0;
    
  dpll_lock_board(CM_ABE_BASE, OPP);
    
  //*(int*)0x4A0041e0 = 0x4;
    
  //*(int*)0x4A0041ec = 0x00004018;
    
  //*(int*)0x4A0041e0 = 0x7;

  //while (*(int*)0x4A0041e4 != 0x1);
    
  // CM_CLKSEL_ABE = 0x4018;

  if (INFO_PRINT) {
    GEL_TextOut("< ABE DPLL BOARD OPP %d\n",,,,, OPP);
  }

}

/******************************************************************************
 * dpll_per_opp_config_board() : PER DPLL OPP configurations
 *****************************************************************************/
dpll_per_opp_config_board(int OPP)
{
  //int debug;

  if (INFO_PRINT) {   
    GEL_TextOut(" > PER BOARD DPLL OPP %d\n",,,,, OPP);
  }
    
  if(OPP==OPPNITROSB)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");           
    }
  if(OPP==OPPNITRO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");            
    }
        
  if(OPP==OPPTURBO)
    {
      GEL_TextOut(">> ONLY OPP100 and OPP50 supported \n");
    }
  // M & N parameters are fixed
  if( OPP == OPP50 )
    {
      /* CM_CLKSEL_DPLL_PER.PLL_MULT = 2 */
      //CM_CLKSEL_DPLL(CM_PER_BASE) = 0x200;

      //CM_CLKSEL_DPLL(CM_PER_BASE) = 0x0;
      CM_CLKSEL_DPLL(CM_PER_BASE) = 0x1F;
     
      /* CM_DIV_M2_DPLL_PER.DPLL_CLKOUT_DIV = 4, UnForce DPLL CLKOUTX2 and CLKOUT to stay enabled */
      //CM_DIV_M2_DPLL(CM_PER_BASE) = 0x004;
      CM_DIV_M2_DPLL(CM_PER_BASE) = 0x008;
        
      /* CM_DIV_M3_DPLL_PER.DPLL_CLKOUT_DIV = 4, UnForce DPLL CLKOUTHIF to stay enabled */
      //CM_DIV_M3_DPLL(CM_PER_BASE) = 0x004;
      CM_DIV_M3_DPLL(CM_PER_BASE) = 0x00A;
        
    
      /* CM_DIV_M4_DPLL_PER.HSDIVIDER_CLKOUT1_DIV = 6, UnForce HSDIVIDER_CLKOUT1 to stay enabled */
      //CM_DIV_M4_DPLL(CM_PER_BASE) = 0x006;
      CM_DIV_M4_DPLL(CM_PER_BASE) = 0x00C;
    
      /* CM_DIV_M5_DPLL_PER.HSDIVIDER_CLKOUT2_DIV = 4, UnForce HSDIVIDER_CLKOUT2 to stay enabled */
      //CM_DIV_M5_DPLL(CM_PER_BASE) = 0x004;
      CM_DIV_M5_DPLL(CM_PER_BASE) = 0x009;
    
      /* CM_DIV_M6_DPLL_PER.HSDIVIDER_CLKOUT2_DIV = 9, UnForce HSDIVIDER_CLKOUT3 to stay enabled */
      //CM_DIV_M6_DPLL(CM_PER_BASE) = 0x009;
      CM_DIV_M6_DPLL(CM_PER_BASE) = 0x012;
    
      /* CM_DIV_M7_DPLL_PER.HSDIVIDER_CLKOUT3_DIV = 5, UnForce HSDIVIDER_CLKOUT4 to stay enabled */
      //CM_DIV_M7_DPLL(CM_PER_BASE) = 0x005;
      CM_DIV_M7_DPLL(CM_PER_BASE) = 0x00A;
    }
  else if( OPP == OPP100 )
    {
      /* CM_CLKSEL_DPLL_PER.PLL_MULT = 2 */
      //CM_CLKSEL_DPLL(CM_PER_BASE) = 0x200;
      if (SYSCLKFREQ == SYS_CLK_38_4)
	{ 
	  //CM_CLKSEL_DPLL(CM_PER_BASE) = 0x0;
	  CM_CLKSEL_DPLL(CM_PER_BASE) = 0x1F;
	}   
      if (SYSCLKFREQ == SYS_CLK_26)
	{ 
	  CM_CLKSEL_DPLL(CM_PER_BASE) = 0x19;
        
	} 	   
      if (SYSCLKFREQ == SYS_CLK_19_2)
	{ 
	  CM_CLKSEL_DPLL(CM_PER_BASE) = 0xF;

	} 	   
      /* CM_DIV_M2_DPLL_PER.DPLL_CLKOUT_DIV = 4, UnForce DPLL CLKOUTX2 and CLKOUT to stay enabled */
      // CM_DIV_M2_DPLL(CM_PER_BASE) = 0x004;
      CM_DIV_M2_DPLL(CM_PER_BASE) = 0x008;
        
      /* CM_DIV_M3_DPLL_PER.DPLL_CLKOUT_DIV = 3, UnForce DPLL CLKOUTHIF to stay enabled */
      //CM_DIV_M3_DPLL(CM_PER_BASE) = 0x003;
      CM_DIV_M3_DPLL(CM_PER_BASE) = 0x006;
    
      /* CM_DIV_M4_DPLL_PER.HSDIVIDER_CLKOUT1_DIV = 6, UnForce HSDIVIDER_CLKOUT1 to stay enabled */
      //CM_DIV_M4_DPLL(CM_PER_BASE) = 0x006;
      CM_DIV_M4_DPLL(CM_PER_BASE) = 0x00B;
    
      /* CM_DIV_M5_DPLL_PER.HSDIVIDER_CLKOUT2_DIV = 4, UnForce HSDIVIDER_CLKOUT2 to stay enabled */
      //CM_DIV_M5_DPLL(CM_PER_BASE) = 0x004;
      CM_DIV_M5_DPLL(CM_PER_BASE) = 0x009;
    
      /* CM_DIV_M6_DPLL_PER.HSDIVIDER_CLKOUT2_DIV = 2, UnForce HSDIVIDER_CLKOUT3 to stay enabled */
      //CM_DIV_M6_DPLL(CM_PER_BASE) = 0x002;
      CM_DIV_M6_DPLL(CM_PER_BASE) = 0x004;
    
      /* CM_DIV_M7_DPLL_PER.HSDIVIDER_CLKOUT3_DIV = 3, UnForce HSDIVIDER_CLKOUT4 to stay enabled */
      //CM_DIV_M7_DPLL(CM_PER_BASE) = 0x003;
      CM_DIV_M7_DPLL(CM_PER_BASE) = 0x005;
         
    }
	
   
        
  /* Set force wakeUp domain transition */
  // CM_L4PER_CLKSTCTRL = 0x2;
        
  
  if (INFO_PRINT) {    
    GEL_TextOut(" < PER DPLL BOARD OPP %d\n",,,,, OPP);
  }   
	
}

opp_default_config_zebu()
{
  GEL_TextOut("opp_default_config_zebu_OPP100 \n");
  opp_config_zebu(OPP100);
}



opp_config_zebu(int OPP)
{

  GEL_TextOut("opp_config OPP Zebu %d\n",,,,, OPP);
	

  // Zonda DPLL programming
  dpll_a15_opp_config_zebu(OPP);
    
  // Core DPLL programming
  dpll_core_opp_config_zebu(OPP);
    
  // IVA & TESLA clock programming
  dpll_iva_opp_config_zebu(OPP);
    
  // PER DPLL programming
  dpll_per_opp_config_zebu(OPP);
    
  // ABE DPLL programming
  //dpll_abe_opp_config_zebu(OPP);
    
  // Ducati clock programming (using CORE clock)
  //dpll_ducati_coreclk_opp_config_zebu(OPP);

  GEL_TextOut("opp_config OPP Zebu FINISHED %d\n",,,,, OPP);

}

/******************************************************************************
 * dpll_a15_opp_config_zebu() : Cortex A15 DPLL OPP configurations
 *****************************************************************************/
dpll_a15_opp_config_zebu(int OPP)
{
  GEL_TextOut("> Cortex A15 DPLL Zebu OPP %d\n",,,,, OPP);
    
  if( OPP == OPP100 )
    {
        
      CM_CLKSEL_DPLL(CM_MPU_BASE) = 0x2F;
        
      // Program DPLL_CLKOUT divider (M2 = 1)
      CM_DIV_M2_DPLL(CM_MPU_BASE) = 0x1;
        
      CM_CLKMODE_DPLL(CM_MPU_BASE) = 0x7;
    
      // Program DPLL frequency 
      CM_CLKSEL_DPLL(CM_MPU_BASE) = 0x36B2F;
        
      dpll_lock_zebu(CM_MPU_BASE);
    }
	  
  GEL_TextOut("< Cortex A15 DPLL Zebu OPP %d\n",,,,, OPP);
}

/******************************************************************************
 * dpll_per_opp_config_zebu() : PER DPLL OPP configurations
 *****************************************************************************/
dpll_per_opp_config_zebu(int OPP)
{
  GEL_TextOut(" > PER DPLL ZEBU OPP %d\n",,,,, OPP);
    
  if( OPP == OPP100 )
    {
      /* CM_CLKSEL_DPLL_PER */
      CM_CLKSEL_DPLL(CM_PER_BASE) = 0x0;
        
      /* CM_DIV_M2_DPLL_PER.DPLL_CLKOUT_DIV = 4, Force DPLL CLKOUTX2 and CLKOUT to stay enabled */
      CM_DIV_M2_DPLL(CM_PER_BASE) = 0x508;
        
      /* CM_DIV_M3_DPLL_PER.DPLL_CLKOUT_DIV = 3, Force DPLL CLKOUTHIF to stay enabled */
      CM_DIV_M3_DPLL(CM_PER_BASE) = 0x106;
    
      /* CM_DIV_M4_DPLL_PER.HSDIVIDER_CLKOUT1_DIV = 6, Force HSDIVIDER_CLKOUT1 to stay enabled */
      CM_DIV_M4_DPLL(CM_PER_BASE) = 0x10C;
    
      /* CM_DIV_M5_DPLL_PER.HSDIVIDER_CLKOUT2_DIV = 5, Force HSDIVIDER_CLKOUT2 to stay enabled */
      CM_DIV_M5_DPLL(CM_PER_BASE) = 0x109;
    
      /* CM_DIV_M6_DPLL_PER.HSDIVIDER_CLKOUT2_DIV = 2, Force HSDIVIDER_CLKOUT3 to stay enabled */
      CM_DIV_M6_DPLL(CM_PER_BASE) = 0x104;
    
      /* CM_DIV_M7_DPLL_PER.HSDIVIDER_CLKOUT3_DIV = 3, Force HSDIVIDER_CLKOUT4 to stay enabled */
      CM_DIV_M7_DPLL(CM_PER_BASE) = 0x105;
        
      GEL_TextOut(" >>> PER DPLL ZEBU OPP %d\n",,,,, OPP);
        
      CM_CLKMODE_DPLL(CM_PER_BASE) = 0x7;
        
      CM_CLKSEL_DPLL(CM_PER_BASE) = 0x1400;
        
      //dpll_lock_zebu(CM_PER_BASE);
        
      GEL_TextOut(" >>>>>> PER DPLL ZEBU OPP %d\n",,,,, OPP);
        
      /* Set force wakeUp domain transition */
      CM_L4PER_CLKSTCTRL = 0x2;
        
      GEL_TextOut(" >>>>>>>>>>>>> PER DPLL OPP %d\n",,,,, OPP);
    }
	
  GEL_TextOut(" < PER DPLL ZEBU OPP %d\n",,,,, OPP);
	
}

/******************************************************************************
 * dpll_core_opp_config_zebu() : CORE DPLL OPP configurations
 *****************************************************************************/
dpll_core_opp_config_zebu(int OPP)
{
  GEL_TextOut("> CORE DPLL ZEBU OPP %d\n",,,,, OPP);
	
  // Program L3 & L4 dividers from CORE DPLL
  /* L3 clock = CORE CLK /2; L4 clock = L3 clock /2; CORE_CLK=CORE_X2_CLK/2 */
  CM_CLKSEL_CORE = 0x110;
    	
  if( OPP == OPP100 )
    {
      /* CM_CLKSEL_DPLL_CORE.PLL_MULT = 0x200 */
      CM_CLKSEL_DPLL(CM_CORE_BASE) = 0x200;
    
      /* CM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV = 1 */
      CM_DIV_M2_DPLL(CM_CORE_BASE) = 0x1;
    
      /* CM_DIV_M3_DPLL_CORE.DPLL_CLKOUT_DIV = 5 */
      CM_DIV_M3_DPLL(CM_CORE_BASE) = 0x5;

      /* CM_DIV_M4_DPLL_CORE.HSDIVIDER_CLKOUT1_DIV = 8 */
      CM_DIV_M4_DPLL(CM_CORE_BASE) = 0x8;

      /* CM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 4 */
      CM_DIV_M5_DPLL(CM_CORE_BASE) = 0x4;

      /* CM_DIV_M6_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV = 6 */
      CM_DIV_M6_DPLL(CM_CORE_BASE) = 0x6;

      /* CM_DIV_M7_DPLL_CORE.HSDIVIDER_CLKOUT3_DIV = 8 */
      CM_DIV_M7_DPLL(CM_CORE_BASE) = 0x8;
        
      CM_CLKMODE_DPLL(CM_CORE_BASE) = 0x7;
        
      // Program DPLL frequency 
      //CM_CLKSEL_DPLL(CM_MPU_BASE) = 0x7D05;
  
      dpll_lock_zebu(CM_CORE_BASE);
    }
      
  GEL_TextOut(" < CORE DPLL ZEBU OPP %d\n",,,,, OPP);	
}


/******************************************************************************
 * dpll_abe_opp_config() : ABE DPLL OPP configurations
 *****************************************************************************/
dpll_abe_opp_config_zebu(int OPP)
{
  GEL_TextOut("> ABE DPLL ZEBU OPP %d\n",,,,, OPP);
    

    
  // CM_CLKSEL_ABE = 0x501;

  GEL_TextOut("< ABE DPLL ZEBU OPP %d\n",,,,, OPP);

}

/******************************************************************************
 * dpll_ducati_coreclk_opp_config_zebu() : DUCATI CORE DPLL OPP configurations
 *****************************************************************************/
dpll_ducati_coreclk_opp_config_zebu(int OPP)
{
  GEL_TextOut("> DUCATI ZEBU OPP %d\n",,,,, OPP);
    
  // Configure Ducati mode into Auto mode
  // CORE_CM2:CM_DUCATI_DUCATI_CLKCTRL
  *(int*)0x4A008920 = 0x00000001;
    
  // Set force-wakeup domain transition
  // CORE_CM2:CM_DUCATI_CLKSTCTRL = SW_WKUP
  *(int*)0x4A008900 = 0x00000002;
    
  // Reading 1 : clock is running ir gating/ungating transition is on-going.
  while (((*(int*)0x4A008900) & 0x100)& ~0x100);
   
  GEL_TextOut("< DUCATI ZEBU OPP %d\n",,,,, OPP);
}


dpll_iva_opp_config_zebu(int OPP)
{
  GEL_TextOut("> IVA ZEBU OPP %d\n",,,,, OPP);
    

  // DPLL AUTO control  disabled
  // *(int*)0x4A0041DC = 0x00000001;
     
  // DPLL AUTO control  disabled
  *(int*)0x4A0041A8 = 0x00000000;
     
  // CKGEN_CM1.CM_CLKSEL_DPLL_IVA
  *(int*)0x4A0041AC = 0x00000003;
    
  // CKGEN_CM1.CM_DIV_M4_DPLL_IVA.HSDIVIDER_CLKOUT1_DIV = 4
  *(int*)0x4A0041B8 = 0x00000004;
    
  // CKGEN_CM1.CM_DIV_M5_DPLL_IVA.HSDIVIDER_CLKOUT2_DIV = 7
  *(int*)0x4A0041BC = 0x00000007;
    
  // LOCK_DPLL
  // Need to lock it (status bit doesn't work in OMAP4430 v2Beta3 Zebu distrib)
  //dpll_lock_zebu(CM_IVA_BASE); 
  *(int*)0x4A0041A0 = 0x00000007;
    
  // CKGEN_CM1.CM_CLKSEL_DPLL_IVA
  *(int*)0x4A0041AC = 0x00006103;
        
  // IVAHD WAKEUP (after IVAHD dpll)
  // Configure IVAHD and SL2 modules into "Auto" mode
  // IVAHD_CM2:CM_IVAHD_IVAHD_CLKCTRL
  //*(int*)0x4A008F20 = 0x00000001;
  // IVAHD_CM2:CM_IVAHD_SL2_CLKCTRL
  //*(int*)0x4A008F28 = 0x00000001;
    
  // Set Force wakeUp domain transition
  // IVAHD_CM2:CM_IVAHD_CLKSTCTRL = SW_WKUP
  //*(int*)0x4A008F00 = 0x00000002;
    
  // Read1 IVAHD_ROOT_CLK is running or gatng/ungating transition is on-going
  // while (((*(int*)0x4A008F00) & 0x100)& ~0x100);
        
  // Configure Tesla mode into Auto mode
  // TESLA_CM1:CM_TESLA_TESLA_CLKCTRL
  //*(int*)0x4A004420 = 0x00000001;    
    
  // Set force-wakeup domain transition
  // TESLA_CM1:CM_TESLA_CLKSTCTRL = SW_WKUP
  //*(int*)0x4A004400 = 0x00000002;
    
  // Reading 1 : clock is running ir gating/ungating transition is on-going.
  //while (((*(int*)0x4A004400) & 0x100)& ~0x100);
    
  GEL_TextOut("< IVA ZEBU OPP %d\n",,,,, OPP);
}

/******************************************************************************
 * dpll_bypass_zebu() : Put DPLL in bypass mode
 *****************************************************************************/
dpll_bypass_zebu(int base_address)
{
  unsigned int timer;
  int clken_pll_value;

  // Put DPLL into bypass mode
  clken_pll_value = CM_CLKMODE_DPLL(base_address);
  clken_pll_value &= ~(7 << 0);
  clken_pll_value |= (4 << 0);
  CM_CLKMODE_DPLL(base_address) = clken_pll_value;

  // Wait for DPLL to be unlocked
  timer = 0;
  while ( (CM_IDLEST_DPLL(base_address) & 0x1) == 0x1 && timer++<DPLL_TIMEOUT);

  if( timer >= DPLL_TIMEOUT)
    return -1;
  else
    return 0;
}

/******************************************************************************
 * dpll_lock_zebu() : lock DPLL at specified frequency 
 *****************************************************************************/
dpll_lock_zebu(int base_address)
{

  // Put DPLL into bypass mode
  // dpll_bypass(base_address);

  // Lock DPLL
  dpll_lock_sequence_zebu(base_address);
}


/******************************************************************************
 * dpll_lock_sequence_zebu() : DPLL lock_sequence
 *****************************************************************************/
dpll_lock_sequence_zebu(int base_address)
{
  unsigned int timer;
	
  // Put DPLL into lock mode
  //CM_CLKMODE_DPLL(base_address) = 7;

  // Wait for DPLL to be locked
  timer = 0;
  while( ((CM_IDLEST_DPLL(base_address) & 0x1) != 0x1) && (timer++<DPLL_TIMEOUT) );

  if( timer >= DPLL_TIMEOUT )
    {
      GEL_TextOut("ERROR: timeout while locking ZEBU DPLL \n");
      return -1;
    }
  else
    {
      GEL_TextOut("Locked ZEBU DPLL successfully \n");
      return 0;
    }
}
