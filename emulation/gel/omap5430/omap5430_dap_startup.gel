/*******************************************************************/ 
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/* OMAP5430 firewall startup             						   */
/*                                                                 */
/*                                                                 */
/*  Author: Salamito thomas				     					   */
/*******************************************************************/

#define INFO_PRINT								1

#define CONTROL_L3_HW_FW_EXPORTED_VALUES_CONF_DBG        0x4A002114
#define CONTROL_L3_HW_FW_EXPORTED_VALUES_CONF_LOCK        0x4A002118

#define fw_lli_ocp_regupdate                    0x4A202040
#define fw_modem_regupdate_control              0x4A204040
#define fw_modem_ocp_regupdate_control              0x4A206040
#define fw_lli_regupdate                    0x4A208040
#define fw_mpuma_regupdate_control              0x4A20A040
#define fw_emif_regupdate_control                 0x4A20C04cc0
#define fw_gpmc_regupdate_control                0x4A210040
#define fw_sgx_regupdate_control              0x4A214040
#define fw_iss_regupdate_control                 0x4A216040
#define fw_ipu_regupdate_control              0x4A218040
#define fw_dss_regupdate_control               0x4A21C040
#define fw_sl2_regupdate_control                 0x4A21E040
#define fw_ivahd_regupdate_control                0x4A220040

#define fw_cal_regupdate_control                0x4A222040
#define fw_ct_tbr_regupdate_control                0x4A224040
#define fw_ct_tbr_mrm_permission_region_low        0x4A224088
#define fw_ct_tbr_mrm_permission_region_high        0x4A22408C

#define fw_l3_inst_regupdate_control                0x4A226040

#define fw_abe_regupdate_control               0x4A228040
#define fw_crypto_regupdate_control               0x4A22A040
#define fw_debug_regupdate_control               0x4A226088

#define fw_l3ram_regupdate_control              0x4A212040
#define fw_l3ram_start_region_1_val              0x40300000
#define fw_l3ram_end_region_1_val                0x4031FFFF

#define FW_L3RAM_START_REGION_1_VALUE     0x4A212090  
#define FW_L3RAM_END_REGION_1_VALUE 	0x4A212094 

#define CONTROL_L4_HW_FW_EXPORTED_VALUES_CONF        0x4A00211C
#define CONTROL_SEC_LOAD_FW_EXPORTED_VALUES          0x4A002120

#define control_l4_hw_fw_exported_values_conf   0x4A00211C
#define control_sec_load_fw_exported_values     0x4A002120

StartUp()
{
  // STM traces
  GEL_LoadGel("$(GEL_file_dir)//omap5430_stm.gel"); 
}


force_efuse()
{
    GEL_TextOut("--->>> force_efuse <<<---\n"); 
    
    //For the Core
    *(int*)0x4ae07bc4=0x00000002;
     
    //For the MM 
    *(int*)0x4ae07bd4=0x00000002;

    //For the MPU 
    *(int*)0x4ae07bcc=0x00000002;
    
    GEL_TextOut("---<<< force_efuse >>>---\n"); 
}    

OnTargetConnect()
{ 
	int device_type;
    
    force_efuse();
    
    	device_type = *(int*)0x4A002134;
    
    	// GP device	
    	if (((device_type & 0x1C0)>>6) == 0x3)
    	{
     	   GEL_TextOut("--->>> GP device, no FW settings needed. <<<---\n"); 
    	}
    	else
    	{	
		// HS device
    		if (((device_type & 0x1C0)>>6) == 0x2) 	
    		{
        		GEL_TextOut("--->>> HS device, no FW settings needed  <<<---\n");
                //set_firewalls_to_public(); 

    		}
    		else
    		{	
				// EMU device
    			if (((device_type & 0x1C0)>>6) == 0x1) 	
    			{
        			//GEL_TextOut("--->>> EMU device, FW settings needed -> allow all access <<<---\n"); 
        			set_firewalls_to_public();
    			}
				else
				{
					// TEST device
					if (((device_type & 0x1C0)>>6) == 0x0) 	
    				{
        				GEL_TextOut("--->>> TEST device, FW settings needed -> allow all access <<<---\n"); 
        				set_firewalls_to_public();
    				}
					else
					{	
						GEL_TextOut("--->>> UNKOWN device maybe NON FUSED , FW settings needed -> allow all access <<<---\n"); 
        				set_firewalls_to_public();
					}
				}
		}
	}
	
	GEL_TextOut("---<<< Firewalls settings >>>---\n");
}  

hotmenu set_firewalls_to_public()
{
	int control_l3_hw_fw_exported_values_conf_dbg_register_value;
    
    int control_l3_hw_fw_exported_values_conf_lock_register_value;
	
	int control_l3ram_regupdate_control_dbg_register_value;
    
    int control_l3ram_regupdate_control_lock_register_value;
	
	int control_l4_hw_fw_exported_values_conf_register_value;

if (INFO_PRINT) {
	GEL_TextOut("--->>> ENTER set_firewalls_to_public <<<---\n");
	}
	
	/* Set Public rights for some L3 firewalls */
	control_l3_hw_fw_exported_values_conf_dbg_register_value = *(int*)CONTROL_L3_HW_FW_EXPORTED_VALUES_CONF_DBG;
    
    control_l3_hw_fw_exported_values_conf_lock_register_value = *(int*)CONTROL_L3_HW_FW_EXPORTED_VALUES_CONF_LOCK;

	control_l3_hw_fw_exported_values_conf_dbg_register_value = 0xFFFFFFFF;
	*(int*)CONTROL_L3_HW_FW_EXPORTED_VALUES_CONF_DBG = control_l3_hw_fw_exported_values_conf_dbg_register_value;

	//control_l3_hw_fw_exported_values_conf_lock_register_value &= 0xFFFF720A;
    
    control_l3_hw_fw_exported_values_conf_lock_register_value = 0xFFFFFFFF;
	*(int*)CONTROL_L3_HW_FW_EXPORTED_VALUES_CONF_LOCK = control_l3_hw_fw_exported_values_conf_lock_register_value;
   
	 /* Request L3 firewalls to load exported values: */
     /*  - Set BUSY_REQ bit (avoid requests to go through FW while updating registers) */
     /*  - Request load of exported values (Write '1' to FW_LOAD_REQ bit) */
     /*  - Clear BUSY_REQ bit */
     
     /* Set BUSY_REQ Bit */
     *(int*)fw_lli_ocp_regupdate = 0x1;
     *(int*)fw_modem_regupdate_control = 0x1;
     *(int*)fw_modem_ocp_regupdate_control = 0x1;
     *(int*)fw_lli_regupdate = 0x1;
     *(int*)fw_mpuma_regupdate_control = 0x1;
     *(int*)fw_emif_regupdate_control = 0x1;
     *(int*)fw_sgx_regupdate_control = 0x1;
     *(int*)fw_iss_regupdate_control = 0x1;
     *(int*)fw_ipu_regupdate_control = 0x1;
     *(int*)fw_dss_regupdate_control = 0x1;
     *(int*)fw_sl2_regupdate_control = 0x1;
     *(int*)fw_ivahd_regupdate_control = 0x1;
	 *(int*)fw_abe_regupdate_control = 0x1;
     *(int*)fw_cal_regupdate_control = 0x1;
     *(int*)fw_ct_tbr_regupdate_control = 0x1;
     *(int*)fw_crypto_regupdate_control = 0x1;
     *(int*)fw_debug_regupdate_control = 0x1;
     *(int*)fw_l3_inst_regupdate_control = 0x1;
     
	 
	 /* Request load of exported value */
     *(int*)fw_lli_ocp_regupdate = 0x3;
     *(int*)fw_modem_regupdate_control = 0x3;
     *(int*)fw_modem_ocp_regupdate_control = 0x3;
     *(int*)fw_lli_regupdate = 0x3;
     *(int*)fw_mpuma_regupdate_control = 0x3;
     *(int*)fw_emif_regupdate_control = 0x3;
     *(int*)fw_sgx_regupdate_control = 0x3;
     *(int*)fw_iss_regupdate_control = 0x3;
     *(int*)fw_ipu_regupdate_control = 0x3;
     *(int*)fw_dss_regupdate_control = 0x3;
     *(int*)fw_sl2_regupdate_control = 0x3;
     *(int*)fw_ivahd_regupdate_control = 0x3;
	 *(int*)fw_abe_regupdate_control = 0x3;
     *(int*)fw_cal_regupdate_control = 0x3;
     *(int*)fw_ct_tbr_regupdate_control = 0x3;
     *(int*)fw_crypto_regupdate_control = 0x3;
     *(int*)fw_debug_regupdate_control = 0x3;
     *(int*)fw_l3_inst_regupdate_control = 0x3; 
	 
	/* Clear BUSY_REQ Bit */
     *(int*)fw_lli_ocp_regupdate = 0x3;
     *(int*)fw_modem_regupdate_control = 0x0;
     *(int*)fw_modem_ocp_regupdate_control = 0x0;
     *(int*)fw_lli_regupdate = 0x0;
     *(int*)fw_mpuma_regupdate_control = 0x0;
     *(int*)fw_emif_regupdate_control = 0x0;
     *(int*)fw_sgx_regupdate_control = 0x0;
     *(int*)fw_iss_regupdate_control = 0x0;
     *(int*)fw_ipu_regupdate_control = 0x0;
     *(int*)fw_dss_regupdate_control = 0x0;
     *(int*)fw_sl2_regupdate_control = 0x0;
     *(int*)fw_ivahd_regupdate_control = 0x0;
	 *(int*)fw_abe_regupdate_control = 0x0;
     *(int*)fw_cal_regupdate_control = 0x0;
     *(int*)fw_ct_tbr_regupdate_control = 0x0;
     *(int*)fw_crypto_regupdate_control = 0x0;
     *(int*)fw_debug_regupdate_control = 0x0;
     *(int*)fw_l3_inst_regupdate_control = 0x0;
 
	 /*  GPMC firewall configuration load request is done there to take care of extermal booting */
     /* in GPMC case. Indeed setting the BUSY_REQ bit locks access to GPMC in which code is located */
     /* when booting in GPMC. Thus in order to avoid deadlock (can not fetch code because of BUSY_REQ */
     /* assertion) the six following instructions are aligned on 8 words boundary. So they are all */
     /* loaded in one time in the prefetch buffer, avoiding the deadlock case to happen. */
     
     /* Set GPMC BUSY_REQ */
     *(int*)fw_gpmc_regupdate_control = 0x1;
     
     /* Request load of exported value */
     *(int*)fw_gpmc_regupdate_control = 0x3;
     
     /* Clear BUSY_REQ Bit */
     *(int*)fw_gpmc_regupdate_control = 0x0;
     
     /* Configure partially OCMCRAM in public with region1 */
     /* control_l3ram_regupdate_control_register_value = *(int*)fw_l3ram_regupdate_control; */
      *(int*)fw_l3ram_regupdate_control = 0x1;  
     
     *(int*)FW_L3RAM_START_REGION_1_VALUE = fw_l3ram_start_region_1_val; 
     //*(int*)0x4A212090 = 0x0; 
     *(int*)FW_L3RAM_END_REGION_1_VALUE =  fw_l3ram_end_region_1_val; 
     //*(int*)0x4A212094 = 0xf001;

     *(int*)fw_l3ram_regupdate_control = 0x0; 
  
     /* Set public rights for some L4 firewalls */
     control_l4_hw_fw_exported_values_conf_register_value = *(int*)control_l4_hw_fw_exported_values_conf;
     /* Clear L4CONFIG_USIM_seclock bit */
     control_l4_hw_fw_exported_values_conf_register_value &= ~(1 << 6);
     
     *(int*)CONTROL_L4_HW_FW_EXPORTED_VALUES_CONF = control_l4_hw_fw_exported_values_conf_register_value;
     
     /* Request L4CONFIG firewalls to load exported values */
     *(int*)CONTROL_SEC_LOAD_FW_EXPORTED_VALUES=0x4;
     
     /* Set debug firewall to public */
     *(int*)fw_debug_regupdate_control = 0xFFFFFFFF;
     
     /* Set all region low for TTBR to 0xFFFFFFFF */
     *(int*)fw_ct_tbr_mrm_permission_region_low = 0xFFFFFFFF;
     
     /* Set all region high for TTBR to 0xFFFFFFFF */
     *(int*)fw_ct_tbr_mrm_permission_region_high = 0xFFFFFFFF;
     
     /* set all region low for MRM_PERMISSION_REGION_0_LOW for EMIF register to 0xFFFFFFFF */
     *(int*) 0x4a20C088 = 0xFFFFFFFF;
     
     /* set all region low for MRM_PERMISSION_REGION_0_LOW for LLI register to 0xFFFFFFFF */
     *(int*) 0x4a202088 = 0xFFFFFFFF;
     
     
 if (INFO_PRINT) {    
     GEL_TextOut("--->>> EXIT set_firewalls_to_public <<<---\n");
}     
}
