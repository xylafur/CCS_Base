/*--------------------------------------------------------------------*/
/* CS_DAP_PC_Utility.gel                                              */
/* version 0.01                                                       */
/* AUTHOR: SALAMITO Thomas                                            */
/*                                                                    */
/* SUMMARY:                                                           */
/*                                                                    */
/* This gel file allows the Cortex-A15 CPU1 to come out of reset       */
/* so that Cortex-A15 CPU0 can be halted in WIR mode on a GP device in */
/* non-secure mode, this is                                           */
/* because the secure ROM code running on CPU0 checks that CPU1 is    */
/* out of reset on CPU0 before exiting secure mode to go into         */
/* non-secure mode                                                    */
/*                                                                    */
/* LIMITATIONS:                                                       */
/*                                                                    */
/*                                                                    */
/*--------------------------------------------------------------------*/

/*--------------------------------------------------------------------*/
/* FUNCTION SUMMARY                                                   */
/*                                                                    */
/* ReleaseWIR_CortexA15_CPU1()                                         */
/*                                                                    */
/*--------------------------------------------------------------------*/

menuitem "CS_DAP_PC_Utility";



//----------------------------------------------------------------------
#define SDTR_CORTEX_A15_1         IP_TAP_CNTL_1

// masks and values for the SDTR register
#define RESETOCCURRED            (unsigned int)(0x1 << 22)
#define POWERLOSSDETECTED        (unsigned int)(0x1 << 21)
#define RELEASEFROMWIR           (unsigned int)(0x1 << 17)
#define RESETCONTROL_MASK        (unsigned int)(0x3 << 14)
#define EXECUTEACTION            (unsigned int)(0x1 << 10)

#define RESETCNTL_NORMAL         (unsigned int)(0x0 << 14)
#define RESETCNTL_WIR            (unsigned int)(0x1 << 14)
#define RESETCNTL_BLOCK          (unsigned int)(0x2 << 14)
#define RESETCNTL_ASSERT         (unsigned int)(0x3 << 14)

OnTargetConnect()
{
    int device_type;
    
    int cpu1_power_state;
    int cpu1_clk_ctrl;
         
    /* Check device type, if GP release CPU1 from reset */
    
    device_type = *(int*)0x4A002134;
    
    device_type = ((*(int*)0x4A002134) & 0x1C0)>>6;
    
    if (device_type  == 0x3)
    { 
       GEL_TextOut("--->>> GP device <<<---\n");
       
       //cpu1_power_state = *(int*)0x48243800;
       
       //GEL_TextOut("--->>> PWR1 (%x) <<<---\n",,,,,cpu1_power_state);
       
       //cpu1_power_state = cpu1_power_state|0x3;
       //*(int*)0x48243800 = cpu1_power_state;
       
       //GEL_TextOut("--->>> PWR2 (%x) <<<---\n",,,,,cpu1_power_state);
       
       //cpu1_clk_ctrl = *(int*)0x48243A00;
       //GEL_TextOut("--->>> CTRL1 (%x) <<<---\n",,,,,cpu1_clk_ctrl);
       
      // cpu1_clk_ctrl = cpu1_clk_ctrl|0x2;
      // *(int*)0x48243A00 = cpu1_clk_ctrl;
       
       //GEL_TextOut("--->>> CTRL2 (%x) <<<---\n",,,,,cpu1_clk_ctrl);
             
       ReleaseWIR_CortexA15_CPU1();
    }
    else
    {
       GEL_TextOut("--->>> Device type not GP <<<---\n");
       
       cpu1_power_state = *(int*)0x48243800;
       
       //GEL_TextOut("--->>> PWR3 (%x) <<<---\n",,,,,cpu1_power_state);
       
       //cpu1_clk_ctrl = *(int*)0x48243A00;
       
       //GEL_TextOut("--->>> CTRL3 (%x) <<<---\n",,,,,cpu1_clk_ctrl);
           
    }
    
    // dpll debug SS
    //dpll_dbgss_config_zebu();
}

//dpll_dbgss_config_zebu()
//{
//    GEL_TextOut("> DEBUGSS ZEBU 1,6GHz\n");
    
    // PLL CONFIGURATION1
//    *(int*)0x5417180C = 0x1C60FA0A;  
    
    // PLL CONFIGURATION2
//    *(int*)0x54171810 = 0xE52008;
    
    // PLL CONFIGURATION3
//    *(int*)0x54171814 = 0x4;
    
    // REQUEST DPLL
//    *(int*)0x54171808 = 0x1;
    
    // Reading 1 : DPLL is locked.
//    while (((*(int*)0x54171804) & 0x2)& ~0x2);
    
//    GEL_TextOut("< DEBUGSS ZEBU \n");   
//}

hotmenu ReleaseWIR_CortexA15_CPU1()
{
   int SDTR_temp;
   int writeBackValue;

   SDTR_temp = SDTR_CORTEX_A15_1;  /* Read the SDTR value */
   
   if ((SDTR_temp & RESETCNTL_WIR) == RESETCNTL_WIR)
   {
      /* Do a read/modify write such that we write zero to following bits */
      /* EXECUTEACTION bit */
      /* RELEASEFROMWIR bit */
      /* POWERLOSSDETECTED bit */
      /* Reset Control bits */
      /* Reset Occurred bit */
   
      writeBackValue = 
          SDTR_temp & (~( POWERLOSSDETECTED | 
                          RELEASEFROMWIR    | 
                          EXECUTEACTION     | 
                          RESETCONTROL_MASK |  
                          RESETOCCURRED) );

      SDTR_CORTEX_A15_1 = writeBackValue;            

      GEL_TextOut("Cortex-A15 1 has been released from Wait-In-Reset.\n");
   }
   else
   {
      GEL_TextOut("Cortex-A15 1 is not in WIR mode so nothing to do.\n");
   }   
} 

          

   

