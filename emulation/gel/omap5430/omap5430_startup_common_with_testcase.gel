/*******************************************************************/ 
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/* OMAP5430 startup common    		     						   */
/*                                                                 */
/*                                                                 */
/*  Author: Salamito thomas				     					   */
/*******************************************************************/

// OPP definitions
#define OPPBOOT		0
#define	OPP100		2
#define ZEBU		11

OnTargetConnect()
{ 
    omap5430_startup_sequence();
    GEL_TextOut("--->>> omap5430_startup_sequence DONE !!!!!  <<<---\n");
}

onResetDetected()
{
    GEL_TextOut("--->>> System Reset detected <<<---\n");
    // commented for the moment feature not availablein CCS 
    // omap5430_startup_sequence(); 
}

OnReset()
{

    int device_type;
    
    int silicon_type;
    
    int ID_CODE	  = *(int*)0x4A002204;
    
    silicon_type = (ID_CODE & 0xE0000000) >> 28;
    
    GEL_TextOut("--->>> Reset occurs <<<---\n");
    
    
    device_type = *(int*)0x4A0022C4;
    
    if (((device_type & 0x300)>>8) == 0x3)
    {
        GEL_TextOut("--->>> GP device <<<---\n"); 
        
        if  (silicon_type == 2)
        {
            //PC=0x28000;
            PC=0x28000;
        }
        else
        {  
             PC=0x20000;
        } 
        CPSR=0x193; 
    }
    
    if (((device_type & 0x300) >> 8) == 0x1)
    { 
        GEL_TextOut("--->>> EMU device <<<---\n");
        CPSR=0x1D3; 
    }
    
	//Enter_Secure_Mode();
	//Secure_Watchdog_disable();
	//Enter_Non_Secure_Mode();
    // Watchdog_disable();
}

omap5430_startup_sequence()
{  
    int device_type;
    int reg;
       
    int ID_CODE	  = *(int*)0x4A002204;
    
    int silicon_type;
    
	GEL_TextOut("--->>> omap5430_startup_sequence <<<---\n");
    
    silicon_type = (ID_CODE & 0xE0000000) >> 28;
	
	if  (silicon_type == 0) 
    {
        GEL_TextOut("--->>> OMAP 5430 ES 1.0 Device <<<---\n");
    }
    	
    device_type = *(int*)0x4A0022C4;
    
    if (((device_type & 0x300)>>8) == 0x3)
    { 
            GEL_TextOut("--->>> GP device <<<---\n"); 
            
            reconfigure_gpmc();
    }
    
    if (((device_type & 0x300) >> 8) == 0x2)
    { 
            GEL_TextOut("--->>> HS device <<<---\n"); 
    }
    
  	if (((device_type & 0x300) >> 8) == 0x1)
    { 
            GEL_TextOut("--->>> EMU device <<<---\n"); 
    }
    
    if (((device_type & 0x300) >> 8) == 0x0)
    { 
            GEL_TextOut("--->>> TEST device <<<---\n"); 
    }           
    
    if (((device_type & 0x300) >> 8) != 3)
    {  
        //Enter_Secure_Mode();
        //Secure_Watchdog_disable();
	//Enter_Non_Secure_Mode(); /* changed for GPMC access */
    }
   
   /* Disable Watchdog timer WDT2 */
   Watchdog_disable();
 
   /* Setup sys.clk = 38.4MHz       */
   //SelectSysClock_38_4MHz();
   
   /* set CORE3 to 1.1V */
/* with EEPROM 05, default VCORE3 value is OPP50, i.e 0.975V. */
/* This is at risk for LPDDR2 code downloading at OPP100_ES20 speed */
/* (even worst @ OPP100).  uTEB are equipped with Phoenix Power */
/* EEPROM 05, and users are not suffering so much while PAB users are. */

   
	/* Set clock config to OPP3 */
	opp_default_config_zebu();
    
    
    
     /* DDR memory config */
      ddr_config_top_zebu(OPP100,ZEBU);
     
     /* GPMC PSRAM Configuration to access all 26 bits of Address */
     *(int*) 0x4A100060 = 0x01080108; /* PAD0_GPMC_A16_PAD1_GPMC_A17 */
     *(int*) 0x4A100064 = 0x01080108; /* PAD0_GPMC_A18_PAD1_GPMC_A17 */
     *(int*) 0x4A100068 = 0x01080108; /* PAD0_GPMC_A20_PAD1_GPMC_A19 */
     *(int*) 0x4A10006Comap4430_i2c_driver.gel = 0x01080108; /* PAD0_GPMC_A22_PAD1_GPMC_A21 */
     *(int*) 0x4A100070 = 0x01080108; /* PAD0_GPMC_A24_PAD1_GPMC_A23 */
	 *(int*) 0x4A100088 = 0x01180108; /* PAD0_GPMC_NBE1_PAD1_GPMC_WAIT0 */

     /* GPMC Config to remove limited address restriction */
     reg = *(int*) 0x50000050;
     *(int*) 0x50000050 = reg | 0x2;

     GEL_TextOut("--->>> GPMC Reconfiguration Complete <<<---\n");

    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is in SECURE state!\n");
    }
	
}

reconfigure_gpmc()
{
      int value;
      
      GEL_TextOut("Reconfigure PSRAM for accessing if device type = GP \n");
      
      value = *(int*) 0x4A004120;
      value &= 0xFFFFFFF8;
      value |= 5;
      *(int*) 0x4A004120 = value;
      
      *(int*) 0x50000060 = 0x1200;
      
      *(int*) 0x50000078 = 0xF48; 
     
     *(int*) 0x4A100040 = 0x01180118; 
       
     *(int*) 0x4A100040 = 0x01180118; 
     *(int*) 0x4A100044 = 0x01180118; 
     *(int*) 0x4A100048 = 0x01180118; 
     *(int*) 0x4A10004C = 0x01180118; 
     *(int*) 0x4A100050 = 0x01180118; 
     *(int*) 0x4A100054 = 0x01180118; 
     *(int*) 0x4A100058 = 0x01180118; 
     *(int*) 0x4A10005c = 0x01180118; 
     

    /* GPMC PSRAM Configuration to access all 26 bits of Address */
     *(int*) 0x4A100060 = 0x01000100; /* PAD0_GPMC_A16_PAD1_GPMC_A17 */
     *(int*) 0x4A100064 = 0x01000100; /* PAD0_GPMC_A18_PAD1_GPMC_A17 */
     *(int*) 0x4A100068 = 0x01000100; /* PAD0_GPMC_A20_PAD1_GPMC_A19 */
     *(int*) 0x4A10006C = 0x01000100; /* PAD0_GPMC_A22_PAD1_GPMC_A21 */
     *(int*) 0x4A100070 = 0x01000100; /* PAD0_GPMC_A24_PAD1_GPMC_A23 */
	 // *(int*) 0x4A100088 = 0x01180108; /* PAD0_GPMC_NBE1_PAD1_GPMC_WAIT0 */

    value = *(int*) 0x4A10007c;
    value &= 0xFFFFFFFE;
    *(int*) 0x4A10007c = value;
    
    value = *(int*) 0x50000050;
    value &= 0xFFFFFFFB;
    *(int*) 0x50000050 = value;
    
     //PC=0x800000;
    
}    




hotmenu Enter_Non_Secure_Mode()
{
    int reg;
    GEL_TextOut("--->>> Enter Non secure Mode <<<---\n");

    REG_TZ_SECURE = 0;
    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is still in SECURE state!\n");
    }
}

hotmenu Enter_Secure_Mode()
{
    int reg;
    GEL_TextOut("--->>> Enter secure Mode <<<---\n");

    REG_TZ_SECURE = 1;
    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is still in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is in SECURE state!\n");
    }
}

hotmenu Watchdog_disable()
{
	GEL_TextOut("--->>> Start WDT2 Watchdog Timer is disabled <<<---\n");
	 
   /* Enable clock */
   *(int*)0x4A307830 = 0x02;

   /* Check that module is Idle */
   while (((*(int *)0x4A307830) & 0x20000));
       
   /* Disable  watchdog 2 */
   /* Wait until reset complete */
   while (!((*(int *)0x4A314014) & 0x01));

   /* Disable watchdog timer */
   *(int*)0x4A314048 = 0x0000AAAA;

   while (((*(int *)0x4A314034) & 0x10));

   /* Disable 32Khz watchdog timer */
   *(int*)0x4A314048 = 0x00005555;

   while (((*(int *)0x4A314034) & 0x10));

   GEL_TextOut("--->>> End WDT2 Watchdog Timer is disabled <<<---\n");
}

hotmenu Secure_Watchdog_disable()
{
	GEL_TextOut("--->>> Start Secure Watchdog Timer is disabled <<<---\n");
	
   /* enable clock */
   *(int*)0x4A307828 = 0x02;

   /* Check that module is Idle */
   while (((*(int *)0x4A307828) & 0x20000));
       
   /* Disable  watchdog 2 */
   /* Wait until reset complete */
   while (!((*(int *)0x4A322014) & 0x01));

   /* Disable watchdog timer */
   *(int*)0x4A322048 = 0x0000AAAA;

   while (((*(int *)0x4A322034) & 0x10));

   /* Disable 32Khz watchdog timer */
   *(int*)0x4A322048 = 0x00005555;

   while (((*(int *)0x4A322034) & 0x10));

   GEL_TextOut("--->>> End Secure Watchdog Timer is disabled <<<---\n");
}
