/*******************************************************************/ 
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/* OMAP4430 startup common    		     						   */
/*                                                                 */
/*                                                                 */
/*  Author: Salamito thomas				     					   */
/*******************************************************************/

// OPP definitions
//#define	OPP25		1
//#define	OPP50		2
//#define	OPP80		3
//#define	OPP100		4
//#define	OPP100_SDC	5
//#define OPP100_ES20 55
//#define OPP119      	6

//#define	OPP25_SDC	7
//#define	OPP50_SDC	8
//#define	OPP80_SDC	9
//#define OPP119_SDC      10

//#define	OPPBOOT		11
//#define	OPP100_HDMI	12

//#define SAMSUNG		1
//#define ELPIDA2X2GBIT	2
//#define ELPIDA4X2GBIT	3
//#define HYNIX		4
//#define MICRON		5
//#define ZEBU		11

OnTargetConnect()
{ 
    omap4430_startup_sequence();
    GEL_TextOut("--->>> omap4430_startup_sequence DONE !!!!!  <<<---\n");
}

onResetDetected()
{
    GEL_TextOut("--->>> System Reset detected <<<---\n");
    // commented for the moment feature not availablein CCS 
    // omap4430_startup_sequence(); 
}

OnReset()
{

    int device_type;
    
    GEL_TextOut("--->>> Reset occurs <<<---\n");
    
    device_type = *(int*)0x4A0022C4;
    
    if (((device_type & 0x300)>>8) == 0x3)
    {
        GEL_TextOut("--->>> GP device <<<---\n"); 
        PC=0x20000;
        CPSR=0x193; 
    }
    
    if (((device_type & 0x300) >> 8) == 0x1)
    { 
        GEL_TextOut("--->>> EMU device <<<---\n");
        CPSR=0x1D3; 
    }
    
	//Enter_Secure_Mode();
	//Secure_Watchdog_disable();
	//Enter_Non_Secure_Mode();
    // Watchdog_disable();
}

omap4430_startup_sequence()
{  
    int device_type;
    int reg;
    
	GEL_TextOut("--->>> omap4430_startup_sequence <<<---\n");
	
    device_type = *(int*)0x4A0022C4;
    
    if (((device_type & 0x300)>>8) == 0x3)
    { 
            GEL_TextOut("--->>> GP device <<<---\n"); 
    }
    
    if (((device_type & 0x300) >> 8) == 0x2)
    { 
            GEL_TextOut("--->>> HS device <<<---\n"); 
    }
    
  	if (((device_type & 0x300) >> 8) == 0x1)
    { 
            GEL_TextOut("--->>> EMU device <<<---\n"); 
    }
    
    if (((device_type & 0x300) >> 8) == 0x0)
    { 
            GEL_TextOut("--->>> TEST device <<<---\n"); 
    }           
    
    if (((device_type & 0x300) >> 8) != 3)
    {  
        //Enter_Secure_Mode();
        //Secure_Watchdog_disable();
	//Enter_Non_Secure_Mode(); /* changed for GPMC access */
    }
   
   /* Disable Watchdog timer WDT2 */
   Watchdog_disable();
 
   /* Setup sys.clk = 38.4MHz       */
   //SelectSysClock_38_4MHz();
   
   /* Fast download set to ON     */
   // Set_AHB_download_ON();
   
   // Initialise I2C config for configuring PHoenix
   // I2C_Init();
   
//   ddr_config_top(OPP100,SAMSUNG);
//   ddr_config_top(OPP50,SAMSUNG);
//   ddr_config_top(OPP25,SAMSUNG);

//   ddr_config_top(OPP100,ELPIDA2X2GBIT);
//   ddr_config_top(OPP50,ELPIDA2X2GBIT);
//   ddr_config_top(OPP25,ELPIDA2X2GBIT);
//   ddr_config_top(OPP100_SDC,ELPIDA2X2GBIT);
//	 ddr_config_top(OPP100_ES20,ELPIDA2X2GBIT);
//   ddr_config_top(OPP50_SDC,ELPIDA2X2GBIT);
//   ddr_config_top(OPP25_SDC,ELPIDA2X2GBIT);

//   ddr_config_top(OPP100,ELPIDA4X2GBIT);
//   ddr_config_top(OPP50,ELPIDA4X2GBIT);
//   ddr_config_top(OPP25,ELPIDA4X2GBIT);
//   ddr_config_top(OPP100_SDC,ELPIDA4X2GBIT);
//   ddr_config_top(OPP100_ES20,ELPIDA4X2GBIT);   
//   ddr_config_top(OPP50_SDC,ELPIDA4X2GBIT);
//   ddr_config_top(OPP25_SDC,ELPIDA4X2GBIT);

//   ddr_config_top(OPP100,HYNIX);
//   ddr_config_top(OPP50,HYNIX);
//   ddr_config_top(OPP25,HYNIX);

//   ddr_config_top(OPP100_SDC,MICRON);
//   ddr_config_top(OPP50_SDC,MICRON);
//   ddr_config_top(OPP25_SDC,MICRON);
   
//   opp_default_config_board(OPP100);	
//   opp_default_config_board(OPP50);	
//   opp_default_config_board(OPP25);	
//   opp_default_config_board(OPP100_SDC);
//	 opp_default_config_board(OPP100_ES20);
//   opp_default_config_board(OPP50_SDC);	
//   opp_default_config_board(OPP25_SDC);	

	/* Set clock config to OPP3 */
	//opp_default_config_zebu();
    
    
    
     /* DDR memory config */
     //zebu_ddr_config();
     //elpida_E1471E10_ddr_config_EMIF4D1_AND_EMIF4D2_wakeUp();
     //elpida_E1471E10_ddr_config_EMIF4D1_AND_EMIF4D2_boot();
     //elpida_E1471E10_ddr_config_EMIF4D1_AND_EMIF4D2_wakeUp(); 

     /* GPMC PSRAM Configuration to access all 26 bits of Address */
     *(int*) 0x4A100060 = 0x01080108; /* PAD0_GPMC_A16_PAD1_GPMC_A17 */
     *(int*) 0x4A100064 = 0x01080108; /* PAD0_GPMC_A18_PAD1_GPMC_A17 */
     *(int*) 0x4A100068 = 0x01080108; /* PAD0_GPMC_A20_PAD1_GPMC_A19 */
     *(int*) 0x4A10006C = 0x01080108; /* PAD0_GPMC_A22_PAD1_GPMC_A21 */
     *(int*) 0x4A100070 = 0x01080108; /* PAD0_GPMC_A24_PAD1_GPMC_A23 */
	 *(int*) 0x4A100088 = 0x01180108; /* PAD0_GPMC_NBE1_PAD1_GPMC_WAIT0 */

     /* GPMC Config to remove limited address restriction */
     reg = *(int*) 0x50000050;
     *(int*) 0x50000050 = reg | 0x2;

     GEL_TextOut("--->>> GPMC Reconfiguration Complete <<<---\n");

    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is in SECURE state!\n");
    }

   // Activate_Fast_download_using_DAP();
				
	// Force LPDDR2 IO keeper mode & Reset DDR PHYs
	//force_keeper();
				

	
	
}

//hotmenu Activate_Fast_download_using_DAP()
//{

//    if ((REG_SYSTEM_TARGET_STATUS & 0x80) != 0x80)
//    {
//       REG_SYSTEM_TARGET_CONTROL = 0x80; /* Turn on DAP download in CA9 driver */
//    }
     
//     GEL_TextOut("--->>> Using the CA9 driver with DAP download for images <<<---\n");
//}



//hotmenu Desactivate_Fast_download_using_DAP()
//{

//    GEL_TextOut("--->>> For loading Internal image in CortexA9 CPU0 (0x402f0000), fast download must be deasactivated  <<<---\n");
    
//    if ((REG_SYSTEM_TARGET_STATUS & 0x80) == 0x80)
//    {
//       REG_SYSTEM_TARGET_CONTROL = 0x80; /* Turn off DAP download in CA9 driver */
//    }
     
//     GEL_TextOut("--->>> removing the CA9 driver with DAP download for images <<<---\n");
//}


hotmenu Enter_Non_Secure_Mode()
{
    int reg;
    GEL_TextOut("--->>> Enter Non secure Mode <<<---\n");

    REG_TZ_SECURE = 0;
    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is still in SECURE state!\n");
    }
}

hotmenu Enter_Secure_Mode()
{
    int reg;
    GEL_TextOut("--->>> Enter secure Mode <<<---\n");

    REG_TZ_SECURE = 1;
    reg = REG_TZ_SECURE;
  
    if (reg == 0)
    {
         GEL_TextOut("The core is still in non-SECURE state. \n");
    }
    else
    {
      GEL_TextOut("The core is in SECURE state!\n");
    }
}

hotmenu Watchdog_disable()
{
	GEL_TextOut("--->>> Start WDT2 Watchdog Timer is disabled <<<---\n");
	 
   /* Enable clock */
   *(int*)0x4A307830 = 0x02;

   /* Check that module is Idle */
   while (((*(int *)0x4A307830) & 0x20000));
       
   /* Disable  watchdog 2 */
   /* Wait until reset complete */
   while (!((*(int *)0x4A314014) & 0x01));

   /* Disable watchdog timer */
   *(int*)0x4A314048 = 0x0000AAAA;

   while (((*(int *)0x4A314034) & 0x10));

   /* Disable 32Khz watchdog timer */
   *(int*)0x4A314048 = 0x00005555;

   while (((*(int *)0x4A314034) & 0x10));

   GEL_TextOut("--->>> End WDT2 Watchdog Timer is disabled <<<---\n");
}

hotmenu Secure_Watchdog_disable()
{
	GEL_TextOut("--->>> Start Secure Watchdog Timer is disabled <<<---\n");
	
   /* enable clock */
   *(int*)0x4A307828 = 0x02;

   /* Check that module is Idle */
   while (((*(int *)0x4A307828) & 0x20000));
       
   /* Disable  watchdog 2 */
   /* Wait until reset complete */
   while (!((*(int *)0x4A322014) & 0x01));

   /* Disable watchdog timer */
   *(int*)0x4A322048 = 0x0000AAAA;

   while (((*(int *)0x4A322034) & 0x10));

   /* Disable 32Khz watchdog timer */
   *(int*)0x4A322048 = 0x00005555;

   while (((*(int *)0x4A322034) & 0x10));

   GEL_TextOut("--->>> End Secure Watchdog Timer is disabled <<<---\n");
}

//hotmenu force_keeper()
//{
//  int dummy_read;

//  GEL_TextOut("--->>> Force DQS pulls to keeper <<<---\n");
//  *(int*)0x4A10063C = 0x9E9E9E9C;
//  *(int*)0x4A100640 = 0x9C9C9E9C;
//  *(int*)0x4A10064C = 0x9E9E9E9C;
//  *(int*)0x4A100650 = 0x9C9C9E9C;

  // Dummy read in LPDDR2
//  dummy_read = *(int*)0x80000000; //EMIF1
//  dummy_read = *(int*)0x80000080; //EMIF2

//  *(int*)0x4C000060 = 0x00002411;
//  *(int*)0x4D000060 = 0x00002411;

//  GEL_TextOut("--->>> Keeper force done <<<---\n");

//}
