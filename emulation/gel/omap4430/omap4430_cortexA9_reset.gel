/*******************************************************************/ 
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/* OMAP4430 cortexA9 reset config  		     					   */
/*                                                                 */
/*                                                                 */
/*  Author: Salamito thomas				     					   */
/*******************************************************************/
menuitem "RESET"
/**********************************************************************
 *
 *  FUNCTIONS
 *
 **********************************************************************/
#define CORTEXM3_RTOS_IN_RESET   1
#define CORTEXM3_SIMCOP_IN_RESET 2
#define CORTEXM3_RESET_MASK      3

hotmenu reset_ducati_cortexM3_RTOS_board()
{
	int cortexResetRegister, cortexResetStatus;

	GEL_TextOut(">> START reset_ducati_cortexM3_RTOS board 1\n");

	cortexResetRegister= *(int*)0x4A306910;
      cortexResetStatus = cortexResetRegister & CORTEXM3_RESET_MASK;
    
      GEL_TextOut("state %d\n",,,,, cortexResetStatus);
     
      // both devices in reset
	if (cortexResetStatus == (CORTEXM3_RTOS_IN_RESET | CORTEXM3_SIMCOP_IN_RESET) )
	{		
		GEL_TextOut("> DUCATI CLK CONFIG 1\n");
    
    		// Configure Ducati mode into Auto mode
    		// CORE_CM2:CM_DUCATI_DUCATI_CLKCTRL
    		*(int*)0x4A008920 = 0x00000001;
    
    		// Set force-wakeup domain transition
    		// CORE_CM2:CM_DUCATI_CLKSTCTRL = SW_WKUP
    		*(int*)0x4A008900 = 0x00000002;
    
    		// Reading 1 : clock is running ir gating/ungating transition is on-going.
    		while (((*(int*)0x4A008900) & 0x100)& ~0x100);
   
    		GEL_TextOut("< DUCATI CLOCK CONFIG 2\n");
	}

      // CORTEXM3_0 in reset
	if ( (cortexResetStatus & CORTEXM3_RTOS_IN_RESET) != 0 )
	{         
		// CORTEXM3_1 in reset
		if ((cortexResetStatus & CORTEXM3_SIMCOP_IN_RESET)!= 0)
		{
			GEL_TextOut("> DUCATI CLOCK CONFIG 3\n");
            
   			// Release Ducati MMU and Cache interface reset
			cortexResetRegister= cortexResetRegister& 0xFFFFFFFB;
   			*(int*)0x4A306910 = cortexResetRegister;
 
   			// read 4 Ducati MMU and Cache interface reset applied
   			while (((*(int*)0x4A306914) & 0x4)& ~0x4);
  
   			// Reset status cleared
   			*(int*)0x4A306914 = 0x00000004;
            
            	GEL_TextOut("> DUCATI CLOCK CONFIG 4\n");
   		}
   		
   		GEL_TextOut("> DUCATI CLOCK CONFIG 5\n");
        
   		/* Boot from Ducati L2RAM - self loop */
		/* Overwrite reset values for AMMU smallPage0&1 policy registers - 
			   Setting it for 16K to program L2MMU from GEL scripts */
		*(unsigned long*)0x55080A20=0xF;
		*(unsigned long*)0x55080A24=0xF;

		// Configure Ducati to boot from Ducati L2RAM
		// AMMU Small Page0 XLTE Register
		*(int*)0x550809A0 = 0x55020000;

		// Branch to itself in Ducati L2RAM - Adding the loop at 0x800 in L2RAM
		*(int*)0x55020004 = 0x801;
		*(int*)0x55020800 = 0xE7FEE7FE;
		/* End Boot from Ducati L2RAM - self loop */
   		
		 
		// Release Ducati CortexM3 RTOS
		cortexResetRegister= cortexResetRegister& 0xFFFFFFFE;
   		*(int*)0x4A306910 = cortexResetRegister;
   
   		// wait Ducati CortexM3 RTOS reset applied
   		while (((*(int*)0x4A306914) & 0x1)& ~0x1);
   
   		// Clear reset status
   		*(int*)0x4A306914 = 0x00000001;
   		
   // test that module is fully functional 
   // while (((*(int*)0x4A008920) & 0x30000)& 0x30000);syslink_bios_omap4.gel
	}
   	GEL_TextOut(">> END reset_ducati_cortexM3_RTOS board 4\n");
}

hotmenu reset_ducati_cortexM3_SIMCOP_board()
{
	int cortexResetRegister, cortexResetStatus;

	GEL_TextOut(">> START reset_ducati_cortexM3_SIMCOP board\n");

	cortexResetRegister= *(int*)0x4A306910;
    cortexResetStatus = cortexResetRegister & CORTEXM3_RESET_MASK;
        
	GEL_TextOut("state %d\n",,,,, cortexResetStatus );

	if (cortexResetStatus == (CORTEXM3_RTOS_IN_RESET | CORTEXM3_SIMCOP_IN_RESET) )
	{		
		GEL_TextOut("> DUCATI CLOCK CONFIG 10 \n");
    
    		// Configure Ducati mode into Auto mode
    		// CORE_CM2:CM_DUCATI_DUCATI_CLKCTRL
    		*(int*)0x4A008920 = 0x00000001;
    
    		// Set force-wakeup domain transition
    		// CORE_CM2:CM_DUCATI_CLKSTCTRL = SW_WKUP
    		*(int*)0x4A008900 = 0x00000002;
    
    		// Reading 1 : clock is running ir gating/ungating transition is on-going.
    		while (((*(int*)0x4A008900) & 0x100)& ~0x100);
   
    		GEL_TextOut("< DUCATI OPP CLOCK CONFIG 11 \n");
	}

	if ((cortexResetStatus & CORTEXM3_SIMCOP_IN_RESET)!= 0)
	{         
		if ( (cortexResetStatus & CORTEXM3_RTOS_IN_RESET) != 0 )
		{
            GEL_TextOut("> DUCATI CLOCK CONFIG 12\n");
        
   			// Release Ducati MMU and Cache interface reset
			
			cortexResetRegister = cortexResetRegister& 0xFFFFFFFB; 	
   			*(int*)0x4A306910 = cortexResetRegister;
 
   			// read 4 Ducati MMU and Cache interface reset applied
   			while (((*(int*)0x4A306914) & 0x4)& ~0x4);
  
   			// Reset status cleared
   			*(int*)0x4A306914 = 0x00000004;
   		}
        
       	GEL_TextOut("> DUCATI CLOCK CONFIG 13\n");
       	/* Boot from Ducati L2RAM - self loop */
	    /* Overwrite reset values for AMMU smallPage0&1 policy registers - 
			   Setting it for 16K to program L2MMU from GEL scripts */
		*(unsigned long*)0x55080A20=0xF;
		*(unsigned long*)0x55080A24=0xF;

		// Configure Ducati to boot from Ducati L2RAM
		// AMMU Small Page0 XLTE Register
		*(int*)0x550809A0 = 0x55020000;

		// Branch to itself in Ducati L2RAM - Adding the loop at 0x800 in L2RAM
		*(int*)0x55020004 = 0x801;
		*(int*)0x55020800 = 0xE7FEE7FE;
		/* End Boot from Ducati L2RAM - self loop */

		// Release Ducati CortexM3 SIMCOP
		cortexResetRegister = cortexResetRegister & 0xFFFFFFFD;
   		*(int*)0x4A306910 = cortexResetRegister;

		
   		// wait Ducati CortexM3 SIMCOP reset applied
   		while (((*(int*)0x4A306914) & 0x2)& ~0x2);
   
   		// Clear reset status
   		*(int*)0x4A306914 = 0x00000002;
   		
   // test that module is fully functional 
   //while (((*(int*)0x4A008920) & 0x30000)& 0x30000);
    }
    GEL_TextOut(">> END reset_ducati_cortexM3_SIMCOP board 14\n");
}


hotmenu reset_tesla_C64_board()
{
	GEL_TextOut(">> START reset_tesla_C64 board\n");

	GEL_TextOut("> TESLA IVA CLOCK CONFIG \n");

	 // IVAHD WAKEUP (after IVAHD dpll)
    	// Configure IVAHD and SL2 modules into "Auto" mode
    	// IVAHD_CM2:CM_IVAHD_IVAHD_CLKCTRL
    	*(int*)0x4A008F20 = 0x00000001;
    	// IVAHD_CM2:CM_IVAHD_SL2_CLKCTRL
    	*(int*)0x4A008F28 = 0x00000001;
    
    	// Set Force wakeUp domain transition
    	// IVAHD_CM2:CM_IVAHD_CLKSTCTRL = SW_WKUP
    	*(int*)0x4A008F00 = 0x00000002;
    
    	// Read1 IVAHD_ROOT_CLK is running or gatng/ungating transition is on-going
    	// while (((*(int*)0x4A008F00) & 0x100)& ~0x100);
        
    	// Configure Tesla mode into Auto mode
    	// TESLA_CM1:CM_TESLA_TESLA_CLKCTRL
    	*(int*)0x4A004420 = 0x00000001;    
    
    	// Set force-wakeup domain transition
    	// TESLA_CM1:CM_TESLA_CLKSTCTRL = SW_WKUP
    	*(int*)0x4A004400 = 0x00000002;
    
    	// Reading 1 : clock is running ir gating/ungating transition is on-going.
    	while (((*(int*)0x4A004400) & 0x100)& ~0x100);
    
    	GEL_TextOut("< TESLA IVA OPP CLOCK CONFIG\n");
        
        // release slave port reset for IVA-HD allows SL2 access.

       *(int*)0x4A306F10 &= ~(1 << 2); 


 	*(int*)0x5B000000 = 0;
	*(int*)0x5B000004 = 0;
	*(int*)0x5B000008 = 0;
	*(int*)0x5B00000C = 0;
	*(int*)0x5B000010 = 0;
	*(int*)0x5B000014 = 0;
	*(int*)0x5B000018 = 0;
	*(int*)0x5B00001c = 0;
	//*(int*)0x5B000020 = 0x0FFB0120;
	*(int*)0x5B000020 = 0x0FFfff12;

    // Set tesla boot address
    //*(int*)0x4A002304 = 0x40200000;  
    //*(int*)0x4A002304 = 0x40200000;  

    	*(int*)0x4A002304 = 0x10800000;  
    
    // DSP reset
    // RM_TESLA_RSTCTRL (MMU and DSP RESET)
    *(int*)0x4A306410 = 0x00000000;
    
    /* wait Tesla reset applied */
   while (((*(int*)0x4A306414) & 0x0001)& ~0x0001);
   
   /* wait slave port reset for IVA-HD reset applied */
   while (((*(int*)0x4A306F14) & 0x0004)& ~0x0004);   
  // Clear reset status 
  *(int*)0x4A306F14 = 0x4;
   
   /* Read 0x0 : test that module is fully functional */
   ;while (((*(int*)0x4A004420) & 0x30000)& ~0x30000);
   
   GEL_TextOut(">> END reset_tesla_C64 board\n");
}


hotmenu reset_ivahd_iCont1_board()
{
	GEL_TextOut(">> START reset_ivahd_iCont1_board \n");
   // iCont1 reset release (release slave port reset)

  // *(int*)0x4A306F10 &= ~(1 << 2); 

  // Write data to iCont1 ITM

  *(int*)0x5A008000 = 0x0;

  *(int*)0x5A008004 = 0x0;

  *(int*)0x5A008008 = 0x0;

  *(int*)0x5A00800C = 0x0;

  *(int*)0x5A008010 = 0xEAFFFFFE;

  // Release iCont1 reset

  *(int*)0x4A306F10 &= ~(1 << 0);

 
   /* wait iCont1 reset applied */
   while (((*(int*)0x4A306F14) & 0x0001)& ~0x0001);
   
  // Clear reset status 
  *(int*)0x4A306F14 = 0x1;
      
   /* Read 0x0 : test that IVAHD is fully functional */
   // while (((*(int*)0x4A008F20) & 0x30000)& ~0x30000);
   
   /* Read 0x0 : test that SL2 is fully functional */
   //while (((*(int*)0x4A008F28) & 0x30000)& ~0x30000);
   
   
   GEL_TextOut(">> END reset_ivahd_iCont1_board \n");
}

hotmenu reset_ivahd_iCont2_board()
{
	GEL_TextOut(">> START reset_ivahd_iCont2_board \n");
    
// iCont2 reset release (release slave port reset)

  // *(int*)0x4A306F10 &= ~(1 << 2); 

  // Write data to iCont2 ITM

  *(int*)0x5A018000 = 0x0;

  *(int*)0x5A018004 = 0x0;

  *(int*)0x5A018008 = 0x0;

  *(int*)0x5A01800C = 0x0;

  *(int*)0x5A018010 = 0xEAFFFFFE;

  // Release iCont2 reset

  *(int*)0x4A306F10 &= ~(1 << 1);

    /* wait iCont2 reset applied */
   while (((*(int*)0x4A306F14) & 0x0002)& ~0x0002);
 
  // Clear reset status 

  *(int*)0x4A306F14 = 0x2;

   /* Read 0x0 : test that IVAHD is fully functional */
   // while (((*(int*)0x4A008F20) & 0x30000)& ~0x30000);
   
   /* Read 0x0 : test that SL2 is fully functional */
   // while (((*(int*)0x4A008F28) & 0x30000)& ~0x30000);
   
   GEL_TextOut(">> END reset_ivahd_iCont2_board \n");
}

reset_ducati_cortexM3_RTOS()
{
	int register1;
	
	GEL_TextOut(">> START reset_ducati_cortexM3_RTOS \n");
       
   // Release Ducati MMU and Cache interface reset
   *(int*)0x4A306910 = 0x00000003;
 
   // read 4 Ducati MMU and Cache interface reset applied
   while (((*(int*)0x4A306914) & 0x4)& ~0x4);
  
   // Reset status cleared
   *(int*)0x4A306914 = 0x00000004;
   
   // Release Ducati CortexM3 RTOS (CortexM3 SIMCOP must be released by CortexM3 RTOS)
   *(int*)0x4A306910 = 0x00000002;
   
   // wait Ducati CortexM3 RTOS reset applied
   while (((*(int*)0x4A306914) & 0x1)& ~0x1);
   
   // Clear reset status
   *(int*)0x4A306914 = 0x00000001;
   
   // test that module is fully functional 
   // while (((*(int*)0x4A008920) & 0x30000)& 0x30000);
    
   GEL_TextOut(">> END reset_ducati_cortexM3_RTOS \n");
}

reset_ducati_cortexM3_SIMCOP()
{
	GEL_TextOut(">> START reset_ducati_cortexM3_SIMCOP (must be done after CortexM3_RTOS out of reset \n");
        
   // Release Ducati CortexM3 SIMCOP
   *(int*)0x4A306910 = 0x00000000;

   // wait Ducati CortexM3 SIMCOP reset applied
   while (((*(int*)0x4A306914) & 0x2)& ~0x2);
   
   // Clear reset status
   *(int*)0x4A306914 = 0x00000002;
   
   // test that module is fully functional 
   //while (((*(int*)0x4A008920) & 0x30000)& 0x30000);
    
   GEL_TextOut(">> END reset_ducati_cortexM3_SIMCOP \n");
}

reset_tesla_C64()
{
	GEL_TextOut(">> START reset_tesla_C64 \n");
    
 *(int*)0x88000000 = 0;
*(int*)0x88000004 = 0;
*(int*)0x88000008 = 0;
*(int*)0x8800000C = 0;
*(int*)0x88000010 = 0;
*(int*)0x88000014 = 0;
*(int*)0x88000018 = 0;
*(int*)0x8800001c = 0;
//*(int*)0x88000020 = 0x0FFB0120;
*(int*)0x88000020 = 0x0FFfff12;



    // Set tesla boot address
    //*(int*)0x4A002304 = 0x40200000;  
//*(int*)0x4A002304 = 0x40200000;  

    	*(int*)0x4A002304 = 0x88000000;  
    
    // DSP reset
    // RM_TESLA_RSTCTRL (MMU and DSP RESET)
    *(int*)0x4A306410 = 0x00000000;
    
    /* wait Tesla reset applied */
   while (((*(int*)0x4A306414) & 0x0001)& ~0x0001);
   
   /* Read 0x0 : test that module is fully functional */
   ;while (((*(int*)0x4A004420) & 0x30000)& ~0x30000);
   
   GEL_TextOut(">> END reset_tesla_C64 \n");
}

reset_ivahd_iCont1()
{
	GEL_TextOut(">> START reset_ivahd_iCont1 \n");
    // Icont1 reset
    *(int*)0x4A306F10 = 0x00000002;
    
    /* wait iCont1 reset applied */
   while (((*(int*)0x4A306F14) & 0x0005)& ~0x0005);
   
   /* Reset status cleared */
   *(int*)0x4A306F14 = 0x00000007;
   
   /* Read 0x0 : test that IVAHD is fully functional */
   while (((*(int*)0x4A008F20) & 0x30000)& ~0x30000);
   
   /* Read 0x0 : test that SL2 is fully functional */
   while (((*(int*)0x4A008F28) & 0x30000)& ~0x30000);
   
   
   
   GEL_TextOut(">> END reset_ivahd_iCont1 \n");
}

reset_ivahd_iCont2()
{
	GEL_TextOut(">> START reset_ivahd_iCont2 \n");
    // Icont2 reset
    *(int*)0x4A306F10 = 0x00000001;
    
    /* wait iCont2 reset applied */
   while (((*(int*)0x4A306414) & 0x0006)& ~0x0006);
   
   /* Reset status cleared */
   *(int*)0x4A306F14 = 0x00000007;
   
   /* Read 0x0 : test that IVAHD is fully functional */
   while (((*(int*)0x4A008F20) & 0x30000)& ~0x30000);
   
   /* Read 0x0 : test that SL2 is fully functional */
   while (((*(int*)0x4A008F28) & 0x30000)& ~0x30000);
   
   GEL_TextOut(">> END reset_ivahd_iCont2 \n");
}
