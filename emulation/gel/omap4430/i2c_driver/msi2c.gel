





/* ============================================================================
* LOCAL TYPES AND DEFINITIONS
* =============================================================================
*/

/* Address size */
#define MSI2C_10BIT_ADD_MAX     0x03FF
#define MSI2C_7BIT_ADD_MAX      0x007F

/* Data number max to transmit */
#define MSI2C_DATA_NUMBER_MAX   0xFFFF

/* I2C Max Mode (for parameter control): Fast/Standard =0, High Speed = 1.  SCCB is not allowed  */
#define MSI2C_MODE_MAX          3

/* Master-Slave configuration*/
#define    MSI2C_MASTER_MODE       1
#define    MSI2C_SLAVE_MODE        0

/* Mode of communication */
#define    MSI2C_TRANSMITTER_MODE  1
#define    MSI2C_RECEIVER_MODE     0

/* Time counter for differents wait functions */
/*  Reset timeout counter .*/
#define MSI2C_RESET_TIMEOUT_COUNTER_INIT_VALUE      0x000000FF
/*  Bus busy timeout .*/
#define MSI2C_BB_TIMEOUT_COUNTER_INIT_VALUE         0x00000FFF
/* Address as slave timeout .*/
#define MSI2C_AAS_TIMEOUT_COUNTER_INIT_VALUE        0x00000FFF
/* Triton Init timeout .*/
#define TRITON_BB_TIMEOUT_COUNTER_INIT_VALUE		0x0000FFFF

#define    MSI2C_INT_ARBITRATION_LOST           MSHSI2COCP_I2C_IE_AL_IE_LO_16_MASK
#define    MSI2C_INT_NO_ACKNOWLEDGMENT          MSHSI2COCP_I2C_IE_NACK_IE_LO_16_MASK
#define    MSI2C_INT_RESISTER_ACCESS_READY      MSHSI2COCP_I2C_IE_ARDY_IE_LO_16_MASK
#define    MSI2C_INT_RECEIVE_DATA_READY         MSHSI2COCP_I2C_IE_RRDY_IE_LO_16_MASK
#define    MSI2C_INT_TRANSMIT_DATA_READY        MSHSI2COCP_I2C_IE_XRDY_IE_LO_16_MASK
#define    MSI2C_INT_GENERAL_CALL               MSHSI2COCP_I2C_IE_GC_IE_LO_16_MASK
#define    MSI2C_INT_START_CONDITION            MSHSI2COCP_I2C_IE_STC_IE_LO_16_MASK
#define    MSI2C_INT_ACCESS_ERROR               MSHSI2COCP_I2C_IE_AERR_IE_LO_16_MASK
#define    MSI2C_INT_BUS_FREE                   MSHSI2COCP_I2C_IE_BF_IE_LO_16_MASK
#define    MSI2C_INT_ADDRESSED_AS_SLAVE         MSHSI2COCP_I2C_IE_ASS_IE_LO_16_MASK
#define    MSI2C_INT_RECEIVE_DRAINING           MSHSI2COCP_I2C_IE_RDR_IE_LO_16_MASK
#define    MSI2C_INT_TRANSMIT_DRAINING          MSHSI2COCP_I2C_IE_XDR_IE_LO_16_MASK
#define    MSI2C_INT_TRANSMIT_UNDERFLOW         0x0400u
#define    MSI2C_INT_RECEIVE_OVERRUN            0x0800u
#define    MSI2C_INT_BUS_BUSY                   0x1000u
#define    MSI2C_INT_ALL                        0x63ff
#define    MSI2C_INT_NONE                       0x00


/* ============================================================================
* GLOBAL VARIABLES
* =============================================================================
*/
int stuck = 0;
int timeoutCounter = 0x0;

/* ============================================================================
* LOCAL FUNCTIONS PROTOTYPES
* =============================================================================
*/

MSI2C_Init( int baseAddress, short prescaler, char scll, char sclh, char    hsscll, char hssclh )
{
    timeoutCounter = MSI2C_RESET_TIMEOUT_COUNTER_INIT_VALUE; /* to count the timeout */
	
	GEL_TextOut("MSI2C_Init Function\n",,1);

	/* DEBUG TRACE */    
	//GEL_TextOut("baseAddress %x\n",,,,,baseAddress);
	//GEL_TextOut("prescaler %x\n",,,,,prescaler);
	//GEL_TextOut("scll %x\n",,,,,scll);
	//GEL_TextOut("sclh %x\n",,,,,sclh);
	//GEL_TextOut("hsscll %x\n",,,,,hsscll);
	//GEL_TextOut("hssclh %x\n",,,,,hssclh);

    /* Force MSI2C module disable */
    MSHSI2COCPI2C_CONI2C_ENWrite32L((int)baseAddress, 0x0000);           /* beach function */

    /* Set MSI2C module core frequency */
    MSHSI2COCPI2C_PSCWriteRegister32L((int)baseAddress, prescaler);      /* beach function */

    /* Set SCL frequency for fast/standard speed mode */
    MSHSI2COCPI2C_SCLLSCLLWrite32L((int)baseAddress, scll);          /* beach function */
    MSHSI2COCPI2C_SCLHSCLHWrite32L((int)baseAddress, sclh);          /* beach function */

    /* Set SCL frequency for high speed mode */
    MSHSI2COCPI2C_SCLLHSSCLLWrite32L((int)baseAddress, hsscll);          /* beach function */
    MSHSI2COCPI2C_SCLHHSSCLHWrite32L((int)baseAddress, hssclh);          /* beach function */

    /* Enable MSI2C module */
    MSHSI2COCPI2C_CONI2C_ENWrite32L((int)baseAddress, 0x0001);           /* beach function */

    /* Wait until reset complete and avoid infinite loop */
    while(
         ( MSHSI2COCPI2C_SYSSRDONERead32L((int)baseAddress) != 0x0001 ) && /* beach function */
         ( (--timeoutCounter) != 0                       )
         );

    /* If timeout occurred */
    if (timeoutCounter == 0)
    {
		GEL_TextOut("Time Out !!!\n",,2);
        //RES_Set(RES_MSI2C_BASE + RES_TIMEOUT_ERR);
        //returnCode = RET_TIMEOUT;
        //return returnCode;
    }
}

/*==================== Function Separator =============================*/

MSI2C_Configure( int baseAddress, char opMode, int startByte, int addressLength, short ownAddress, char masterCode )
{
    GEL_TextOut("MSI2C_Configure Function\n",,1);

	/* DEBUG TRACE */
	//GEL_TextOut("baseAddress %x\n",,,,,baseAddress);
	//GEL_TextOut("opMode %x\n",,,,,opMode);
	//GEL_TextOut("startByte %x\n",,,,,startByte);
	//GEL_TextOut("addressLength %x\n",,,,,addressLength);
	//GEL_TextOut("ownAddress %x\n",,,,,ownAddress);
	//GEL_TextOut("masterCode %x\n",,,,,masterCode);

    /* Configure MSI2C operation mode */
    MSHSI2COCPI2C_CONOPMODEWrite32L((int)baseAddress,(short)opMode);                                          /* beach function */

    /* Set MSI2C module start byte mode */
    MSHSI2COCPI2C_CONSTBWrite32L((int)baseAddress,
                                 (short)startByte);            /* beach function */

    /* Set MSI2C module address length mode */
    MSHSI2COCPI2C_CONXSAWrite32L((int)baseAddress,
                                (short)addressLength);        /* beach function */

    /* Set MSI2C module own address */
    MSHSI2COCPI2C_OAOAWrite32L((int)baseAddress,ownAddress);          /* beach function */

    /* Set MSI2C master code */
    MSHSI2COCPI2C_OAMCODEWrite32L((int)baseAddress,masterCode);    /* beach function */
}

/*==================== Function Separator =============================*/

MSI2C_IntAck( int baseAddress, short intSet )
{
    short RegVal;
	
    //GEL_TextOut("MSI2C_IntAck Function\n",,1);
	
	/* DEBUG TRACE */
	//GEL_TextOut("baseAddress %x\n",,,,,baseAddress);
	//GEL_TextOut("intSet %x\n",,,,,intSet);

    /* Enable requested Interruption */
    RegVal = MSHSI2COCPI2C_STATReadRegister32L((int)baseAddress);          /* beach function */
    RegVal = (RegVal & 0xFFE0) | ( intSet & 0x001F );
    MSHSI2COCPI2C_STATWriteRegister32L((int)baseAddress,
                             (short) RegVal);             /* beach function */
}


/*==================== Function Separator =============================*/

MSI2C_MasterSendPolling( int baseAddress, short slaveAddress, char regAddress, char pDataArray, short dataNumber)
{
    unsigned int stop = 0x0;
	char DATA = 0x0;
    short count;          /* to count the number of byte sent to the MSI2C module */
    short currentState;   /* to store the current state of the MSI2C module */
    timeoutCounter = MSI2C_BB_TIMEOUT_COUNTER_INIT_VALUE; /* to count the timeout */
	
	// GEL_TextOut("MSI2C_MasterSendPolling Function\n",,1);

	/* DEBUG TRACE */
	//GEL_TextOut("baseAddress %x\n",,,,,baseAddress);
	//GEL_TextOut("slaveAddress %x\n",,,,,slaveAddress);
	//GEL_TextOut("regAddress %x\n",,,,,regAddress);
	//GEL_TextOut("pDataArray %x\n",,,,,pDataArray);
	//GEL_TextOut("dataNumber %x\n",,,,,dataNumber);

    /* Wait for bus free */
    while(
         ( MSHSI2COCPI2C_STATBBRead32L((int)baseAddress) == 1 ) &&           /* beach function */
         ( (--timeoutCounter) != 0               )
         );

    /* If timeout occurred */
    if (timeoutCounter == 0)
    {
        GEL_TextOut("Time Out !!!\n",,2);
        //RES_Set(RES_MSI2C_BASE + RES_TIMEOUT_ERR);              /* spy function */
        //returnCode = RET_TIMEOUT;
        //return returnCode;
    }

    /* Configure slave device address */
    MSHSI2COCPI2C_SASAWrite32L((int)baseAddress, slaveAddress);              /* beach function */

    /* Configure data count */
    MSHSI2COCPI2C_CNTDCOUNTWrite32L((int)baseAddress, dataNumber);           /* beach function */

    /* Configure transfer - Master, Transmitter, Stop */
    MSHSI2COCPI2C_CONMSTWrite32L((int)baseAddress, MSI2C_MASTER_MODE);       /* beach function */
    MSHSI2COCPI2C_CONTRXWrite32L((int)baseAddress, MSI2C_TRANSMITTER_MODE);  /* beach function */
    MSHSI2COCPI2C_CONSTPWrite32L((int)baseAddress, 0x1);                     /* beach function */

    /* Start transfer */
    MSHSI2COCPI2C_CONSTTWrite32L((int)baseAddress, 0x1);                     /* beach function */

    /* Send data */
    count = 0;
  
  while(stop == 0x0)
    {       
        /* Added for GEL Driver 'cause pointers are not possible in GEL Files... */
        if(count == 0)
			DATA = (char)regAddress;
		else if (count == 1)
			DATA = (char)pDataArray;
		else
			DATA = 0x0;
	       
        /* Read current MSI2C module State */
        currentState = MSHSI2COCPI2C_STATReadRegister32L((int)baseAddress);  /* beach function */
		//GEL_TextOut("currentState = %d\n",,,,,currentState);
        
        if ( MSHSI2COCPI2C_STATALGet32L(currentState) == 0x01)          /* beach function */
        { /* Arbitratin lost */
            /* Clear flag */
            MSHSI2COCPI2C_STATALWrite32L((int)baseAddress, 0x0001);          /* beach function */
            //RES_Set(RES_MSI2C_BASE + RES_START_FAIL);           /* spy function */
            //returnCode = RET_FAIL;
            //return returnCode;
			stop = 0x1;
			GEL_TextOut("STOP1\n");
        }

        if ( MSHSI2COCPI2C_STATNACKGet32L(currentState) == 0x00)        /* beach function */
        { /* NACK not set */
            if ( MSHSI2COCPI2C_STATARDYGet32L(currentState) == 0x00)    /* beach function */
            { /* ARDY not set */
                if ( MSHSI2COCPI2C_STATXRDYGet32L(currentState) != 0x00)/* beach function */
                { /* XRDY set: need new data to send */

                   GEL_TextOut("DATA %x\n",,,,,DATA);
                   MSHSI2COCPI2C_DATAWriteRegister32LL(
                                baseAddress,
                                (char)(DATA)
                                );                              /* beach function */
                   count ++;

                   /* Acknowledge XRDY */
                   MSI2C_IntAck((int)baseAddress,MSI2C_INT_TRANSMIT_DATA_READY );
                }
                else if  ( MSHSI2COCPI2C_STATXDRGet32L(currentState) != 0x00 )
                {
                   GEL_TextOut("DATA1 %x\n",,,,,DATA);
                   MSHSI2COCPI2C_DATAWriteRegister32LL(
                                baseAddress,
                                (char)(DATA)
                                );                              /* beach function */
                   count ++;
                   
                   /* Acknowledge XDR */
                   MSI2C_IntAck((int)baseAddress,MSI2C_INT_TRANSMIT_DRAINING);

                }
            }
            else
            { /* ARDY set */
                /* Acknowledge ARDY */
                MSI2C_IntAck((int)baseAddress,MSI2C_INT_RESISTER_ACCESS_READY );
                if( MSHSI2COCPI2C_CONSTPRead32L((int)baseAddress) == 0 )     /* beach function */
                { /* STP is cleared */
                    //return returnCode;                          /* transfer ended */
                	stop = 0x1;
					//GEL_TextOut("STOP2\n");
                }
            }
        }
        else
        { /* NACK received */
            /* Clear flag */
            MSHSI2COCPI2C_STATNACKWrite32L((int)baseAddress, 0x0001);        /* beach function */
            MSHSI2COCPI2C_CONSTPWrite32L((int)baseAddress, 0x1);            /* 2420 modification */
            //RES_Set(RES_MSI2C_BASE + RES_WRITE_FAIL);          /* spy function */
            //returnCode = RET_FAIL;
            //return returnCode;
			stop = 0x1;
			GEL_TextOut("STOP3\n");
        }
    }
}

/*==================== Function Separator =============================*/

MSI2C_MasterReceivePolling( int baseAddress, short slaveAddress, char pDataArray, short dataNumber )
{
    unsigned int stop = 0x0;
    short currentState;   /* to store the current state of the MSI2C module */
    short currentData;    /* to store the last reiceved data */
	char data = 0x0;
	timeoutCounter = MSI2C_BB_TIMEOUT_COUNTER_INIT_VALUE; /* to count the timeout */

	GEL_TextOut("MSI2C_MasterReceivePolling Function\n",,1);

	/* DEBUG TRACE */
	//GEL_TextOut("baseAddress %x\n",,,,,baseAddress);
	//GEL_TextOut("slaveAddress %x\n",,,,,slaveAddress);
	//GEL_TextOut("pDataArray %x\n",,,,,pDataArray);
	//GEL_TextOut("dataNumber %x\n",,,,,dataNumber);

    /* Wait for bus free */
    while(
         ( MSHSI2COCPI2C_STATBBRead32L((int)baseAddress) == 1 ) &&           /* beach function */
         ( --timeoutCounter != 0                 )
         );

    /* If timeout occurred */
    if (timeoutCounter == 0)
    {
        GEL_TextOut("Time Out !!!\n",,2);
    }

    /* Configure slave device address */
    MSHSI2COCPI2C_SASAWrite32L((int)baseAddress, slaveAddress);              /* beach function */

    /* Configure data count */
    MSHSI2COCPI2C_CNTDCOUNTWrite32L((int)baseAddress, dataNumber);           /* beach function */

    /* Configure transfer - Master, Receiver, Stop */
    MSHSI2COCPI2C_CONMSTWrite32L((int)baseAddress, MSI2C_MASTER_MODE);       /* beach function */
    MSHSI2COCPI2C_CONTRXWrite32L((int)baseAddress, MSI2C_RECEIVER_MODE);     /* beach function */
    MSHSI2COCPI2C_CONSTPWrite32L((int)baseAddress, 0x1);                     /* beach function */

    /* Start transfer */
    MSHSI2COCPI2C_CONSTTWrite32L((int)baseAddress, 0x1);                     /* beach function */

    /* Receive data */
    //for(;;)
    while(stop == 0x0)
    {
        /* Read current MSI2C module State */
        currentState = MSHSI2COCPI2C_STATReadRegister32L((int)baseAddress);  /* beach function */

        if ( MSHSI2COCPI2C_STATALGet32L(currentState) == 0x01)          /* beach function */
        { /* Arbitratin lost */
            /* Clear flag */
            MSHSI2COCPI2C_STATALWrite32L((int)baseAddress, 0x0001);           /* beach function */
            //RES_Set(RES_MSI2C_BASE + RES_START_FAIL);            /* spy function */
            //returnCode = RET_FAIL;
            //return returnCode;
			stop = 0x1;
			//GEL_TextOut("STOP1\n");
        }
        if ( MSHSI2COCPI2C_STATNACKGet32L(currentState) == 0x00)        /* beach function */
        { /* NACK not set */
            if ( MSHSI2COCPI2C_STATARDYGet32L(currentState) == 0x00 )   /* beach function */
            { /* ARDY not set */
                if ( MSHSI2COCPI2C_STATRRDYGet32L(currentState) != 0x00)/* beach function */
                { /* RRDY set: new data reiceved */
                    currentData = MSHSI2COCPI2C_DATAReadRegister32LL((int)baseAddress);/* beach function */
                    data = (char)(currentData & 0x00FF); /* Store data */
					GEL_TextOut("DATA %x\n",,,,,data);
                    //pDataArray ++;
                    /* Acknowledge RRDY */
                    MSI2C_IntAck((int)baseAddress,MSI2C_INT_RECEIVE_DATA_READY );
                }
                else if ( MSHSI2COCPI2C_STATRDRGet32L(currentState) != 0x00 )
                {
                   /* RDR set: new data reiceved */
                   currentData = MSHSI2COCPI2C_DATAReadRegister32LL((int)baseAddress);/* beach function */
                    data = (char)(currentData & 0x00FF); /* Store data */
					GEL_TextOut("DATA %x\n",,,,,data);
                    //pDataArray ++;
                    /* Acknowledge RDR */
                   MSI2C_IntAck((int)baseAddress,MSI2C_INT_RECEIVE_DRAINING);
                }

            }
            else
            { /* ARDY set */
                /* Acknowledge ARDY */
                MSI2C_IntAck((int)baseAddress,MSI2C_INT_RESISTER_ACCESS_READY );
                if( MSHSI2COCPI2C_CONSTPRead32L((int)baseAddress) == 0 )     /* beach function */
                { /* STP is cleared */
                    //return returnCode;                          /* transfer ended */
                	stop = 0x1;
					//GEL_TextOut("STOP2\n");
                }
            }
         }
        else
        { /* NACK received */
            /* Clear flag */
            MSHSI2COCPI2C_STATNACKWrite32L((int)baseAddress, 0x0001);         /* beach function */
            MSHSI2COCPI2C_CONSTPWrite32L((int)baseAddress, 0x1);            /* 2420 modification */
            //RES_Set(RES_MSI2C_BASE + RES_READ_FAIL);            /* spy function */
            //returnCode = RET_FAIL;
            //return returnCode;
			stop = 0x1;

        }
    }
	return data;
}
