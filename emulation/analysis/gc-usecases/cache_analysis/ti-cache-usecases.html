
<!doctype html>
<html>
<head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <link rel="icon" type="image/png" href="images/ti_gui_icon.png">
        <script src="../components/webcomponentsjs/webcomponents-lite.js"></script>
        <script src="../components/ti-core-assets/scripts/gcDesktop.js"></script>
        <link rel="import" href="../components/ti-core-databind/ti-core-databind.html">
        <link rel="stylesheet" href="overriden.css">
        <link rel="import" href="../components/ti-widget-common/ti-widget-container.html">
        <link rel="import" href="../components/ti-widget-common/ti-widget-listbox.html">
        <link rel="import" href="../components/ti-widget-common/ti-widget-tabcontainer.html">
        <link rel="import" href="../components/ti-widget-common/ti-widget-tab.html">
        <link rel="import" href="../components/ti-widget-common/ti-widget-button.html">
        <link rel="import" href="../components/ti-widget-common/ti-widget-label.html">
        <link rel="import" href="../components/ti-widget-common/ti-widget-input.html">
        <link rel="import" href="../components/ti-widget-helpbutton/ti-widget-helpbutton.html">
            <link rel="import" href="../components-dbgtrc/ti-trace-model/ti-trace-model.html">
        <link rel="import" href="../components/polymer/polymer.html">
         }

</head>

<body class="ti-theme">
    <dom-module name='ti-cache-usecases'>
        <template>
            <style>

              #ti_widget_container1 {
              text-align: left;
              text-decoration: none;
              font-weight: normal;
              font-style: normal;
              font-size: inherit;
              height: 100%;
              width: 100%;
              display: flex;
              overflow:auto;

              }
              .tab_container {
              text-align: left;
              text-decoration: none;
              font-weight: normal;
              font-style: normal;
              font-size: inherit;
              overflow: initial;
              margin: 20px;
              display:flex;
              }

              #ti_widget_tabcontainer {
              flex-grow: 1;
              width: 75%;
              }

              #ti_widget_listbox1 {
              font-size: inherit;
              font-style: normal;
              font-weight: normal;
              text-decoration: none;
              text-align: left;
              opacity: 1;
              height:100%;
              width:25%;
              }


              #top-container {
              height: 100%;
              width: 100%;
              display: flex;
              flex-direction: column;
              overflow:auto;
              min-width: 500px;
              min-height:600px;
              }

              #toolbar {
              background-color: rgb(223, 223, 223);
              display:flex;
              }

              #ti_widget_helpbutton {
              width: 40px;
              height: 21px;
              margin: 11px;
              position:relative;
              display:flex;

              }
			  
			  #helpicon {
			  fill: black;
			  }

              .filldiv {
              flex-grow: 1;
              }

              #container {
              height: 100%;
              width: 100%;
              display: flex;
              flex-direction: row;
              overflow:auto;
              }
              #leftThing {
              background-color:red;
              }

              #content {
              display:block;
              }
              :root{
              --paper-tab-content:{white-space:normal;};
              }
            </style>

            <ti-core-stylesheets id="ti_core_stylesheets" class="_TI_"></ti-core-stylesheets>
            <ti-trace-model id="tm" device-id="{{devId}}" trace-agent="{{ta}}" active-core="{{activeCore}}" device-info="{{deviceInfo}}"></ti-trace-model>
            <ti-widget-container id="top-container">
                <paper-toolbar class="_TI_" id="toolbar" horizontal="" layout="">
                    <div class="filldiv" ></div>
                  <ti-widget-helpbutton id="ti_widget_helpbutton" title-text="{{uc_val}}" icon-color="black" icon-size-in-px="23" tile-position="below_left" tile-width-in-px="300" tile-height-in-px="300" markdown-text="{{md_txt}}"></ti-widget-helpbutton>
                  <paper-button id="rstOnStart_button" toggles="" on-click="_rstOnStartHdlr" title="{{rstbtn_title}}">
                            <iron-icon icon="restore"></iron-icon>
                    </paper-button>
                    <paper-button id="syncRun_button" toggles="" on-click="_syncRunHdlr" title="{{syncrun_title}}">
                            <iron-icon icon="link"></iron-icon>
                    </paper-button>
                </paper-toolbar>

                <ti-widget-container visible="" id="ti_widget_container1" class="_TI_" horizontal="" layout="">
                    <ti-widget-listbox id="ti_widget_listbox1" selected-index="{uc_index}}" selected-value="{{uc_val}}" selected-text="{{uc_txt}}" values="{{uc1}}|{{uc2}}|{{uc3}}|{{uc4}}" labels="{{uc1}}|{{uc2}}|{{uc3}}|{{uc4}}"  initial-index="0"  visible="" class="_TI_ x-scope ti-widget-listbox-0"></ti-widget-listbox>
                    <ti-widget-tabcontainer selected-index="{{uc_index}}" selected-label="{{uc_val}}" id="ti_widget_tabcontainer" layout="" class="_TI_" one="" flex="">
                        <ti-widget-tab name="{{uc1}}" icon-style="width:25px;padding-right:5px;" font-size="inherit" font-style="normal" font-weight="normal" text-align="left" text-decoration="none" visible=""  id="tab1" class="_TI_ iron-selected" title="">
                            <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal" text-align="left" text-decoration="none" visible="" class="tab_container" title="" horizontal="" layout="">
                                <div class="filldiv"  one="" flex=""></div>
                                <ti-widget-button label="Start" button-type="default" raised="" on-click="_onStart_uc1_hdlr" visible="" bindable-trigger="7" id="start_button_uc1" animated="" title="" elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                                <ti-widget-button label="Stop" button-type="default" raised="" on-click="_onStop_uc1" visible="" bindable-trigger="7" id="stop_button_uc1" disabled="" animated="" title="" elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                            </ti-widget-container>                
                            <table class="_TI_" id="cacheTable1">
                                <colgroup class="_TI_" width="400"></colgroup>
                                <tbody class="_TI_">
                                    <tr class="_TI_">
                                        <th class="_TI_">
                                            <ti-widget-label id="uc1_head0" label="{{uc1_th0}}" text-align="left" font-size="large" font-style="normal" font-weight="normal"  text-decoration="none"  wrap="" visible=""  ></ti-widget-label>
                                        </th>
                                        <th class="_TI_">
                                            <ti-widget-label id="uc1_head1" label="{{uc1_th1}}" text-align="left" font-size="large" font-style="normal" font-weight="normal"  text-decoration="none" wrap=""  visible=""  class="_TI_" ></ti-widget-label>
                                        </th>
                                    </tr>
                                    <template is="dom-repeat" items="{{uc1_tableItems}}" as="item1">
                                    <tr>
                                        <td class="_TI_" id="td">
                                            <ti-widget-label label="{{item1.col1}}" text-align="left" font-size="inherit" font-style="normal" font-weight="normal" text-decoration="none" wrap="" visible  class="_TI_"></ti-widget-label>
                                        </td>
                                        <td class="_TI_" id="td1">
                                            <ti-widget-input label="{{item1.col2}}" id="ti_widget_input" class="_TI_"></ti-widget-input>
                                        </td>                    
                                    </tr>
                                    </template>
                
                                </tbody>
                            </table>
                        </ti-widget-tab>  
                        <ti-widget-tab name="{{uc2}}" icon-style="width:25px;padding-right:5px;" font-size="inherit" font-style="normal" font-weight="normal" text-align="left" text-decoration="none" id="tab2" class="_TI_ " title="">
                                <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal" text-align="left" text-decoration="none"  class="tab_container" title="" horizontal="" layout="">
                                    <div class="filldiv"  one="" flex=""></div>
                                    <ti-widget-button label="Start" button-type="default" raised="" on-click="_onStart_uc2_hdlr" visible="" bindable-trigger="7" id="start_button_uc2" animated="" title="" elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                                    <ti-widget-button label="Stop" button-type="default" raised="" on-click="_onStop_uc2" visible="" bindable-trigger="7" id="stop_button_uc2" disabled="" animated="" title="" elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                                </ti-widget-container>                
                                <table class="_TI_" id="cacheTable2">
                                    <colgroup class="_TI_" width="400"></colgroup>
                                    <tbody class="_TI_">
                                        <tr class="_TI_">
                                            <th class="_TI_">
                                                <ti-widget-label id="uc2_head0" label="{{uc2_th0}}" text-align="left" font-size="large" font-style="normal" font-weight="normal"  text-decoration="none"  wrap="" visible=""  ></ti-widget-label>
                                            </th>
                                            <th class="_TI_">
                                                <ti-widget-label id="uc2_head0" label="{{uc2_th1}}" text-align="left" font-size="large" font-style="normal" font-weight="normal"  text-decoration="none" wrap=""  visible=""  class="_TI_" ></ti-widget-label>
                                            </th>
                                        </tr>
                                        <template is="dom-repeat" items="{{uc2_tableItems}}" as="item2">
                                        <tr>
                                            <td class="_TI_" id="td">
                                                <ti-widget-label label="{{item2.col1}}" text-align="left" font-size="inherit" font-style="normal" font-weight="normal" text-decoration="none" wrap="" visible="" class="_TI_"></ti-widget-label>
                                            </td>
                                            <td class="_TI_" id="td1">
                                                <ti-widget-input label="{{item2.col2}}" id="ti_widget_input" class="_TI_"></ti-widget-input>
                                            </td>                    
                                        </tr>
                                        </template>
                    
                                    </tbody>
                                </table>
                            </ti-widget-tab>      
                    
                        <ti-widget-tab name="{{uc3}}" icon-style="width:25px;padding-right:5px;" font-size="inherit" font-style="normal" font-weight="normal" text-align="left" text-decoration="none" id="tab3" class="_TI_ " title="">
                                <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal" text-align="left" text-decoration="none"  class="tab_container" title="" horizontal="" layout="">
                                    <div class="filldiv"  one="" flex=""></div>
                                    <ti-widget-button label="Start" button-type="default" raised="" on-click="_onStart_uc3_hdlr" visible="" bindable-trigger="7" id="start_button_uc3" animated="" title="" elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                                    <ti-widget-button label="Stop" button-type="default" raised="" on-click="_onStop_uc3" visible="" bindable-trigger="7" id="stop_button_uc3" disabled="" animated="" title="" elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                                </ti-widget-container>                
                                <table class="_TI_" id="cacheTable3">
                                    <colgroup class="_TI_" width="400"></colgroup>
                                    <tbody class="_TI_">
                                        <tr class="_TI_">
                                            <th class="_TI_">
                                                <ti-widget-label id="uc3_head0" label="{{uc3_th0}}" text-align="left" font-size="large" font-style="normal" font-weight="normal"  text-decoration="none"  wrap="" visible=""  ></ti-widget-label>
                                            </th>
                                            <th class="_TI_">
                                                <ti-widget-label id="uc3_head0" label="{{uc3_th1}}" text-align="left" font-size="large" font-style="normal" font-weight="normal"  text-decoration="none" wrap=""  visible=""  class="_TI_" ></ti-widget-label>
                                            </th>
                                        </tr>
                                        <template is="dom-repeat" items="{{uc3_tableItems}}" as="item3">
                                        <tr>
                                            <td class="_TI_" id="td">
                                                <ti-widget-label label="{{item3.col1}}" text-align="left" font-size="inherit" font-style="normal" font-weight="normal" text-decoration="none" wrap="" visible="" class="_TI_"></ti-widget-label>
                                            </td>
                                            <td class="_TI_" id="td1">
                                                <ti-widget-input label="{{item3.col2}}" id="ti_widget_input" class="_TI_"></ti-widget-input>
                                            </td>                    
                                        </tr>
                                        </template>
                    
                                    </tbody>
                                </table>
                            </ti-widget-tab>      
                            <ti-widget-tab name="{{uc4}}" icon-style="width:25px;padding-right:5px;" font-size="inherit" font-style="normal" font-weight="normal" text-align="left" text-decoration="none" id="tab4" class="_TI_ " title="">
                                <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal" text-align="left" text-decoration="none"  class="tab_container" title="" horizontal="" layout="">
                                    <div class="filldiv"  one="" flex=""></div>
                                    <ti-widget-button label="Start" button-type="default" raised="" on-click="_onStart_uc4_hdlr" visible="" bindable-trigger="7" id="start_button_uc4" animated="" title="" elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                                    <ti-widget-button label="Stop" button-type="default" raised="" on-click="_onStop_uc4" visible="" bindable-trigger="7" id="stop_button_uc4" disabled="" animated="" title="" elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                                </ti-widget-container>                
                                <table class="_TI_" id="cacheTable4">
                                    <colgroup class="_TI_" width="400"></colgroup>
                                    <tbody class="_TI_">
                                        <tr class="_TI_">
                                            <th class="_TI_">
                                                <ti-widget-label id="uc4_head0" label="{{uc4_th0}}" text-align="left" font-size="large" font-style="normal" font-weight="normal"  text-decoration="none"  wrap="" visible=""  ></ti-widget-label>
                                            </th>
                                            <th class="_TI_">
                                                <ti-widget-label id="uc4_head0" label="{{uc4_th1}}" text-align="left" font-size="large" font-style="normal" font-weight="normal"  text-decoration="none" wrap=""  visible=""  class="_TI_" ></ti-widget-label>
                                            </th>
                                        </tr>
                                        <template is="dom-repeat" items="{{uc4_tableItems}}" as="item4">
                                        <tr>
                                            <td class="_TI_" id="td">
                                                <ti-widget-label label="{{item4.col1}}" text-align="left" font-size="inherit" font-style="normal" font-weight="normal" text-decoration="none" wrap="" visible="" class="_TI_"></ti-widget-label>
                                            </td>
                                            <td class="_TI_" id="td1">
                                                <ti-widget-input label="{{item4.col2}}" id="ti_widget_input" class="_TI_"></ti-widget-input>
                                            </td>                    
                                        </tr>
                                        </template>                    
                                    </tbody>
                                </table>
                            </ti-widget-tab>                          
                        </ti-widget-tabcontainer>   
                </ti-widget-container>
            </ti-widget-container>
        </template>
 
        <script>
		/* global Promise:false */
          Polymer({
          is: 'ti-cache-usecases',
          properties: {

          ctset2_prop_default : {
          type: Array,
          value: (function () {
          return [
          {
          name : "Type",
          sub_properties: [
          {name : "SRAM Bank", type : "String", value : "SRAM Bank 0"},
          {name : "Event to Count", type : "String", value : "SRAM External Access"},
          {name : "Event Detection Type", type : "String", value : "Edge"},
          {name : "Counter Size", type : "String", value : "32 Bit"},
          {name : "Current Count", type : "Number", value : 0},
          {name : "Overflow", type : "String", value : "no overflow"},
          ]
          }
          ];
          }),
          notify: true,
          reflectToAttribute: true,
          },

          ta : {
          notify: true,
          type: Object,
          reflectToAttribute: true
          },
          devId : {
          notify: true,
          type: Number,
          reflectToAttribute: true,
          value: undefined,
          observer: '_devIdChanged'
          },
          activeCore: {
          notify: true,
          type: String,
          reflectToAttribute: true,
          value: undefined,
          observer: '_activeCoreChanged'
          },
          corepacSelected : {
          notify: true,
          type: Number,
          reflectToAttribute: true,
          value: undefined,
          observer: '_corepacSelChanged'
          },
          deviceInfo : {
          notify: true,
          type: String,
          reflectToAttribute: true,
          value: undefined,
          observer: '_devInfoChanged'
          },

          md_txt:{
          type: String,
          value: ""
          },

          rstbtn_title:{
          type: String,
          value: ""
          },

          syncrun_title:{
          type: String,
          value: ""
          },

          uc_index:{
          type: Number,
          value: 0,
          observer: '_ucIndexChanged'
          },

          uc_val:{
          type: String,
          value: ""
          },

          uc_txt:{
          type: String,
          value: ""
          },

          uc_tab:{
          type: String,
          value: ""
          },

          uc1:{
          type: String,
          value: ""
          },

          uc1_th0:{
          type: String,
          value: ""
          },

          uc1_th1:{
          type: String,
          value: ""
          },

          uc1_tableItems:{
          type: Array,
          value: []
          },

          uc2:{
          type: String,
          value: ""
          },

          uc2_th0:{
          type: String,
          value: ""
          },

          uc2_th1:{
          type: String,
          value: ""
          },

          uc2_tableItems:{
          type: Array,
          value: []
          },

          uc3:{
          type: String,
          value: ""
          },

          uc3_th0:{
          type: String,
          value: ""
          },

          uc3_th1:{
          type: String,
          value: ""
          },

          uc3_tableItems:{
          type: Array,
          value: []
          },

          uc4:{
          type: String,
          value: ""
          },

          uc4_th0:{
          type: String,
          value: ""
          },

          uc4_th1:{
          type: String,
          value: ""
          },

          uc4_tableItems:{
          type: Array,
          value: []
          },

          },

          tm : null,
          rstOnStart : [],
          syncRun :[],
          uc_helpInfo :[],
          corepacInfo : [],
          mycpuNames: [],
          cpuFullNames : [],
          mycpuNames_uc1: [],
          cpuFullNames_uc1 : [],
          core_connected :[],
          msmc_ctset2_connected : false,
          start_alert : [],

          armPmuAetHndl : [],
          ctset2AetHndl : [],
          armPmu_alert : "",
          ctset2_alert : "",
          ctset2Cnt : [],
          ctset2Ovfl : [],
          armPmuCnt : [],
          num_ctset2_cnt : 8,
          jobInProg : [],
          uc1InProg : false,
          uc2InProg : false,
          uc3InProg : false,
          uc4InProg : false,
          msmc_ctset2_inuse : false,

          /* GUI component status */
          uc1_startStatus: [], // usecase1 START button disable status: true -- disabled, false -- enabled
          uc1_stopStatus: [], // usecase1 STOP button disable status: true -- disabled, false -- enabled
          uc2_startStatus: [], // usecase2 START button disable status: true -- disabled, false -- enabled
          uc2_stopStatus: [], // usecase2 STOP button disable status: true -- disabled, false -- enabled
          uc3_startStatus: [], // usecase3 START button disable status: true -- disabled, false -- enabled
          uc3_stopStatus: [], // usecase3 STOP button disable status: true -- disabled, false -- enabled
          uc4_startStatus: [], // usecase4 START button disable status: true -- disabled, false -- enabled
          uc4_stopStatus: [], // usecase4 STOP button disable status: true -- disabled, false -- enabled
          uc1_tdata: [], //usecase1 table data
          uc2_tdata: [], //usecase2 table data
          uc3_tdata: [], //usecase3 table data
          uc4_tdata: [], //usecase4 table data

          cpuExeStatus : [],
          emulator : "",
          trace : undefined,
          //Below are constants
          deviceID_k3m4 : 0x0bb5a02f, //AM654x device ID 0x0bb5a02f
          deviceID_k3m2 : 0xffffffff, // this is the Maxwell M2 ID, TODO, temp value here
          _rstbtn_title_enable: "Click to enable Reset on Start. Counter values will automatically reset when job is started.",
          _rstbtn_title_disable : "Click to disable Reset On Start. Counter values will continue from the last run when job is started.",
          _syncRun_title_enable : "Click to enable the automatic start of job on target run and automatic stop of job on target halt.",
          _syncRun_title_disable : "Click to disable the automatic start of job on target run and automatic stop of job on target halt.",
          tgtEvtCallback : undefined,

          _devIdChanged : function() {
          var _self = this;

          _self.init_devinfo();
          //_self.init();
          _self.init_var(); //this is only called when device ID has changed

          _self.check_corepac_sel();

          },

          _activeCoreChanged : function() {
          var _self = this;
          //_self.init();
          _self.check_corepac_sel();

          },

          check_corepac_sel : function() {
          var _self = this;
          //_self.init();

          /* Initialize the corepacSelected value based on highlighted core */
          if ((_self.devId == _self.deviceID_k3m4) || (_self.devId == _self.deviceID_k3m2) ) { //Maxwell M4 or M2
          if (_self.activeCore === "CortexA53_0_0" || _self.activeCore === "CortexA53_0_1") {
          _self.corepacSelected = 0;
          } else if (_self.activeCore === "CortexA53_1_0" || _self.activeCore === "CortexA53_1_1") {
          _self.corepacSelected = 1;
          } else {
          _self.corepacSelected = 9999; //this number represented unsupported cores


          }
          }
          },
          _corepacSelChanged : function() {
          var _self = this;


          // Initialize the usecase list
          _self.init_uclist();
          // Initialize each use case
          _self.init_uc();

          if (_self.corepacSelected != 9999) {
          // GUI updates based on selected core context
          // START/STOP button update
          _self.update_start_stop_btn('#start_button_uc1',_self.uc1_startStatus[_self.corepacSelected], '#stop_button_uc1', _self.uc1_stopStatus[_self.corepacSelected]);
          _self.update_start_stop_btn('#start_button_uc2',_self.uc2_startStatus[_self.corepacSelected], '#stop_button_uc2', _self.uc2_stopStatus[_self.corepacSelected]);
          _self.update_start_stop_btn('#start_button_uc3',_self.uc3_startStatus[_self.corepacSelected], '#stop_button_uc3', _self.uc3_stopStatus[_self.corepacSelected]);
          _self.update_start_stop_btn('#start_button_uc4',_self.uc4_startStatus[_self.corepacSelected], '#stop_button_uc4', _self.uc4_stopStatus[_self.corepacSelected]);

          // Data table update
          _self.table_init_uc1(_self.uc1_tdata[_self.corepacSelected]);
          _self.table_init_uc2(_self.uc2_tdata[_self.corepacSelected]);
          _self.table_init_uc3(_self.uc3_tdata[_self.corepacSelected]);
          _self.table_init_uc4(_self.uc4_tdata[_self.corepacSelected]);

          // Sync Run button update
          _self.syncRunBtn_update();

          // rstOnStart button update
          _self.rstBtn_update();


          }

          },


          _ucIndexChanged : function() {

          var _self = this;

          _self.md_txt = _self.uc_helpInfo[_self.uc_index];

          },

          _devInfoChanged : function() {
          var _self = this;
          _self.emulator = _self.deviceInfo.name;
          var i,j;

          _self.cpuFullNames_uc1 = JSON.parse(JSON.stringify(_self.mycpuNames_uc1));
          _self.cpuFullNames = JSON.parse(JSON.stringify(_self.mycpuNames));

          /* Initialize trace model element */
          _self.tm = document.querySelector('#tm');
          if (_self.tm == null) {
          console.log("Trace model init failed!");
          } else {

          for (i=0; i<_self.corepacInfo.length;i++) {
                      /* Construct the full cpu names for uc1 */
                      for (j = 0; j < _self.mycpuNames_uc1[i].length; j++) {
                              _self.cpuFullNames_uc1[i][j] = _self.emulator + "/" + _self.mycpuNames_uc1[i][j];                                                   
                      }
                      /* Construct the full cpu names for uc2,3,4 */
                      for (j = 0; j < _self.mycpuNames[i].length; j++) {
                          _self.cpuFullNames[i][j] = _self.emulator + "/" + _self.mycpuNames[i][j];
                      }
                  }
                
              }        
                //_self.init();                
            },

            ready: function () {
                var _self = this;
                
                _self.md_txt = "Please select a usecase first!"; 
                _self.rstbtn_title = _self._rstbtn_title_disable;
                _self.syncrun_title = _self._syncRun_title_enable;

                this.tgtEvtCallback = this._tgtEvtCallback.bind(this);

            },



            update_start_stop_btn : function (startBtn_id, start_val, stopBtn_id, stop_val ) {
                var startbtn = document.querySelector(startBtn_id);
                var stopbtn = document.querySelector(stopBtn_id);
                if (startbtn != null)
                    startbtn.disabled = start_val;
                if (stopbtn != null)
                    stopbtn.disabled = stop_val;
                
            },

            /////////////////////////////////////////////////////////
            // initialize the internal variables
            /////////////////////////////////////////////////////////
            init_var : function() {
                var _self = this;
                var i=0;

                _self.jobInProg = [];
                

                for (i=0;i<_self.corepacInfo.length;i++) {
                    _self.jobInProg[i] = false;
                    _self.syncRun[i] = false;
                    _self.rstOnStart[i] = true;
                    _self.start_alert[i] = "";

                    _self.uc1_tdata[i] = ["","","","","",""];
                    _self.uc2_tdata[i] = ["",""];
                    _self.uc3_tdata[i] = ["","","",""];
                    _self.uc4_tdata[i] = ["",""];

                    
                    _self.uc1_startStatus[i] = false; // START button by default is enabled
                    _self.uc1_stopStatus[i] = true; // STOP button by default is disabled
                    _self.uc2_startStatus[i] = false; // START button by default is enabled
                    _self.uc2_stopStatus[i] = true; // STOP button by default is disabled
                    _self.uc3_startStatus[i] = false; // START button by default is enabled
                    _self.uc3_stopStatus[i] = true; // STOP button by default is disabled
                    _self.uc4_startStatus[i] = false; // START button by default is enabled
                    _self.uc4_stopStatus[i] = true; // STOP button by default is disabled

                    _self.core_connected[i] = [];
                    _self.cpuExeStatus[i] = [];
                    // Assume all cores are not connected at start and set initial exe state to halted
                    for (var j=0; j<_self.corepacInfo[i].num_cores;j++) {
                        _self.core_connected[i][j] = false;
                        _self.cpuExeStatus[i][j] = "halted";
                    }

                }


                //GUI update for START/STOP button
                        _self.update_start_stop_btn('#start_button_uc1',false, '#stop_button_uc1', true);
                        _self.update_start_stop_btn('#start_button_uc2',false, '#stop_button_uc2', true);
                        _self.update_start_stop_btn('#start_button_uc3',false, '#stop_button_uc3', true);
                        _self.update_start_stop_btn('#start_button_uc4',false, '#stop_button_uc4', true);



                        },


                        /////////////////////////////////////////////////////////
                        // initialize the device info
                        /////////////////////////////////////////////////////////
                        init_devinfo : function() {
                        var _self = this;

                        /* Initialize the corepac info */
                        if (_self.devId == _self.deviceID_k3m4)  { //Maxwell M4

                        console.log("corepacInfo is being initialized for Maxwell");

                        /* TODO, need to revisit if we can get this from ctools K3 database */
                        _self.corepacInfo =
                        [   /* corepac type, number of cores */
                        { "type": "a53", "num_cores": "2" }, //Corepac-0
                        { "type": "a53", "num_cores": "2" }  //Corepac-1
                        ];
                        _self.mycpuNames_uc1 =
                        [
                        ["CortexA53_0_0","CortexA53_0_1", "CTSET2_0"], //cores related to Corepac-0 for uc1
                        ["CortexA53_1_0","CortexA53_1_1", "CTSET2_0"]  //cores related to Corepac-1 for uc1
                        ];
                        _self.mycpuNames =
                        [
                        ["CortexA53_0_0","CortexA53_0_1"], //cores related to Corepac-0 for uc2,3,4
                        ["CortexA53_1_0","CortexA53_1_1"]  //cores related to Corepac-1 for uc2,3,4
                        ];
                        } else if (_self.devId == _self.deviceID_k3m2) { //Maxwell M2
                        _self.corepacInfo =
                        [   /* corepac type, number of cores */
                        { "type": "a53", "num_cores": "2" } //Corepac-0
                        ];
                        _self.mycpuNames_uc1 =
                        [
                        ["CortexA53_0_0","CortexA53_0_1", "CTSET2_0"], //cores related to Corepac-0 for uc1
                        ];
                        _self.mycpuNames =
                        [
                        ["CortexA53_0_0","CortexA53_0_1"], //cores related to Corepac-0 for uc2,3,4
                        ];

                        } else {
                        //placeholder for other device
                        }
                        },


                        init_helpInfo:function() {

                        var _self = this;
                        var des_h = "**Description**<br><br>";
                        var tips_h = "**Tips**<br><br>";
                        var tip1 = "1. ARM PMU counters will be used for this use case. Please make sure those counters are not used in " + 
                                   "the application code while running this use case.<br><br>";
                        var tip2 = "2. Use hardware breakpoints instead of software breakpoints to debug your code when running this use case. " + 
                                   "Usage of software breakpoints may interfere with instruction cache behavior causing inaccurate result for this use case.<br>";


                        _self.uc_helpInfo = [ 
                                    des_h + "This use case presents the cache hit percentage data at L1/L2/L3 cache levels for each CorePac CPU.<br><br>" + tips_h + tip1 + tip2,
                                    des_h + "This use case presents the cachable data percentage for all the data accesses for each CorePac CPU.<br><br>" + tips_h + tip1,
                                    des_h + "This use case presents the MMU TLB hit percentage data for each CorePac CPU.<br><br>" + tips_h + tip1 + tip2,
                                    des_h + "This use case presents the CPU performance benchmarking data in the unit of Instruction Per Cycle for each CorePac CPU.<br><br>" + tips_h + tip1
                                  ];
                        },


                        /////////////////////////////////////////////////////////
                        // initialize the usecase list here
                        /////////////////////////////////////////////////////////
                        init_uclist:function() {
                        var _self = this;
                        var tabs = document.querySelector('#ti_widget_tabcontainer');

                        if ((_self.devId == _self.deviceID_k3m4) || (_self.devId == _self.deviceID_k3m2) ){ //Maxwell M4 and Maxwell M2
                        if (_self.corepacSelected != 9999) {
                        _self.uc1 = "Cache Hit Percentage";
                        _self.uc2 = "Cacheable Data Percentage";
                        _self.uc3 = "ARM MMU TLB Hit Percentage";
                        _self.uc4 = "CPU Performance Benchmark";

                        _self.init_helpInfo();
                        
                        _self.md_txt = _self.uc_helpInfo[0];

                        // show the use cases tabs
                        if (tabs != null)
                        tabs.style = "visibility:visible";

                        } else {
                        _self.uc1 = "No Use Case found for the selected core";
                        _self.uc2 = "";
                        _self.uc3 = "";
                        _self.uc4 = "";

                        // For invalid cases, hide the use cases tabs
                        if (tabs != null)
                        tabs.style = "visibility:hidden";
                        }
                        } else {

                        _self.uc1 = "No Use Case found for the device. Check if the device is connected first, then close this window and retry";
                        _self.uc2 = "";
                        _self.uc3 = "";
                        _self.uc4 = "";

                        // For invalid cases, hide the use cases tabs
                        if (tabs != null)
                        tabs.style = "visibility:hidden";
                        }

                        },

                        /////////////////////////////////////////////////////////
                        // initialize the usecase
                        /////////////////////////////////////////////////////////
                        init_uc : function() {
                        var _self = this;

                        if ((_self.corepacSelected != 9999) && (_self.corepacSelected != undefined) && (_self.corepacInfo.length > 0)) {                    
                    _self.init_uc1();
                    _self.init_uc2();
                    _self.init_uc3();
                    _self.init_uc4();
                }
            },
            

            /////////////////////////////////////////////////////////
            // Enable Target events for SyncRun
            /////////////////////////////////////////////////////////
            syncRun_init: function() {
                var _self = this;
				var p = [];
				var j;
                
    
                if ((_self.corepacInfo.length > 0) && (_self.corepacSelected != 9999) || (_self.corepacSelected!=undefined)) {

                if (_self.syncRun[_self.corepacSelected]) {
                    console.log("Add target event listener");
                    _self.ta.cloudTrace.addListener("targetEvent", _self.tgtEvtCallback);


                    //return new Promise(function (resolve, reject) {
                        //Enable the CCS event notification for all the relevant cores in the selected CorePac. 
                        for (j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                                p[j] = _self.ta.cloudTrace.enableTargetEvents(_self.cpuFullNames[_self.corepacSelected][j]);
                        }

                        Promise.all(p).then(function () {
                            console.log("Event notification enable passed");
                            return _self.preRun_init();
                        }).then(function(){
                            console.log("Sync Run is now enabled");
                            _self.syncRunBtn_update(); //update the SyncRun button
                            //return resolve(retObj);
                        }).catch(function (err) {
                            console.log("Event notification enable FAILED: " + err.toString());
                            console.log("Sync Run is still disabled");
                            //re-disable SyncRun
                            _self.syncRun[_self.corepacSelected] = false;
                            _self.syncRunBtn_update(); //update the SyncRun button
                            //Generate a warning to user
                            alert("Sync Run operation cannot be enabled! Please make sure all the cores in the selected CorePac are connected in CCS and then retry!");
                            //return reject(err);
                        });                        
                     
                    //});
                } else {
                    console.log("Remove target event listener");
                    _self.ta.cloudTrace.removeListener("targetEvent", _self.tgtEvtCallback);

                    //return new Promise(function (resolve, reject) {
                        //Disable the CCS event notification for all the relevant cores in the selected CorePac. 
                        for (j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                                p[j] = _self.ta.cloudTrace.disableTargetEvents(_self.cpuFullNames[_self.corepacSelected][j]);
                        }

                        Promise.all(p).then(function () {
                            console.log("Event notification disable passed");
                            return _self.preRun_init();
                        }).then(function(){
                            console.log("Sync Run is now disabled");
                            _self.syncRunBtn_update(); //update the SyncRun button
                            //return resolve(retObj);
                        }).catch(function (err) {
                            console.log("Event notification disable FAILED: " + err.toString());
                            console.log("Sync Run is still enabled");
                            //re-enable SyncRun
                            _self.syncRun[_self.corepacSelected] = true;
                            _self.syncRunBtn_update(); //update the SyncRun button
                            //Generate a warning to user
                            alert("Sync Run operation cannot be disabled! Please make sure all the cores in the selected CorePac are connected in CCS and then retry!");
                            //return reject(err);
                        });                        
                }
            }
            },


            /////////////////////////////////////////////////////////
            // _profile_arm_pmu_start()
            // Configure and enable ARM PMU counter 
            /////////////////////////////////////////////////////////
            _profile_arm_pmu_start : function(cpu_name, cnt_id, evt_to_count) {
                var _self = this;
                var aetopHandle;
                var armpmu_prop_setval;
                var armpmu_prop_getval;
				var i;

                /* Initialize the ARM PMU counter overflow alert text */
                _self.armPmu_alert = "";

                return new Promise(function (resolve, reject) {
                    /* Create the AET operation server for ARM PMU counter */
                    _self.ta.cloudTrace.createOperation(cpu_name, "AET").then(function (retObj) {
                        /* save the AET operation handle for later use */
                        aetopHandle = retObj.handle;
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " operation created: id = " + aetopHandle);
                        return retObj;
                    }).then(function () {
                        // Get the property tree for ARM PMU counter
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function(retObj) {
                        armpmu_prop_setval = retObj.cfg;
                        var armpmu_prop = armpmu_prop_setval[0]; 

                        // Modify the properties for ARM PMU counter
                        for (i=0; i < armpmu_prop.sub_properties.length; i++) {
                            if (armpmu_prop.sub_properties[i].name === "Event to Count") {
                                armpmu_prop.sub_properties[i].value = evt_to_count;
                            }
                        }
                        // Set the ARM PMU counter properties 
                        return _self.ta.cloudTrace.setProperties(aetopHandle, armpmu_prop_setval);
                    }).then(function () {
                        // Get the ARM PMU counter properties again
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function(retObj) {
                        // Confirm the new ARM PMU counter properties have been set correctly
                        armpmu_prop_getval = retObj.cfg;
                        if (JSON.stringify(armpmu_prop_getval) === JSON.stringify(armpmu_prop_setval)) {
                            console.log("setProperties() passed");
                            /* Enable the AET operation for ARM PMU counter */
                            return _self.ta.cloudTrace.setEnableOperation(aetopHandle, true);
                        }
                        else {
                            var err = "setProperties() failed";
                            console.log(err);  
                            return reject(err);                          
                        }                        
                     }).then(function (retObj) {
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " operation enabled");
                        return retObj;
                    }).then(function (retObj) {
                        _self._saveArmAetHndl(cpu_name, cnt_id, aetopHandle);
                        console.log("_profile_arm_pmu_start() passed: " + cpu_name + ", cnt_id = " + cnt_id);
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_arm_pmu_start() failed: " + cpu_name + ", cnt_id = " + cnt_id + " " + err.toString());
                    });
                });

            },


            /////////////////////////////////////////////////////////
            // _profile_arm_pmu_stop()
            // Disable ARM PMU counter 
            /////////////////////////////////////////////////////////
            _profile_arm_pmu_stop : function(cpu_name, cnt_id) {
                var _self = this;
                var aetopHandle;
                var cntval;
                var ovfl;
                var hdl_index;

                return new Promise(function (resolve, reject) {
                    /* Get the AET operation handle based on the cpu_name and cnt_id */
                    for (var i = 0; i < _self.armPmuAetHndl.length; i++) {
                        if ((_self.armPmuAetHndl[i].core == cpu_name) && (_self.armPmuAetHndl[i].cntid == cnt_id)) {
                            aetopHandle = _self.armPmuAetHndl[i].aetop;
                            hdl_index = i;
                            break;
                        }
                    }

                    if (aetopHandle == null)
                        return reject("AET Operation Handle is NULL");

                    _self.ta.cloudTrace.getProperties(aetopHandle).then(function (retObj) {
                        /* Get the current count value and overflow value */
                        var armpmu_prop = retObj.cfg[0];
                        
                        // Modify the properties for ARM PMU counter
                        for (var i=0; i < armpmu_prop.sub_properties.length; i++) {
                            if (armpmu_prop.sub_properties[i].name === "Current Count") {
                                cntval = armpmu_prop.sub_properties[i].value;
                            } else if (armpmu_prop.sub_properties[i].name === "Overflow") {
                                ovfl = armpmu_prop.sub_properties[i].value;
                            }
                        }
                        /* Save the counter value and overflow status */
                        _self._save_arm_counter(cpu_name, cnt_id, cntval, ovfl, _self.rstOnStart[_self.corepacSelected]);
                        //console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " Count Value: " + cntval + ", Overflow: " + ovfl);
                        /* Disable the counter */
                        return _self.ta.cloudTrace.setEnableOperation(aetopHandle, false);
                    }).then(function () {
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " operation disabled");
                        /* Release the AET operation */
                        return _self.ta.cloudTrace.releaseOperation(aetopHandle);
                    }).then(function (retObj) {
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " operation released");
                        _self.armPmuAetHndl[hdl_index].aetop = null; //Reset the corresponding AET Operation handle to null
                        console.log("_profile_arm_pmu_stop() passed: " + cpu_name + ", cnt_id = " + cnt_id);
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_arm_pmu_stop() failed: " + cpu_name + ", cnt_id = " + cnt_id + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _save_arm_counter()
            // Save the ARM PMU counter value and overflow status
            // resetCnt -- when false, new counter value will be added to the old value; when true, new counter value will replace the old value
            /////////////////////////////////////////////////////////
            _save_arm_counter:function(cpu_name, cnt_id, cntval, ovfl, resetCnt) {
            var _self = this;

            var found = false;

            for (var i = 0; i < _self.armPmuCnt.length; i++) {
                    //If the entry for the existing cpu and cnt_id already exists, then just update the counter value
                    if ((_self.armPmuCnt[i].core == cpu_name) && (_self.armPmuCnt[i].cntid == cnt_id)) {
            if (resetCnt)
            _self.armPmuCnt[i].cntval = cntval;
            else
            _self.armPmuCnt[i].cntval += cntval;

            _self.armPmuCnt[i].ovfl = ovfl;
            found = true;
            console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " Count Value: " + _self.armPmuCnt[i].cntval + ", Overflow: " + ovfl);
            break;
            }
            }

            // If we didn't find any entry in _self.armPmuCnt for the cpu_name and cnt_id spedified, then we will create a new entry for it
            if (!found) {
            var obj = { "core": cpu_name, "cntid": cnt_id, "cntval": cntval, "ovfl": ovfl };
            console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " Count Value: " + cntval + ", Overflow: " + ovfl);
            _self.armPmuCnt.push(obj);
            }

            },

            /////////////////////////////////////////////////////////
            // _get_arm_counter()
            // Fetch the ARM PMU counter value and overflow status
            /////////////////////////////////////////////////////////
            _get_arm_counter:function(cpu_name, cnt_id) {
            var _self = this;

            var obj = { "found": false, "cntval": 0, "ovfl": false };

            for (var i = 0; i < _self.armPmuCnt.length; i++) {
                    //If the entry for the existing cpu and cnt_id already exists, then just update the counter value
                    if ((_self.armPmuCnt[i].core == cpu_name) && (_self.armPmuCnt[i].cntid == cnt_id)) {
            obj.found = true;
            obj.cntval = _self.armPmuCnt[i].cntval;
            obj.ovfl = _self.armPmuCnt[i].ovfl;
            break;
            }
            }

            return obj;
            },


            /////////////////////////////////////////////////////////
            // _saveArmAetHndl()
            /////////////////////////////////////////////////////////
            _saveArmAetHndl : function(cpu_name, cnt_id, aetopHandle) {
            var _self = this;

            var found = false;


            for (var i = 0; i < _self.armPmuAetHndl.length; i++) {
                    if ((_self.armPmuAetHndl[i].core == cpu_name) && (_self.armPmuAetHndl[i].cntid == cnt_id)) {
            _self.armPmuAetHndl[i].aetop = aetopHandle;
            found = true;
            break;
            }
            }

            if (!found) {
            var obj = { "core": "", "cntid": "", "aetop": 0 };
            obj.core = cpu_name;
            obj.cntid = cnt_id;
            obj.aetop = aetopHandle;

            _self.armPmuAetHndl.push(obj);
            }
            },

            /////////////////////////////////////////////////////////
            // _profile_msmc_ctset2_stop()
            // Get the CTSET2 counter values and then disable the counters
            /////////////////////////////////////////////////////////
        _profile_msmc_ctset2_stop : function(cnt_id) {
            
            var _self = this;

            var aetopHandle = _self.ctset2AetHndl[cnt_id];

            return new Promise(function (resolve, reject) {

                _self.ta.cloudTrace.getProperties(aetopHandle).then(function (retObj) {
                    /* Get the current count value and overflow value */
                    var ctset2_prop = retObj.cfg[0];
                    
                    for (var i=0; i < ctset2_prop.sub_properties.length; i++) {
                        if (ctset2_prop.sub_properties[i].name === "Current Count") {
                            if (_self.rstOnStart[_self.corepacSelected])
                                _self.ctset2Cnt[cnt_id] = ctset2_prop.sub_properties[i].value;
                            else
                                _self.ctset2Cnt[cnt_id] += ctset2_prop.sub_properties[i].value;
                        } else if (ctset2_prop.sub_properties[i].name === "Overflow") {
                            _self.ctset2Ovfl[cnt_id] = ctset2_prop.sub_properties[i].value;
                        }
                    }
                    console.log("MSMC CTSET2 Counter " + cnt_id + " Count Value: " + _self.ctset2Cnt[cnt_id] + ", Overflow: " + _self.ctset2Ovfl[cnt_id]);
                    /* Disable the counter */
                    return _self.ta.cloudTrace.setEnableOperation(aetopHandle, false);
                }).then(function () {
                    console.log("MSMC CTSET2 Counter " + cnt_id + " operation disabled");
                    /* Release the AET operation */
                    return _self.ta.cloudTrace.releaseOperation(aetopHandle);
                }).then(function (retObj) {
                    console.log("MSMC CTSET2 Counter " + cnt_id + " operation released");
                    _self.ctset2AetHndl[cnt_id] = null;
                    console.log("_profile_msmc_ctset2_stop() passed: cnt_id = " + cnt_id);
                    return resolve(retObj);
                }).catch(function (err) {
                    _self.ctset2AetHndl[cnt_id] = null;
                    return reject("_profile_msmc_ctset2_stop() failed: cnt_id = " + cnt_id + err.toString());
                });
            });
        },

            /////////////////////////////////////////////////////////
            /* Initialize counters needed for L3 cache benchmarking */
            /////////////////////////////////////////////////////////
            _l3_cnt_reset: function() {
            var _self = this;

            for (var i = 0; i < _self.num_ctset2_cnt; i++) {
                    _self.ctset2Cnt[i] = 0;
                }
            },

            _rstOnStartHdlr : function() {
                var _self = this;
                
                // Do nothing if there is job running
                if (_self.jobInProg[_self.corepacSelected]) {
                    alert("Cannot change this while there is job running!");
                } else {
                    //toggle the rstOnStart status
                    _self.rstOnStart[_self.corepacSelected] = !_self.rstOnStart[_self.corepacSelected];
                    _self.rstBtn_update();
                }
            },

            _syncRunHdlr: function() {
                var _self = this;
                
                // Do nothing if there is job running
                if (_self.jobInProg[_self.corepacSelected]) {
                    alert("Cannot change this while there is job running!");
                } else {
                    var corepac_connected = true;
                    var unconn_cores = "";

                    // Check if all the cores in the selected corepac are connected or not before we call the enable/disable target event commands
                    _self.check_corepac_connected().then(function() {
                        for (var i=0; i<_self.corepacInfo[_self.corepacSelected].num_cores;i++) {

                            if (!_self.core_connected[_self.corepacSelected][i]){
                                corepac_connected = false;
                                unconn_cores += _self.cpuFullNames[_self.corepacSelected][i] + "\n";
                            }
                        }

                        //Generate a warning if not all the cores in the selected corepac are connected and then do nothing here
                        if (!corepac_connected) {
                            alert("Sync Run configuration failed! Please connect the following cores first and then retry:\n" + unconn_cores);
                        } else {
                            //toggle the sync run status
                            _self.syncRun[_self.corepacSelected] = !_self.syncRun[_self.corepacSelected];
                            _self.syncRun_init();
                        }
                    }).catch(function(){
                        console.log("check_corepac_connected() failed");
                    }); 
                }
            },


            syncRunBtn_update: function() {
                var _self=this;
                var mybutton = document.querySelector('#syncRun_button');
                mybutton.raised = _self.syncRun[_self.corepacSelected];

                if (_self.syncRun[_self.corepacSelected]) {
                    _self.syncrun_title = _self._syncRun_title_disable;
                } else {
                    _self.syncrun_title = _self._syncRun_title_enable;
                }
            },

            rstBtn_update: function(){
                var _self=this;
                var mybutton = document.querySelector('#rstOnStart_button');
                    mybutton.raised = !_self.rstOnStart[_self.corepacSelected];

                    if (mybutton.raised) {
                         _self.rstbtn_title = _self._rstbtn_title_enable;
                        console.log("_self.rstOnStart is disabled");
                    } else {
                        _self.rstbtn_title = _self._rstbtn_title_disable;
                        console.log("_self.rstOnStart is enabled");
                    }

            },

            _tgtPreRun: function(x) {
                var _self = this;

                if (_self.syncRun[_self.corepacSelected]) {

                    var onStartFunc;
                    var start_job = false;
                    var ucInProg = false;

                    console.log("target " + x.target + " is about to run");

                    switch (_self.uc_val) {
                        case _self.uc1:
                            onStartFunc = _self._onStart_uc1.bind(this);
                            ucInProg = _self.uc1InProg;
                            break;
                        case _self.uc2:
                            onStartFunc = _self._onStart_uc2.bind(this);
                            ucInProg = _self.uc2InProg;
                            break;
                        case _self.uc3:
                            onStartFunc = _self._onStart_uc3.bind(this);
                            ucInProg = _self.uc3InProg;
                            break;
                        case _self.uc4:
                            onStartFunc = _self._onStart_uc4.bind(this);
                            ucInProg = _self.uc4InProg;
                            break;
                        default:
                            break;
                    }

                    for (var i = 0; i < _self.corepacInfo[_self.corepacSelected].num_cores; i++) {
                        if (x.target == _self.cpuFullNames[_self.corepacSelected][i]) {
                            _self.cpuExeStatus[_self.corepacSelected][i] = "running";
                            start_job = true;
                            break;
                        }
                    }
                    
                    /* Start the profiling job if it is not already in progress */
                    /* We will start the job as soon as we receive the PreRun notification from the first cpu */
                    if (start_job && !_self.jobInProg[_self.corepacSelected]) {
                        onStartFunc().then(function () {
                            return _self.ta.cloudTrace.preRunComplete();
                        }).then(function () {
                            console.log("preRunComplete() passed!");
                            if (_self.start_alert[_self.corepacSelected] != ""){
                                alert(_self.start_alert[_self.corepacSelected]);
                            }
                        }).catch(function (err) {
                            console.log(err.toString());
                        });
                    } else {
                        _self.ta.cloudTrace.preRunComplete().then(function () {
                            console.log("preRunComplete() passed!");
                            // If the usecase in progress is a different use case than the selected one, then don't start.
                            // For the same corepac, there can only be one use case running at a time
                            if ((_self.jobInProg[_self.corepacSelected]) && (!ucInProg))
                                alert("Automatic start of this use case failed since some other use case is still running on the selected CorePac!");
                        }).catch(function (err) {
                            console.log("preRunComplete() failed: " + err.toString());
                        });
                    }
                }
            },

            _tgtEvtCallback : function (info) {

                console.log("Event received: " + JSON.stringify(info));
                if (info.eventName === "Halt")
                {
                    return this._tgtHalted(info);                    
                } else if (info.eventName == "PreRun")
                {
                    return this._tgtPreRun(info);
                }
               
                return;
            },

            _tgtHalted: function(x) {
                var _self = this;
                var ucInProg = false;

            console.log("target " + x.target + " has halted");


            /* We will only respond if the Profiling job is in progress */
            if (_self.syncRun[_self.corepacSelected] && _self.jobInProg[_self.corepacSelected]) {
            var onStopFunc;
            switch (_self.uc_val) {
            case _self.uc1:
            onStopFunc = _self._onStop_uc1.bind(this);
            ucInProg = _self.uc1InProg;
            break;
            case _self.uc2:
            onStopFunc = _self._onStop_uc2.bind(this);
            ucInProg = _self.uc2InProg;
            break;
            case _self.uc3:
            onStopFunc = _self._onStop_uc3.bind(this);
            ucInProg = _self.uc3InProg;
            break;
            case _self.uc4:
            onStopFunc = _self._onStop_uc4.bind(this);
            ucInProg = _self.uc4InProg;
            break;
            default:
            break;
            }

            var stop_job = true;
			var i;


            for (i = 0; i < _self.corepacInfo[_self.corepacSelected].num_cores; i++) {
                        if (x.target == _self.cpuFullNames[_self.corepacSelected][i]) {
                            _self.cpuExeStatus[_self.corepacSelected][i] = "halted";
                            break;
                        }
            }

            /* Set stop_job to true only when all the cpus in the Corepac is halted */
            for (i = 0; i < _self.corepacInfo[_self.corepacSelected].num_cores; i++) {
                if (_self.cpuExeStatus[_self.corepacSelected][i] != "halted")
                    stop_job = false;
            }

            // Stop the job only if the selected use case is running
            if (stop_job && _self.jobInProg[_self.corepacSelected] && ucInProg)  {
                onStopFunc();
            }
        }
    },

            preRun_init:function() {
                var _self = this;
                var p = [];

                /* if sync box is checked, then enable the CCS PreRun event notification for the corresponding cpus in the selected CorePac. */
                /* if sync box is unchecked, then disable the CCS PreRun event notification for the corresponding cpus in the selected CorePac. */
                if (_self.syncRun[_self.corepacSelected]) {
                    return new Promise(function (resolve, reject) {
                        for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                                p[j] = _self.ta.cloudTrace.enableTargetPreRunEvent(_self.cpuFullNames[_self.corepacSelected][j]);
                        }
                        
                        Promise.all(p).then(function (retObj) {
                            console.log("Pre Run Event notification enable passed");
                            return resolve(retObj);
                        }).catch(function (err) {
                            return reject("Pre Run Event notification enable failed:" + err.toString());
                        });
                    });
                } else {

                    return new Promise(function (resolve, reject) {
                        for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                            p[j] = _self.ta.cloudTrace.disableTargetPreRunEvent(_self.cpuFullNames[_self.corepacSelected][j]);
                        }

                        Promise.all(p).then(function (retObj) {
                            console.log("Pre Run Event notification disable passed");
                            return resolve(retObj);
                        }).catch(function (err) {
                            return reject("Pre Run Event notification disable failed:" + err.toString());
                        });
                    });

                }
            },

            //////////////////////////////////////////////////////// JavaScript source code specific to usecase 1 /////////////////////////////////////////////////////////////


            /////////////////////////////////////////////////////////
            // initialization for usecase1
            /////////////////////////////////////////////////////////
            init_uc1 : function() {
                var _self = this;
                var data = ["","","","","",""];

                // table header
                _self.uc1_th0 = "Cache Name";
                _self.uc1_th1 = "Cache Hit Percentage";

                // Initialize L3 counter values 
                _self._l3_cnt_reset();

                // Initialize the table display
                _self.table_init_uc1(data);

            },

            table_init_uc1 : function(data) {
                var _self = this;
                var tableItems = [];
                var i = 0;

                if (_self.devId == _self.deviceID_k3m4)  { //Maxwell M4
                    //var obj = { "col1": "", "col2": "" };
                    //var cache_name;

                    for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                        var obj1 = { "col1": "", "col2": "" };
                        var obj2 = { "col1": "", "col2": "" };
                        obj1.col1 = _self.mycpuNames_uc1[_self.corepacSelected][j] + " L1 Instruction Cache";
                        obj1.col2 = data[i];
                        obj2.col1 = _self.mycpuNames_uc1[_self.corepacSelected][j] + " L1 Data Cache"
                        obj2.col2 = data[i+1];
                        tableItems.push(obj1);
                        tableItems.push(obj2);
                        i=i+2;
                    }
                    tableItems.push({ "col1": "L2 Data Cache", "col2": data[i] });
                    tableItems.push({ "col1": "L3 Cache", "col2": data[i+1] });
                    
                } else { // other device
                    //placeholder for now, TODO
                }

                // Update the table 
                _self.uc1_tableItems = JSON.parse(JSON.stringify(tableItems));


            },
            /////////////////////////////////////////////////////////
            // check_core_connected -- check if core is connected. if not, connect it
            /////////////////////////////////////////////////////////
            check_core_connected : function(core_number) {
                var _self = this;

                return new Promise(function (resolve, reject) {    

                    _self.ta.cloudTrace.isTargetConnected(_self.cpuFullNames[_self.corepacSelected][core_number]).then(function(retObj){
                            _self.core_connected[_self.corepacSelected][core_number] = retObj.connected;
                             return resolve(retObj);    
                    }).catch(function(err){
                            return reject(err); 
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // connect_core -- check if core is connected. if not, connect it
            /////////////////////////////////////////////////////////
                           
            connect_core : function(core_number) {
                var _self = this;

                      
                return new Promise(function (resolve, reject) {

                          // Check if the core is already connected
                          _self.ta.cloudTrace.isTargetConnected(_self.cpuFullNames[_self.corepacSelected][core_number]).then(function(retObj) {
                      
                              // Record the core connect status
                              _self.core_connected[_self.corepacSelected][core_number] = retObj.connected;
                      
                              // Connect core if not connected already
                              if (retObj.connected != true) {
                      
                                  // initCore() will cause CCS connect/disconnect on the specified cpu, will leave cpu in connected state from our perspective, not visible to user though
                                  _self.tm.initCore(_self.cpuFullNames[_self.corepacSelected][core_number]);
                      
                                  // Change status to connected
                                  _self.core_connected[_self.corepacSelected][core_number] = true;      
                              }
                      
                              console.log("Connect core passed: " + _self.cpuFullNames[_self.corepacSelected][core_number]);
                              return resolve("success");

                          }).catch(function(){
                                  var err = "Core connect failed: " + _self.cpuFullNames[_self.corepacSelected][core_number];
                                  alert(err);
                                  console.log(err);
                                  return reject(err);
                          }); 

/*                      
                     // Return right away if core is already connected   
                      
                     if (_self.core_connected[_self.corepacSelected][core_number] == true) {
                        return resolve("success");
                     } else {
                          // connect the core,
                          // initCore() will cause CCS connect/disconnect on the specified cpu, will leave cpu in connected state from our perspective, not visible to user though
                          _self.tm.initCore(_self.cpuFullNames[_self.corepacSelected][core_number]);
                          return resolve("success");
                  
                          .then(function(retObj) {
                              // Check if the core is now connected
                              //return _self.ta.cloudTrace.isTargetConnected(_self.cpuFullNames[_self.corepacSelected][core_number]);
                              return resolve("success");
                      
                          }).then(function(retObj) {
                              _self.core_connected[_self.corepacSelected][core_number] = retObj.connected;
                              // Return success if core is connected successfully, other return fail
                              if (retObj.connected == true) {
                                  console.log("Connect core passed: " + _self.cpuFullNames[_self.corepacSelected][core_number]);
                                  return resolve(retObj);
                              } else {
                                  alert("Core connect failed: " + _self.cpuFullNames[_self.corepacSelected][core_number]);
                                  console.log("Connect core failed: " + _self.cpuFullNames[_self.corepacSelected][core_number]);
                                  return reject("Core connect failed: " + _self.cpuFullNames[_self.corepacSelected][core_number]);
                              }
                          }).catch(function(err){
                                  alert("Core connect failed: " + _self.cpuFullNames[_self.corepacSelected][core_number]);
                                  console.log("Connect core failed: " + _self.cpuFullNames[_self.corepacSelected][core_number]);
                                  return reject(er);
                          }); 
                      
                      };
*/                      
                });
                      
            },
                      
            /////////////////////////////////////////////////////////
            // connect_corepac_cores -- check if all relevant cores are connected. if not, connect them
            /////////////////////////////////////////////////////////
            connect_corepac_cores : function() {
                var _self = this;
                var p = [];

                for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                    p[j] = _self.connect_core(j);
                }

                /* Wait for all the operations to finish */
                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // connect_msmc_ctset2 -- connect MSMC ctset2 core for usecase 1
            /////////////////////////////////////////////////////////
            connect_msmc_ctset2 : function() {
                var _self = this;
                var len = _self.cpuFullNames_uc1[_self.corepacSelected].length;
                var ctset2_name = _self.cpuFullNames_uc1[_self.corepacSelected][len-1];

                if (_self.msmc_ctset2_connected != true) {
                     _self.tm.initCore(ctset2_name);                  
                     _self.msmc_ctset2_connected = true;
                }
            },
                  
            /////////////////////////////////////////////////////////
            // check_corepac_connected -- check if all relevant cores are connected. if not, connect them
            /////////////////////////////////////////////////////////
            check_corepac_connected : function() {
                var _self = this;
                var p = [];

                for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                    p[j] = _self.check_core_connected(j);
                }

                /* Wait for all the operations to finish */
                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _onStart_uc1_hdlr -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc1_hdlr: function() {
                var _self=this;
                
                if (!_self.jobInProg[_self.corepacSelected]) {

                _self._onStart_uc1().then(function(){
                    console.log("_onStart_uc1_hdlr() passed");
                    if (_self.start_alert[_self.corepacSelected]!="")
                        alert(_self.start_alert[_self.corepacSelected]);
                }).catch(function(err){
                    console.log("_onStart_uc1_hdlr() failed:" + err.toString());
                });
                }
            },

            /////////////////////////////////////////////////////////
            // _onStart_uc1 
            /////////////////////////////////////////////////////////
            _onStart_uc1: function() {
                var _self = this;

                //var length = 0;
                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function(resolve, reject) {

                    // This use case cannot be started on either of the following conditions:
                    // 1) If other use case is in progress on the same corepac cores (meaning ARM PMU counters are not available)
                    // 2) If the same use case is in progress on the other corepac cores (meaning MSMC CTSET2 is not available)
                    if (_self.jobInProg[_self.corepacSelected] || _self.msmc_ctset2_inuse) {
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started due to one of the following reasons:\n" + 
                            "1) the other use case is in progress on the same CorePac cores \n" +
                            "2) the same use case is in progress on the other CorePac cores which uses the shared CTSET2 resource.";
                        return resolve("success");

                    } else {

                        //myStatusTxt = statusTxtAll[_self.corepacSelected];

                        //length = tableItemsAll[_self.corepacSelected].length;
                        
                        if (_self.rstOnStart[_self.corepacSelected]) {
                            var data = ["","","","","",""];

                            // Initialize L3 counter values 
                            _self._l3_cnt_reset();

                            // Update table display
                            _self.table_init_uc1(data);
                            _self.uc1_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                        }
    /*
                    _self.check_all_cores_connected(_self.cpuFullNames_uc1[_self.corepacSelected]).then(function(retObj) {
                        console.log("check_all_cores_connected() passed");
                        return _self._profile_start_uc1();
                    }).then(function (retObj) {                                         
    */                 
                    _self.connect_msmc_ctset2();
                    _self.connect_corepac_cores().then(function() {                  
                        console.log("connect_corepac_cores() passed");

                        // Set the flag to indicate job in progress
                        _self.jobInProg[_self.corepacSelected] = true;
                        _self.uc1InProg = true;
                        return _self._profile_start_uc1();

                        //_self._profile_start_uc1().then(function (retObj) {                        
                    }).then(function() {

                            console.log("_onStart_uc1() passed");


                            // Set the flag to indicate MSMC CTSET2 is in use
                            _self.msmc_ctset2_inuse = true;

                            // Disable the START button and enable the STOP button 
                            _self.update_start_stop_btn('#start_button_uc1',true,'#stop_button_uc1',false);
                            _self.uc1_startStatus[_self.corepacSelected] = true;
                            _self.uc1_stopStatus[_self.corepacSelected] = false;
                            return resolve("success");


                    }).catch(function (err) {
                            // Set the flag to indicate job failed
                            _self.jobInProg[_self.corepacSelected] = false;
                            _self.uc1InProg = false;

                            console.log(err.toString());
                            return reject(err);

                    });
                    }    
                });    
            },

            /////////////////////////////////////////////////////////
            // _profile_start_uc1
            /////////////////////////////////////////////////////////
            _profile_start_uc1 : function() {
                var _self = this;

                var p = [];
                //var warning = "";

                //_self.armPmuAetHndl = [];

                return new Promise(function (resolve, reject) {
                    p[0] = _self._profile_l1_start_uc1(); 
                    p[1] = _self._profile_l2_start_uc1();
                    p[2] = _self._profile_l3_start_uc1();

                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc1() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc1() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_start_uc1()
            //
            // Configure and enable all counters in CorePac needed for L1 cache benchmarking */
            /////////////////////////////////////////////////////////
            _profile_l1_start_uc1:function() {
                var _self = this;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_start(core_names[i], 0, "Level 1 instruction cache refill"); // L1 instruction cache miss count
                        p[j + 1] = _self._profile_arm_pmu_start(core_names[i], 1, "Level 1 instruction cache access"); // L1 instruction cache total count
                        p[j + 2] = _self._profile_arm_pmu_start(core_names[i], 2, "Level 1 data cache refill"); // L1 data cache miss count
                        p[j + 3] = _self._profile_arm_pmu_start(core_names[i], 3, "Level 1 data cache access"); // L1 data cache total count
                        j += 4;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /* placeholder for now */
                }

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l2_start_uc1()
            //
            // Configure and enable all counters in CorePac needed for L2 cache benchmarking */
            /////////////////////////////////////////////////////////
            _profile_l2_start_uc1 : function() {
                var _self = this;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    /* Configure PMU counters for L2 data cache benchmarking */
                    /* We use ARM core 0 PMU counters for this purpose */
                    p[0] = _self._profile_arm_pmu_start(core_names[0], 4, "Level 2 data cache refill"); // L2 data cache miss count
                    p[1] = _self._profile_arm_pmu_start(core_names[0], 5, "Level 2 data cache access"); // L2 data cache total count
                } else if (_self.corepacInfo[_self.corepacSelected].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _profile_l3_start_uc1()
            //
            // Configure and enable all MSMC CTSET2 counters needed for L3 cache benchmarking 
            /////////////////////////////////////////////////////////
            _profile_l3_start_uc1 : function() {
                var _self = this;

                var p_ctset2 = [];


                /* Config and start all the CTSET2 counters */
                p_ctset2[0] = _self._profile_msmc_ctset2_start(0, "SRAM Bank 0", "32 Bit", "Edge", "SRAM External Access Hit to Data Cache");
                p_ctset2[1] = _self._profile_msmc_ctset2_start(1, "SRAM Bank 1", "32 Bit", "Edge", "SRAM External Access Hit to Data Cache");
                p_ctset2[2] = _self._profile_msmc_ctset2_start(2, "SRAM Bank 2", "32 Bit", "Edge", "SRAM External Access Hit to Data Cache");
                p_ctset2[3] = _self._profile_msmc_ctset2_start(3, "SRAM Bank 3", "32 Bit", "Edge", "SRAM External Access Hit to Data Cache");
                p_ctset2[4] = _self._profile_msmc_ctset2_start(4, "SRAM Bank 0", "32 Bit", "Edge", "SRAM External Access Cacheable");
                p_ctset2[5] = _self._profile_msmc_ctset2_start(5, "SRAM Bank 1", "32 Bit", "Edge", "SRAM External Access Cacheable");
                p_ctset2[6] = _self._profile_msmc_ctset2_start(6, "SRAM Bank 2", "32 Bit", "Edge", "SRAM External Access Cacheable");
                p_ctset2[7] = _self._profile_msmc_ctset2_start(7, "SRAM Bank 3", "32 Bit", "Edge", "SRAM External Access Cacheable");


                /* Wait for all the CTSET2 start operations to finish */
                return Promise.all(p_ctset2);

            },

            /////////////////////////////////////////////////////////
            // _profile_msmc_ctset2_start()
            //
            // Configure and enable CTSET2 counter 
            /////////////////////////////////////////////////////////
            _profile_msmc_ctset2_start : function(cnt_id, sram_bank, cnt_size, evt_detect, evt_to_count) {
                var _self = this;

                //var data;
                //var length = 0;
                var aetopHandle;
                var i;
                var ctset2_prop_setval;
                var ctset2_prop_getval;
				var ctset2_name;

                /* Initialize the CTSET2 counter overflow alert text */
                _self.ctset2_alert = "";

                var str = _self.cpuFullNames_uc1[_self.corepacSelected];
                for (i = 0; i < _self.cpuFullNames_uc1[_self.corepacSelected].length; i++) {
                    if (str[i].indexOf("CTSET2_0") >= 0) {
                        ctset2_name = _self.cpuFullNames_uc1[_self.corepacSelected][i];
                        break;
                    }
                }

                return new Promise(function (resolve, reject) {
                    /* Create the AET operation server for CTSET2 */
                    _self.ta.cloudTrace.createOperation(ctset2_name, "AET").then(function (retObj) {
                        /* save the AET operation handle for later use */
                        aetopHandle = retObj.handle;
                        console.log("MSMC CTSET2 Counter " + cnt_id + " operation created: id = " + aetopHandle);
                        return retObj;
                    }).then(function () {
                        // Get the property tree for CTSET2 counter
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function(retObj) {
                        ctset2_prop_setval = retObj.cfg;
                        var ctset2_prop = ctset2_prop_setval[0]; 

                        // Modify the properties for CTSET2 counter
                        for (i=0; i < ctset2_prop.sub_properties.length; i++) {
                            if (ctset2_prop.sub_properties[i].name === "SRAM Bank") {
                                ctset2_prop.sub_properties[i].value = sram_bank;
                            } else if (ctset2_prop.sub_properties[i].name === "Counter Size") {
                                ctset2_prop.sub_properties[i].value = cnt_size;
                            } else if (ctset2_prop.sub_properties[i].name === "Event Detection Type") {
                                ctset2_prop.sub_properties[i].value = evt_detect;
                            } else if (ctset2_prop.sub_properties[i].name === "Event to Count") {
                                ctset2_prop.sub_properties[i].value = evt_to_count;
                            }
                        }
                        
                        // Set the MSMC ctset2 properties 
                        return _self.ta.cloudTrace.setProperties(aetopHandle, ctset2_prop_setval);
                    }).then(function () {
                        // Get the MSMC ctset2 properties again
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function(retObj) {
                        // Confirm the new ctset2 counter properties have been set correctly
                        ctset2_prop_getval = retObj.cfg;
                        if (JSON.stringify(ctset2_prop_getval) === JSON.stringify(ctset2_prop_setval)) {
                            console.log("setProperties() passed");
                            // Enable the AET operation for CTSET2 
                            return _self.ta.cloudTrace.setEnableOperation(aetopHandle, true);
                        }
                        else {
                            console.log("setProperties() failed");  
                            return reject("setProperties() failed");                          
                        }
                    }).then(function (retObj) {
                        console.log("MSMC CTSET2 Counter " + cnt_id + " operation enabled");
                        return retObj;
                    }).then(function (retObj) {
                        _self.ctset2AetHndl[cnt_id] = aetopHandle;
                        console.log("_profile_msmc_ctset2_start() passed: cnt_id = " + cnt_id);                       
                        return resolve(retObj);
                    }).catch(function (err) {
                        _self.ctset2AetHndl[cnt_id] = null;
                        return reject("_profile_msmc_ctset2_start() failed: cnt_id = " + cnt_id + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _onStop_uc1 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc1 : function() {
                var _self = this;

                var data = [];
                //var length = 0;
                //var cnt_id = 0;

                if (_self.jobInProg[_self.corepacSelected]) {
                          
                /* Mark the job as finished */
                _self.jobInProg[_self.corepacSelected] = false;
                _self.uc1InProg = false;
                          
                /* Stop the profiling function and fetch the counter values for table update */
                _self._profile_stop_uc1().then(function () {

                    /* Disable the STOP button and enable the START button */
                    _self.update_start_stop_btn('#start_button_uc1',false,'#stop_button_uc1',true);                    
                    _self.uc1_startStatus[_self.corepacSelected] = false;
                    _self.uc1_stopStatus[_self.corepacSelected] = true;
                    

                    /* Post Processing with returned counter data */
                    data = _self._post_process_uc1();

                    /* Update the table display with the new counter values */
                    _self.table_init_uc1(data);
                    _self.uc1_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));

                    /* Pop up a warning if there is any overflow in ARM PMU or CTSET2 counters */
                    if (_self.armPmu_alert)
                        alert(_self.armPmu_alert);
                    if (_self.ctset2_alert)
                        alert(_self.ctset2_alert);



                    // Set the flag to indicate MSMC CTSET2 is not in use
                    _self.msmc_ctset2_inuse = false;

                    console.log("_onStop_uc1() passed");

                }).catch(function (err) {
                    /* Mark the job as not finished */
                    _self.jobInProg[_self.corepacSelected] = true;
                    _self.uc1InProg = true;
                          
                          
                    console.log("_onStop_uc1() failed: " + err.toString());

                });
                          
                }
            },

            /////////////////////////////////////////////////////////
            // _profile_stop_uc1() 
            /////////////////////////////////////////////////////////
            _profile_stop_uc1 : function() {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1_stop_uc1();
                p[1] = _self._profile_l2_stop_uc1();
                p[2] = _self._profile_l3_stop_uc1();

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_stop_uc1() 
            /////////////////////////////////////////////////////////
            _profile_l1_stop_uc1: function() {
                var _self = this;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_stop(core_names[i], 0); // L1 instruction cache miss count
                        p[j + 1] = _self._profile_arm_pmu_stop(core_names[i], 1); // L1 instruction cache total count
                        p[j + 2] = _self._profile_arm_pmu_stop(core_names[i], 2); // L1 data cache miss count
                        p[j + 3] = _self._profile_arm_pmu_stop(core_names[i], 3); // L1 data cache total count
                        j += 4;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l2_stop_uc1() 
            /////////////////////////////////////////////////////////
            _profile_l2_stop_uc1 : function() {
                var _self = this;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    /* We use ARM core 0 PMU counters for this purpose */
                    p[0] = _self._profile_arm_pmu_stop(core_names[0], 4); // L2 data cache miss count
                    p[1] = _self._profile_arm_pmu_stop(core_names[0], 5); // L2 data cache total count
                } else if (_self.corepacInfo[_self.corepacSelected].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _profile_l3_stop_uc1() 
            // Stop all the CTSET2 counters for L3 cache benchmarking 
            /////////////////////////////////////////////////////////
            _profile_l3_stop_uc1 : function() {
                var _self = this;

                var p_ctset2 = [];

                /* Stop all the CTSET2 counters */
                for (var i = 0; i < _self.num_ctset2_cnt; i++) {
                    p_ctset2[i] = _self._profile_msmc_ctset2_stop(i);
                }

                /* Wait for all the counter stop operations to finish */
                return Promise.all(p_ctset2);
            },


            /////////////////////////////////////////////////////////
            // _post_process_uc1() 
            /////////////////////////////////////////////////////////
            _post_process_uc1 : function() {
                var _self = this;

                var l1_data = [];
                var l2_data;
                var l3_data;
                var data = [];

                l1_data = _self._post_process_l1_uc1();
                l2_data = _self._post_process_l2_uc1();
                l3_data = _self._post_process_l3_uc1();

                /* Combine all the data and return */
                data = l1_data.concat(l2_data).concat(l3_data);

                return data;
            },

            /////////////////////////////////////////////////////////
            // _post_process_l1_uc1() 
            /////////////////////////////////////////////////////////
            _post_process_l1_uc1 : function() {
                var _self = this;

                var data = [];
                var l1p_miss = [];
                var l1p_total = [];
                var l1d_miss = [];
                var l1d_total = [];
                var j = 0;

                var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];

                for (var i = 0; i < num_cores; i++) {
                    var obj;

                    /* Get L1P miss count */
                    obj = _self._get_arm_counter(core_names[i], 0);
                    if (obj.found) {
                        l1p_miss[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1P Miss has overflowed;\n";
                        }
                    }

                    /* Get L1P total count */
                    obj = _self._get_arm_counter(core_names[i], 1);
                    if (obj.found) {
                        l1p_total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1P Total has overflowed;\n";
                        }
                    }

                    /* Get L1D miss count */
                    obj = _self._get_arm_counter(core_names[i], 2);
                    if (obj.found) {
                        l1d_miss[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1D Miss has overflowed;\n";
                        }
                    }

                    /* Get L1D total count */
                    obj = _self._get_arm_counter(core_names[i], 3);
                    if (obj.found) {
                        l1d_total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1D Total has overflowed;\n";
                        }
                    }

                    /* Core #i L1P hit percentage */
					if (l1p_total[i] == 0){
						data[j] = "No Cache Activity";
					} else {
						data[j] = ((l1p_total[i] - l1p_miss[i]) * 100 / l1p_total[i]).toFixed(2) + "%";
					}
					
					
                    /* Core #i L1D hit percentage */
					if (l1d_total[i] == 0){
						data[j+1] = "No Cache Activity";
					} else {
						data[j + 1] = ((l1d_total[i] - l1d_miss[i]) * 100 / l1d_total[i]).toFixed(2) + "%";
					}
					
                    j += 2;
                }

                return data;


            },

            /////////////////////////////////////////////////////////
            // _post_process_l2_uc1() 
            /////////////////////////////////////////////////////////
            _post_process_l2_uc1 : function() {
                var _self = this;

                var data;
                var l2d_miss;
                var l2d_total;
                var obj;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];

                /* Get L2D miss count */
                obj = _self._get_arm_counter(core_names[0], 4);
                if (obj.found) {
                    l2d_miss = obj.cntval;
                    if (obj.ovfl == "TRUE") {
                        _self.armPmu_alert += "Counter used for L2D Miss has overflowed;\n";
                    }
                }

                /* Get L2D total count */
                obj = _self._get_arm_counter(core_names[0], 5);
                if (obj.found) {
                    l2d_total = obj.cntval;
                    if (obj.ovfl == "TRUE") {
                        _self.armPmu_alert += "Counter used for L2D Total has overflowed;\n";
                    }
                }

                /* Shared L2D hit percentage */
				if (l2d_total == 0){
						data = "No Cache Activity";
				} else {
						data = ((l2d_total - l2d_miss) * 100 / l2d_total).toFixed(2) + "%";
				}
				
                return data;
            },


            /////////////////////////////////////////////////////////
            // _post_process_l3_uc1() 
            // Post Processing for ctset2 
            /////////////////////////////////////////////////////////
            _post_process_l3_uc1 : function() {
                var _self = this;

                var data = "0%";
                var cacheHitCnt;
                var cacheableCnt;


                /* Update the data for CTSET2 */
                cacheHitCnt = _self.ctset2Cnt[0] + _self.ctset2Cnt[1] + _self.ctset2Cnt[2] + _self.ctset2Cnt[3];
                cacheableCnt = _self.ctset2Cnt[4] + _self.ctset2Cnt[5] + _self.ctset2Cnt[6] + _self.ctset2Cnt[7];
				
				if (cacheableCnt == 0) {
					data = "No Cache Activity";				
				} else {				
					data = (cacheHitCnt * 100 / cacheableCnt).toFixed(2) + "%";
				}
				
                /* Update the overflow status for CTSET2*/
                for (var i = 0; i < _self.ctset2Cnt.length; i++) {
                    if (_self.ctset2Ovfl[i] == "overflowed") {
                        _self.ctset2_alert += "CTSET2 Counter " + i + " used for L3 Cache benchmarking has overflowed;\n";
                    }
                }

                return data;
            },
            //////////////////////////////////////////////////////// JavaScript source code specific to usecase 2 /////////////////////////////////////////////////////////////


            /////////////////////////////////////////////////////////
            // initialization for usecase2
            /////////////////////////////////////////////////////////
            init_uc2 : function() {
                var _self = this;
                var data = ["",""];

                // table header
                _self.uc2_th0 = "CPU Name";
                _self.uc2_th1 = "Cacheable Data Percentage";

                // Initialize the table display
                _self.table_init_uc2(data);
            },


            table_init_uc2 : function(data) {
                var _self = this;
                var tableItems = [];
				var obj;

                if (_self.devId == _self.deviceID_k3m4)  { //Maxwell M4
                    //var cache_name;

                    for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                        obj = { "col1": "", "col2": "" };
                        obj.col1 = _self.mycpuNames[_self.corepacSelected][j];
                        obj.col2 = data[j];
                        tableItems.push(obj);
                    }                    
                } else { // other device
                    obj = { "col1": "", "col2": "" };
                    tableItems.push(obj);
                    tableItems.push(obj);
                }

                /* Update the table */
                _self.uc2_tableItems = JSON.parse(JSON.stringify(tableItems));
            },

            /////////////////////////////////////////////////////////
            // _onStart_uc2_hdlr -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc2_hdlr: function() {
                var _self=this;
                if (!_self.jobInProg[_self.corepacSelected]) {
                      
                _self._onStart_uc2().then(function(){
                    console.log("_onStart_uc2_hdlr() passed");
                    if (_self.start_alert[_self.corepacSelected]!="")
                        alert(_self.start_alert[_self.corepacSelected]);
                }).catch(function(err){
                    console.log("_onStart_uc2_hdlr() failed:" + err.toString());
                });
                 
                }
            },

            /////////////////////////////////////////////////////////
            // _onStart_uc2 -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc2 : function() {
                var _self = this;
                //var length = 0;
                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function(resolve, reject) {

                    if (_self.jobInProg[_self.corepacSelected]) {
                         _self.start_alert[_self.corepacSelected]="Some other use case is running on the selected core, please wait for it to complete before starting this use case!";
                         return resolve("success");
                   } else {


                    if (_self.rstOnStart[_self.corepacSelected]) {
                        var data = ["",""];

                        // Update table display
                        _self.table_init_uc2(data);
                        _self.uc2_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                    }
    
                    //myStatusTxt = statusTxtAll[_self.corepacSelected];

                    //length = tableItemsAll[_self.corepacSelected].length;

    /*
                    _self.check_all_cores_connected(_self.cpuFullNames[_self.corepacSelected]).then(function(retObj) {
                        console.log("check_all_cores_connected() passed");
                        // Now program the job
                        return _self._profile_start_uc2();
                    }).then(function (retObj) {                        
    */              
                      
                    // Set the flag to indicate job in progress
                    _self.jobInProg[_self.corepacSelected] = true;
                    _self.uc2InProg = true;
                      
                    _self._profile_start_uc2().then(function(){
                            console.log("_onStart_uc2() passed");

                            // Disable the START button and enable the STOP button 
                            _self.update_start_stop_btn('#start_button_uc2',true,'#stop_button_uc2',false);
                            _self.uc2_startStatus[_self.corepacSelected] = true;
                            _self.uc2_stopStatus[_self.corepacSelected] = false;
                            return resolve("success");
                            
                        }).catch(function (err) {
                      
                            // Set the flag to indicate job not in progress
                            _self.jobInProg[_self.corepacSelected] = false;
                            _self.uc2InProg = false;
                      
                            console.log(err.toString());
                            return reject(err);
                        });
        
                    }
                });
            },


            /////////////////////////////////////////////////////////
            // _profile_start_uc2
            /////////////////////////////////////////////////////////
            _profile_start_uc2 : function() {
                var _self = this;

                var p = [];
                //var warning = "";

                //_self.armPmuAetHndl = [];

                return new Promise(function (resolve, reject) {
                    p[0] = _self._profile_l1_start_uc2();

                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc2() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc2() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_start_uc2()
            //
            // Configure and enable all counters in CorePac needed for L1 cache benchmarking 
            /////////////////////////////////////////////////////////
            _profile_l1_start_uc2 : function() {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_start(core_names[i], 0, "Level 1 data cache access"); // this is the count for cacheable access
                        p[j + 1] = _self._profile_arm_pmu_start(core_names[i], 1, "Data memory access");//this is the total access count
                        j += 2;

                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _onStop_uc2 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc2 : function() {
                var _self = this;

                var data = [];
                //var length = 0;
                //var cnt_id = 0;

                if (_self.jobInProg[_self.corepacSelected]) {
                          
                /* Mark the job as finished */
                _self.jobInProg[_self.corepacSelected] = false;
                _self.uc2InProg = false;
                      
                /* Stop the profiling function and fetch the counter values for table update */
                _self._profile_stop_uc2().then(function () {

                    /* Disable the STOP button and enable the START button */
                    _self.update_start_stop_btn('#start_button_uc2',false, '#stop_button_uc2', true);
                    _self.uc2_startStatus[_self.corepacSelected] = false;
                    _self.uc2_stopStatus[_self.corepacSelected] = true;

                    /* Post Processing with returned counter data */
                    data = _self._post_process_uc2();

                    /* Update the table display with the new counter values */
                    _self.table_init_uc2(data);
                    _self.uc2_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));


                    /* Pop up a warning if there is any overflow in ARM PMU counters */
                    if (_self.armPmu_alert)
                        alert(_self.armPmu_alert);

                    console.log("_onStop_uc2() passed");

                }).catch(function (err) {
                    /* Mark the job as not finished */
                    _self.jobInProg[_self.corepacSelected] = true;
                    _self.uc2InProg = true;
                      
                    console.log("_onStop_uc2() failed: " + err.toString());

                 });
               }
            },
            


            /////////////////////////////////////////////////////////
            // _profile_stop_uc2() 
            /////////////////////////////////////////////////////////
            _profile_stop_uc2 : function() {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1_stop_uc2();

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_stop_uc2() 
            /////////////////////////////////////////////////////////
            _profile_l1_stop_uc2 : function() {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        p[j] = _self._profile_arm_pmu_stop(core_names[i], 0); // this is the count for cacheable access
                        p[j + 1] = _self._profile_arm_pmu_stop(core_names[i], 1); // this is the total access count
                        j += 2;

                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _post_process_uc2() 
            /////////////////////////////////////////////////////////
            _post_process_uc2 : function() {
                var _self = this;

                var l1_data = [];

                l1_data = _self._post_process_l1_uc2();

                return l1_data;
            },

            /////////////////////////////////////////////////////////
            // _post_process_l1_uc2() 
            /////////////////////////////////////////////////////////
            _post_process_l1_uc2 :function() {
                var _self = this;

                var data = [];
                var l1d_cacheable = [];
                var total = [];

                var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                var core_names = _self.cpuFullNames[_self.corepacSelected];

                for (var i = 0; i < num_cores; i++) {
                    var obj;

                    /* Get L1D cacheable access count */
                    obj = _self._get_arm_counter(core_names[i], 0);
                    if (obj.found) {
                        l1d_cacheable[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1D Cacheable access has overflowed;\n";
                        }
                    }

                    /* Get Total Access count */
                    obj = _self._get_arm_counter(core_names[i], 1);
                    if (obj.found) {
                        total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for Total Access has overflowed;\n";
                        }
                    }

                    /* Core #i L1D Cacheable Percentage */
					if (total[i] == 0){
						data[i] = "No Cache Activity";
					} else {
						data[i] = (l1d_cacheable[i] * 100 / total[i]).toFixed(2) + "%";
					}
                }

                return data;
            },

            //////////////////////////////////////////////////////// JavaScript source code specific to usecase 3 /////////////////////////////////////////////////////////////

 
            /////////////////////////////////////////////////////////
            // initialization for usecase3
            /////////////////////////////////////////////////////////
            init_uc3 : function() {
                var _self = this;
                var data = ["","","",""];

                // table header
                _self.uc3_th0 = "CPU Name";
                _self.uc3_th1 = "MMU TLB Hit Percentage";

                // Initialize the table display
                _self.table_init_uc3(data);

             },

            table_init_uc3 : function(data) {
                var _self = this;
                var tableItems = [];
                var i = 0;

                if (_self.devId == _self.deviceID_k3m4)  { //Maxwell M4
                    for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                        var obj1 = { "col1": "", "col2": "" };
                        var obj2 = { "col1": "", "col2": "" };
                        obj1.col1 = _self.mycpuNames[_self.corepacSelected][j] + " L1 Instruction Cache";
                        obj1.col2 = data[i];
                        obj2.col1 = _self.mycpuNames[_self.corepacSelected][j] + " L1 Data Cache"
                        obj2.col2 = data[i+1];
                        tableItems.push(obj1);
                        tableItems.push(obj2);
                        i=i+2;
                    }
                    
                } else { // other device
                    //placeholder for now, TODO
                }

                // Update the table 
                _self.uc3_tableItems = JSON.parse(JSON.stringify(tableItems));

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc3_hdlr -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc3_hdlr: function() {
                var _self=this;
                      
                if (!_self.jobInProg[_self.corepacSelected]) {
                      
                _self._onStart_uc3().then(function(){
                    console.log("_onStart_uc3_hdlr() passed");
                    if (_self.start_alert[_self.corepacSelected]!="")
                        alert(_self.start_alert[_self.corepacSelected]);
                }).catch(function(err){
                    console.log("_onStart_uc3_hdlr() failed:" + err.toString());
                });
                  
               }
            },
            /////////////////////////////////////////////////////////
            // _onStart_uc3 
            /////////////////////////////////////////////////////////
            _onStart_uc3 : function() {
                var _self = this;
                //var length = 0;
                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function(resolve, reject) {

                    if (_self.jobInProg[_self.corepacSelected]) {
                        _self.start_alert[_self.corepacSelected]="Some other use case is running on the selected core, please wait for it to complete before starting this use case!";
                        return resolve("success");
                    } else {


                    if (_self.rstOnStart[_self.corepacSelected]) {
                        var data = ["","", "", ""];

                        // Update table display
                        _self.table_init_uc3(data);
                        _self.uc3_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));                    
                    }
    /*
                    _self.check_all_cores_connected(_self.cpuFullNames[_self.corepacSelected]).then(function(retObj) {
                        console.log("check_all_cores_connected() passed");
                        // Now program the job
                        return _self._profile_start_uc3();
                    }).then(function (retObj) {    
    */
                    // Set the flag to indicate job in progress
                    _self.jobInProg[_self.corepacSelected] = true;
                    _self.uc3InProg = true;
                      
                    _self._profile_start_uc3().then(function(){
                                            
                            console.log("_onStart_uc3() passed");

                            // Disable the START button and enable the STOP button 
                            _self.update_start_stop_btn('#start_button_uc3',true,'#stop_button_uc3',false);
                            _self.uc3_startStatus[_self.corepacSelected] = true;
                            _self.uc3_stopStatus[_self.corepacSelected] = false;
                            return resolve("success");

                        }).catch(function (err) {
                      
                            // Set the flag to indicate job not in progress
                            _self.jobInProg[_self.corepacSelected] = false;
                            _self.uc3InProg = false;
                      
                            console.log("_onStart_uc3() failed: " + err.toString());
                            return reject(err);
                        });
                    }
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_start_uc3
            /////////////////////////////////////////////////////////
            _profile_start_uc3 : function() {
                var _self = this;

                var p = [];
                //var warning = "";

                //_self.armPmuAetHndl = [];

                return new Promise(function (resolve, reject) {
                    p[0] = _self._profile_l1_start_uc3();

                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc3() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc3() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_start_uc3()
            //
            // Configure and enable all counters in CorePac needed for L1 cache benchmarking 
            /////////////////////////////////////////////////////////
            _profile_l1_start_uc3 : function() {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache TLB hit/miss */
                        p[j] = _self._profile_arm_pmu_start(core_names[i], 0, "Level 1 instruction TLB refill"); // L1 instruction TLB miss count
                        p[j + 1] = _self._profile_arm_pmu_start(core_names[i], 1, "Level 1 instruction cache access"); // L1 instruction cache total count
                        p[j + 2] = _self._profile_arm_pmu_start(core_names[i], 2, "Level 1 data TLB refill"); // L1 data TLB miss count
                        p[j + 3] = _self._profile_arm_pmu_start(core_names[i], 3, "Bus access"); // data total access
                        j += 4;

                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _onStop_uc3 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc3 : function() {
                var _self = this;

                var data = [];
                //var length = 0;
                //var cnt_id = 0;

                if (_self.jobInProg[_self.corepacSelected]) {
                          
                /* Mark the job as finished */
                _self.jobInProg[_self.corepacSelected] = false;
                _self.uc3InProg = false;
                      
                /* Stop the profiling function and fetch the counter values for table update */
                _self._profile_stop_uc3().then(function () {


                    /* Disable the STOP button and enable the START button */
                    _self.update_start_stop_btn('#start_button_uc3',false, '#stop_button_uc3', true);
                    _self.uc3_startStatus[_self.corepacSelected] = false;
                    _self.uc3_stopStatus[_self.corepacSelected] = true;

                    /* Post Processing with returned counter data */
                    data = _self._post_process_uc3();

                     /* Update the table display with the new counter values */
                     _self.table_init_uc3(data);
                     _self.uc3_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));

                    /* Pop up a warning if there is any overflow in ARM PMU counters */
                    if (_self.armPmu_alert)
                        alert(_self.armPmu_alert);


                    console.log("_onStop_uc3() passed");

                }).catch(function (err) {
                    /* Mark the job as not finished */
                    _self.jobInProg[_self.corepacSelected] = true;
                    _self.uc3InProg = true;

                    console.log("_onStop_uc3() failed: " + err.toString());

               });
               }
            },


            /////////////////////////////////////////////////////////
            // _profile_stop_uc3() 
            /////////////////////////////////////////////////////////
            _profile_stop_uc3 : function() {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1_stop_uc3();

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_stop_uc3() 
            /////////////////////////////////////////////////////////
            _profile_l1_stop_uc3 : function() {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_stop(core_names[i], 0); // L1 instruction TLB miss count
                        p[j + 1] = _self._profile_arm_pmu_stop(core_names[i], 1); // L1 instruction cache total count
                        p[j + 2] = _self._profile_arm_pmu_stop(core_names[i], 2); // L1 data TLB miss count
                        p[j + 3] = _self._profile_arm_pmu_stop(core_names[i], 3); // data total count
                        j += 4;

                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _post_process_uc3() 
            /////////////////////////////////////////////////////////
            _post_process_uc3: function() {
                var _self = this;

                var l1_data = [];

                l1_data = _self._post_process_l1_uc3();

                return l1_data;
            },

            /////////////////////////////////////////////////////////
            // _post_process_l1_uc3() 
            /////////////////////////////////////////////////////////
            _post_process_l1_uc3 : function() {
                var _self = this;

                var data = [];
                var l1p_total = [];
                var l1p_tlb_miss = [];
                var l1d_total = [];
                var l1d_tlb_miss = [];
                var j = 0;

                var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                var core_names = _self.cpuFullNames[_self.corepacSelected];

                for (var i = 0; i < num_cores; i++) {
                    var obj;

                    /* Get L1 instruction TLB miss count */
                    obj = _self._get_arm_counter(core_names[i], 0);
                    if (obj.found) {
                        l1p_tlb_miss[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1 instruction TLB miss has overflowed;\n";
                        }
                    }

                    /* Get L1 instruction Total Access count */
                    obj = _self._get_arm_counter(core_names[i], 1);
                    if (obj.found) {
                        l1p_total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1 instruction cache total access has overflowed;\n";
                        }
                    }

                    /* Get L1 data TLB miss count */
                    obj = _self._get_arm_counter(core_names[i], 2);
                    if (obj.found) {
                        l1d_tlb_miss[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1 data TLB miss has overflowed;\n";
                        }
                    }

                    /* Get Data Total Access count */
                    obj = _self._get_arm_counter(core_names[i], 3);
                    if (obj.found) {
                        l1d_total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for data access total has overflowed;\n";
                        }
                    }

                    /* Core #i L1 instruction TLB hit percentage */
					if (l1p_total[i] == 0) {
						data[j] = "No Cache Activity";
					} else {
						data[j] = ((l1p_total[i] - l1p_tlb_miss[i]) * 100 / l1p_total[i]).toFixed(2) + "%";
					}
					
                    /* Core #i L1 data TLB hit percentage */
					if (l1d_total[i] == 0) {
						data[j + 1] = "No Cache Activity";
					} else {
						data[j + 1] = ((l1d_total[i] - l1d_tlb_miss[i]) * 100 / l1d_total[i]).toFixed(2) + "%";
					}
					
                    j += 2;

                }

                return data;

            },

            //////////////////////////////////////////////////////// JavaScript source code specific to usecase 4 /////////////////////////////////////////////////////////////


            /////////////////////////////////////////////////////////
            // initialization for usecase4
            /////////////////////////////////////////////////////////
            init_uc4 : function() {
                var _self = this;
                var data = ["",""];

                // table header
                _self.uc4_th0 = "CPU Name";
                _self.uc4_th1 = "CPU Performance Benchmark (Instruction/Cycle)";

                 // Initialize the table display
                _self.table_init_uc4(data);

            },


            table_init_uc4 : function(data) {
                var _self = this;
                var tableItems = [];
				var obj;

                if (_self.devId == _self.deviceID_k3m4)  { //Maxwell M4
                    //var cache_name;

                    for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                        obj = { "col1": "", "col2": "" };
                        obj.col1 = _self.mycpuNames[_self.corepacSelected][j];
                        obj.col2 = data[j];
                        tableItems.push(obj);
                    }                    
                } else { // other device
                    obj = { "col1": "", "col2": "" };
                    tableItems.push(obj);
                    tableItems.push(obj);
                }

                /* Update the table */
                _self.uc4_tableItems = JSON.parse(JSON.stringify(tableItems));

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc4_hdlr -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc4_hdlr: function() {
                var _self=this;
                      
                if (!_self.jobInProg[_self.corepacSelected]) {
                      
                _self._onStart_uc4().then(function(){
                    console.log("_onStart_uc4_hdlr() passed");
                    if (_self.start_alert[_self.corepacSelected]!="")
                        alert(_self.start_alert[_self.corepacSelected]);
                }).catch(function(err){
                    console.log("_onStart_uc4_hdlr() failed:" + err.toString());
                });
              
                }
            },

            /////////////////////////////////////////////////////////
            // _onStart_uc4 
            /////////////////////////////////////////////////////////
            _onStart_uc4 : function() {
                var _self = this;
                //var length = 0;
                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function(resolve, reject) {

                    if (_self.jobInProg[_self.corepacSelected]) {
                        _self.start_alert[_self.corepacSelected]="Some other use case is running on the selected core, please wait for it to complete before starting this use case!";
                        return resolve("success");
                    } else {


                    if (_self.rstOnStart[_self.corepacSelected]) {
                        var data = ["",""];

                        // Update table display
                        _self.table_init_uc4(data);
                        _self.uc4_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                    }

    /*
                    _self.check_all_cores_connected(_self.cpuFullNames[_self.corepacSelected]).then(function(retObj) {
                        console.log("check_all_cores_connected() passed");
                        // Now program the job
                        return _self._profile_start_uc4();
                    }).then(function (retObj) { 
    */
                    // Set the flag to indicate job in progress
                    _self.jobInProg[_self.corepacSelected] = true;
                    _self.uc4InProg = true;
                      
                    _self._profile_start_uc4().then(function(){
                                            
                            console.log("_onStart_uc4() passed");

                            // Disable the START button and enable the STOP button 
                            _self.update_start_stop_btn('#start_button_uc4',true,'#stop_button_uc4',false);
                            _self.uc4_startStatus[_self.corepacSelected] = true;
                            _self.uc4_stopStatus[_self.corepacSelected] = false;
                            return resolve("success");
                        }).catch(function (err) {
                      
                            // Set the flag to indicate job not in progress
                            _self.jobInProg[_self.corepacSelected] = false;
                            _self.uc4InProg = false;
                      
                            console.log("_onStart_uc4() failed: " + err.toString());
                            return reject(err);
                        });
                    }
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_start_uc4
            /////////////////////////////////////////////////////////
            _profile_start_uc4 : function() {
                var _self = this;

                var p = [];
                //var warning = "";

                //_self.armPmuAetHndl = [];

                return new Promise(function (resolve, reject) {
                    p[0] = _self._profile_l1_start_uc4();

                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc4() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc4() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_start_uc4()
            //
            // Configure and enable all counters in CorePac needed for L1 cache benchmarking 
            /////////////////////////////////////////////////////////
            _profile_l1_start_uc4 : function() {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core instruction count and cycle count */
                        p[j] = _self._profile_arm_pmu_start(core_names[i], 0, "Instruction architecturally executed"); // this is the count for cacheable access
                        p[j + 1] = _self._profile_arm_pmu_start(core_names[i], 1, "Cycle"); // this is the cycle count
                        j += 2;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _onStop_uc4 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc4 : function() {
                var _self = this;

                var data = [];
                //var length = 0;
                //var cnt_id = 0;

                if (_self.jobInProg[_self.corepacSelected]) {
                          
                /* Mark the job as finished */
                _self.jobInProg[_self.corepacSelected] = false;
                _self.uc4InProg = false;
                      
                /* Stop the profiling function and fetch the counter values for table update */
                _self._profile_stop_uc4().then(function () {

                    /* Disable the STOP button and enable the START button */
                    _self.update_start_stop_btn('#start_button_uc4',false, '#stop_button_uc4', true);
                    _self.uc4_startStatus[_self.corepacSelected] = false;
                    _self.uc4_stopStatus[_self.corepacSelected] = true;

                    /* Post Processing with returned counter data */
                    data = _self._post_process_uc4();

                    /* Update the table display with the new counter values */
                    _self.table_init_uc4(data);
                    _self.uc4_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));

                    /* Pop up a warning if there is any overflow in ARM PMU counters */
                    if (_self.armPmu_alert)
                        alert(_self.armPmu_alert);

                    console.log("_onStop_uc4() passed");

                }).catch(function (err) {
                    /* Mark the job as not finished */
                    _self.jobInProg[_self.corepacSelected] = true;
                    _self.uc4InProg = true;
                                         
                    console.log("_onStop_uc4() failed: " + err.toString());

                });
               }
            },


            /////////////////////////////////////////////////////////
            // _profile_stop_uc4() 
            /////////////////////////////////////////////////////////
            _profile_stop_uc4 : function() {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1_stop_uc4();

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_stop_uc4() 
            /////////////////////////////////////////////////////////
            _profile_l1_stop_uc4 : function() {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if ((_self.corepacInfo[_self.corepacSelected].type == "a53") || (_self.corepacInfo[_self.corepacSelected].type == "a72")) { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_stop(core_names[i], 0); // this is the instruction count 
                        p[j + 1] = _self._profile_arm_pmu_stop(core_names[i], 1); // this is the cycle count
                        j += 2;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _post_process_uc4() 
            /////////////////////////////////////////////////////////
            _post_process_uc4 : function() {
                var _self = this;

                var data = [];
                var inst_cnt = [];
                var cycle_cnt = [];

                var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                var core_names = _self.cpuFullNames[_self.corepacSelected];

                for (var i = 0; i < num_cores; i++) {
                    var obj;

                    /* Get the instruction count */
                    obj = _self._get_arm_counter(core_names[i], 0);
                    if (obj.found) {
                        inst_cnt[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for Instruction count has overflowed;\n";
                        }
                    }

                    /* Get cycle count */
                    obj = _self._get_arm_counter(core_names[i], 1);
                    if (obj.found) {
                        cycle_cnt[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for Cycle count has overflowed;\n";
                        }
                    }

                    /* Core #i Instruction Per Cycle */
					if (cycle_cnt[i] == 0) {
						data[i] = "No data (Check if CPU is running)";
					} else {
						data[i] = (inst_cnt[i] / cycle_cnt[i]).toFixed(2);
					}
                }

                return data;

            },            
        });            
        </script>
    </dom-module>
 </body>
</html>