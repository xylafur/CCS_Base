/* M4_OBSCLK.GEL */

//TODO: Test these functions once pinmuxing is set up.

#define CSL_MAIN_CTRL_MMR_CFG0_OBSCLK_CTRL                         (0x00008000U)
#define CSL_WKUP_CTRL_MMR_CFG0_MCU_OBSCLK_CTRL                     (0x00008000U)

menuitem "Observation Clock"
dialog Configure_OBSCLK(unsigned int Clock_mux_index "Observation Clock Multiplexer Index (which input do you want?):", unsigned int divider_value "Output Divider Value (+1 factored in already): "){
	//Internal variables
	unsigned int temp_val;
	unsigned int temp_val2;
	unsigned int temp_val3;
	unsigned int reg_val;
	unsigned int LOAD;
	unsigned int address_offset;

	//Initialization of internal variables
	temp_val = 0; 
	temp_val2 = 0;
	temp_val3 = 0;
	reg_val = 0;
	LOAD = 0x10000; //Bit 16 is the load bit.
	//address_offset = 0x80000000; //This is the address offset of any peripherals in the main domain.

	//If this statement is true we're running from the CM3 DMSC.
	//Make sure to account for the address offset.
	if (*((unsigned int*)WAKEUP_PSC_BASE) != PSC_PID)
    {
        address_offset = 0x80000000;
    } //Main Control MMRs use the offset of 0x8000_0000.

	//Error checking against user input. This should be taken care of anyhow.
	if(divider_value > 0xFF){
		GEL_TextOut("********ERROR: Divider Value is too large.\n");
		return;
	}
	if(Clock_mux_index >= 16){
		GEL_TextOut("********ERROR: Invalid observation clock multiplexer selection.\n");
		return;
	}

	//Unlock Main CTRL MMR Partition 2
	Write_MMR(CSL_MAIN_CTRL_MMR0_CFG0_BASE + CSL_MAIN_CTRL_MMR_CFG0_LOCK2_KICK0 + address_offset, KICK0_UNLOCK_VAL);
	Write_MMR(CSL_MAIN_CTRL_MMR0_CFG0_BASE + CSL_MAIN_CTRL_MMR_CFG0_LOCK2_KICK1 + address_offset, KICK1_UNLOCK_VAL);

	//Read the MMR
	temp_val = Read_MMR(CSL_MAIN_CTRL_MMR0_CFG0_BASE + CSL_MAIN_CTRL_MMR_CFG0_OBSCLK_CTRL + address_offset);
	GEL_TextOut("OBSCLK control MMR value: %x\n",,,,, temp_val); //just for debugging

	//Write to the actual obsclk the actual obsclk value.
	//First, pack the register value we want to write.
	reg_val = Clock_mux_index;
	temp_val = divider_value << 8; //The divider value goes in bits 8-15.
	reg_val |= temp_val;
	Write_MMR(CSL_MAIN_CTRL_MMR0_CFG0_BASE + CSL_MAIN_CTRL_MMR_CFG0_OBSCLK_CTRL + address_offset, reg_val);

	//Now load the divider value into the programmable divider.
	reg_val |= LOAD;
	Write_MMR(CSL_MAIN_CTRL_MMR0_CFG0_BASE + CSL_MAIN_CTRL_MMR_CFG0_OBSCLK_CTRL + address_offset, reg_val);

	//Read the MMR
	temp_val = Read_MMR(CSL_MAIN_CTRL_MMR0_CFG0_BASE + CSL_MAIN_CTRL_MMR_CFG0_OBSCLK_CTRL + address_offset);
	GEL_TextOut("OBSCLK control MMR value: %x\n",,,,, temp_val); //just for debugging

	GEL_TextOut("Main OBSCLK successfully programmed.\n");

}

//for MCU Obsclk
//TODO: Test this before integrating it into GIT
dialog Configure_MCU_OBSCLK(unsigned int Clock_mux_index "Observation Clock Multiplexer Index (which input do you want?):", unsigned int divider_value "Output Divider Value (+1 factored in already): "){
	//Internal variables
	unsigned int temp_val;
	unsigned int temp_val2;
	unsigned int temp_val3;
	unsigned int reg_val;
	unsigned int LOAD;
	unsigned int address_offset;

	//Initialization of internal variables
	temp_val = 0; 
	temp_val2 = 0;
	temp_val3 = 0;
	reg_val = 0;
	LOAD = 0x10000; //Bit 16 is the load bit.
	//address_offset = 0x20000000; //This is the address offset of any peripherals in the WKUP domain outside of the DMSC.

	//If this statement is true we're running from the CM3 DMSC.
	//Make sure to account for the address offset.
	if (*((unsigned int*)WAKEUP_PSC_BASE) != PSC_PID)
    {
        address_offset = 0x20000000;
    } //WKUP Control MMRs use the offset of 0x8000_0000.

    //Error checking against user input. This should be taken care of anyhow.
	if(divider_value > 0xF){
		GEL_TextOut("********ERROR: Divider Value is too large.\n");
		return;
	}
	if(Clock_mux_index >= 16){
		GEL_TextOut("********ERROR: Invalid observation clock multiplexer selection.\n");
		return;
	}

	//Unlock WKUP CTRL MMR Partition 2
	Write_MMR(CSL_WKUP_CTRL_MMR0_CFG0_BASE + CSL_WKUP_CTRL_MMR_CFG0_LOCK2_KICK0 + address_offset, KICK0_UNLOCK_VAL);
	Write_MMR(CSL_WKUP_CTRL_MMR0_CFG0_BASE + CSL_WKUP_CTRL_MMR_CFG0_LOCK2_KICK1 + address_offset, KICK1_UNLOCK_VAL);

	//Read the MMR
	temp_val = Read_MMR(CSL_WKUP_CTRL_MMR0_CFG0_BASE + CSL_WKUP_CTRL_MMR_CFG0_MCU_OBSCLK_CTRL + address_offset);
	GEL_TextOut("MCU OBSCLK control MMR value: %x\n",,,,, temp_val); //just for debugging

	//Write to the actual obsclk the actual obsclk value.
	//First, pack the register value we want to write.
	reg_val = Clock_mux_index;
	temp_val = divider_value << 8; //The divider value goes in bits 8-15.
	reg_val |= temp_val;
	Write_MMR(CSL_WKUP_CTRL_MMR0_CFG0_BASE + CSL_WKUP_CTRL_MMR_CFG0_MCU_OBSCLK_CTRL + address_offset, reg_val);

	//Now load the divider value into the programmable divider.
	reg_val |= LOAD;
	Write_MMR(CSL_WKUP_CTRL_MMR0_CFG0_BASE + CSL_WKUP_CTRL_MMR_CFG0_MCU_OBSCLK_CTRL + address_offset, reg_val);

	//Read the MMR
	temp_val = Read_MMR(CSL_WKUP_CTRL_MMR0_CFG0_BASE + CSL_WKUP_CTRL_MMR_CFG0_MCU_OBSCLK_CTRL + address_offset);
	GEL_TextOut("MCU OBSCLK control MMR value: %x\n",,,,, temp_val); //just for debugging

	GEL_TextOut("MCU OBSCLK successfully programmed.\n");
}

/* END OF FILE */
