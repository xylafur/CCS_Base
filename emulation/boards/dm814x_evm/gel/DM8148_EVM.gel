 /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Project	: DM8148
File	: DM8148_EVM.gel
Purpose	: DM8148 System initilization function
Desciption	: Contains intialization routines for DDR3, HDVICP, UART, TIMER, etc
Version	Hystory	
---------------
Version		Date			Who		 		Description 		
-------		-----------		------		 	-----------
Ver6.1      08-Nov-2011     Viet Dinh		Removed obsoleted old registers
                                            Initial version for broad market
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


/************************************************************************************/ 
 
    #define WR_MEM_32(addr, data)    *(unsigned int*)(addr) =(unsigned int)(data)
    #define RD_MEM_32(addr) 	  	 *(unsigned int*)(addr)
    #define UWORD32 			     unsigned int



menuitem "DM8148 System Initialization"
/********************************************************************************************/
	
	hotmenu mmr_unlock_API()
	{	
			mmr_unlock();
	}

	hotmenu ALL_ADPLL_CLOCKS_ENABLE_API()
	{
			GEL_TextOut("\t ****  DM8148 ALL ADPLL INIT IS In Progress ......... \n","Output",1,1,1);	
			PLL_SETUP();
			GEL_TextOut("\t ****  DM8148 ALL ADPLL INIT IS  Done ************** \n","Output",1,1,1);	
	}

/********************************************************************************************
    //Note: By default the Values of ADPLL are set using "ALL_ADPLL_CLOCKS_ENABLE" function if called.
	
	//CONFIGURE ADPLL TO GET REQUIRED CLKOUTS  with your required values of N,M,M2
	
	//RUN THE HOTMENU of the REQUIRED CHANGED PLL
*********************************************************************************************/	 
	
	/***********************************************************************************
		Change the values of N,M,M2 to get the Required ADPLL Clockout
		cmdxxxxPLL(int CLKIN,int N, int M, int M2)
		
		****   REF_CLK       = (CLKIP)/N+1  [  REF_CLK < 2.5MHz      ] 
    	****   DCOCLK_HS2    = (REF_CLK)*M     [500  < DCOCLK < 1000MHz ] 
    	****   DCOCLK_HS1    = (REF_CLK)*M     [1000 < DCOCLK < 2000MHz ]--used for HDMI CLKDCO    
    	****   CLKOUT        =  DCOCLK/M2      [10   < CLKOUT < 2000MHz ]
    	****   N+1 			           		   [1..256]
    	****   M    		           		   [2..4095]
    	****   M2    		           		   [1..127]
    	****
	*************************************************************************************/



/***************************************************************************************/

	/***************************************************************************
			CONTROL MODULE,ADPLL,C674x,HDVICP,GPMC Clock ENABLES
	*********************************************************************************/
	menuitem "DM8148 CORE_CLKS Configuration"
	
	/********* Clocks PRCM for Control Module  *******/
	hotmenu ControlModule_ClkEnable_API()
	{
        ControlModule_ClkEnable();
	}
	  
	/********* Enable the OCMC0RAM Clocks ************/
 	hotmenu PrcmAlwayOnClkEnable_API()
	{
			PrcmAlwayOnClkEnable();
	}

    /************ Enable the HDVICP Clocks ***************/
	hotmenu HDVICPClkEnable_API()
	{
			HDVICPClkEnable();
	}

    /************ Enable the C674x Clocks ***************/
	hotmenu C674xClkEnable_API()
	{
			C674xClkEnable();
	}


   /********************************************************************************
      					PERIPHERAL CLOCK ENABLES
						EMAC,UART,DSS,MLB,DCAN
   *********************************************************************************/
   /*** ADD Here if any required Module clocks *************/

menuitem "DM8148 Peripheral Clock Init"
	hotmenu emac_clkenable_API()
	{
			emac_clkenable();
	}

	hotmenu Clockout_Enable_API()
	{
		Clockout_Enable();
	}

	hotmenu UARTClkEnable_API()
	{
		UARTClkEnable();
	}

	hotmenu DSSClkEnable_API()
	{
		DSSClkEnable();
	}

	hotmenu MLBClkEnable_API()
	{
		MLBClkEnable();
	}
	
	hotmenu DCANClkEnable_API()
	{
		DCANClkEnable();
	}

	hotmenu GPMC_ClkEnable_API()
	{
		GPMC_ClkEnable();
	}

/********************************************************************************/


/***************************************************************************************************************
			            DM8148 REGISTER MAP DEFINES
***************************************************************************************************************/
	
	#define PRCM_BASE_ADDR			0x48180000
	#define DMM_BASE_ADDR			0x4E000000
	#define EMIF4_0_CFG_BASE_ADDR	0x4C000000
	#define EMIF4_1_CFG_BASE_ADDR	0x4D000000 
	#define GPMC_MEM_BASE_ADDR		0x02000000
	#define DDR_MEM_BASE_ADDR		0x80000000
	#define CTRL_MODULE_BASE_ADDR	0x48140000
	#define C674x_L2RAM_BASE_ADDR		0x40800000
	
	/* Control Module*/
	#define CM_CTRL_CLKCTRL			0x481815c4
	#define DSPBOOTADDR			(CTRL_MODULE_BASE_ADDR + 0x0048) 
	#define CM_ALWON_L3_SLOW_CLKSTCTRL	(PRCM_BASE_ADDR + 0x1400)
	
	/*UART*/
	#define CM_ALWON_UART_0_CLKCTRL 	(PRCM_BASE_ADDR + 0x1550)
	#define CM_ALWON_UART_1_CLKCTRL 	(PRCM_BASE_ADDR + 0x1554)
	#define CM_ALWON_UART_2_CLKCTRL 	(PRCM_BASE_ADDR + 0x1558)
	#define RM_DEFAULT_RSTCTRL			(PRCM_BASE_ADDR + 0x0B10)
	#define RM_DEFAULT_RSTST			(PRCM_BASE_ADDR + 0x0B14)
	#define CM_ALWON_OCMC_0_CLKSTCTRL	(PRCM_BASE_ADDR + 0x1414) 
	#define CM_ALWON_OCMC_0_CLKCTRL		(PRCM_BASE_ADDR + 0x15B4) 
	#define CM_ALWON_GPMC_CLKCTRL		(PRCM_BASE_ADDR + 0x15D0) 
	
	/* McASP2 PRCM definitions */
	#define CM_ALWON_MCA_0_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1540)
	#define CM_ALWON_MCA_1_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1544)
	#define CM_ALWON_MCA_2_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1548)
	#define CM_ALWON_I2C_0_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1564)
	#define CM_ALWON_I2C_1_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1568)
	#define CM_ALWON_MCA_345_CLKSTCTL       (PRCM_BASE_ADDR + 0x156C)
	#define CM_ALWON_SPI_0_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1590)
	#define CM_ALWON_MMC_HS_0_CLKSTCTRL		(PRCM_BASE_ADDR + 0x161C)
	#define CM_ALWON_MMC_HS_1_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1620)
	#define MC_ALWON_ETHNET_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1404)
	#define MC_ALWON_ETH_0_CLKSTCTRL		(PRCM_BASE_ADDR + 0x15D4)
	#define MC_ALWON_ETH_1_CLKSTCTRL		(PRCM_BASE_ADDR + 0x15D8)
	#define CM_ALWON_DCAN_0_CLKCTRL         (PRCM_BASE_ADDR + 0x1618)
	
	/*HDVICP PRCM Definition*/
	#define CM_HDVICP_CLKSTCTRL			(PRCM_BASE_ADDR + 0x0600) 
	#define CM_HDVICP_CLKCTRL		(PRCM_BASE_ADDR + 0x0620) 
	#define CM_HDVICP_SL2_CLKCTRL		(PRCM_BASE_ADDR + 0x0624)  
	#define PM_HDVICP_PWRSTST			(PRCM_BASE_ADDR + 0x0C04)  
	#define RM_HDVICP_RSTCTRL			(PRCM_BASE_ADDR + 0x0C10)  
	#define RM_HDVICP_RSTST		        (PRCM_BASE_ADDR + 0x0C14)  
	/*END OF HDVICP PRCM Definition*/ 
	
	/*C674x PRCM definition*/
	#define CM_C674x_CLKSTCTRL			(PRCM_BASE_ADDR + 0x0400) 
	#define CM_ACTIVE_C674x_CLKCTRL		(PRCM_BASE_ADDR + 0x0420)
	#define PM_ACTIVE_PWRSTST			(PRCM_BASE_ADDR + 0x0A04)
	#define RM_ACTIVE_RSTCTRL			(PRCM_BASE_ADDR + 0x0A10) 
	#define RM_ACTIVE_RSTST				(PRCM_BASE_ADDR + 0x0A14) 
	
	#define CM_MMU_CLKSTCTRL			(PRCM_BASE_ADDR + 0x140C) 
	#define CM_ALWON_MMUDATA_CLKCTRL	(PRCM_BASE_ADDR + 0x159C) 
	
	#define CM_MMUCFG_CLKSTCTRL 		(PRCM_BASE_ADDR + 0x1410) 
	#define CM_ALWON_MMUCFG_CLKCTRL  	(PRCM_BASE_ADDR + 0x15A8) 
	/*END OF C674x PRCM Definition*/ 
	
   //Control Module Always on ClockControl
	#define CM_ALWON_L3_SLOW_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1400)
	#define CM_ALWON_TIMER_0_CLKCTRL     	(PRCM_BASE_ADDR + 0x156C)
	#define CM_ALWON_TIMER_1_CLKCTRL     	(PRCM_BASE_ADDR + 0x1570) 
	#define CM_ALWON_TIMER_2_CLKCTRL     	(PRCM_BASE_ADDR + 0x1574) 
	#define CM_ALWON_TIMER_3_CLKCTRL     	(PRCM_BASE_ADDR + 0x1578) 
	#define CM_ALWON_TIMER_4_CLKCTRL     	(PRCM_BASE_ADDR + 0x157C) 
	#define CM_ALWON_TIMER_5_CLKCTRL     	(PRCM_BASE_ADDR + 0x1580) 
	#define CM_ALWON_TIMER_6_CLKCTRL     	(PRCM_BASE_ADDR + 0x1584)  
	#define CM_ALWON_TIMER_7_CLKCTRL     	(PRCM_BASE_ADDR + 0x1588) 
	#define CM_ALWON_SYSCLK5_CLKSTCTRL		(PRCM_BASE_ADDR + 0x1424)
	#define CM_ALWON_DCAN_0_1_CLKCTRL		(PRCM_BASE_ADDR + 0x1618) 
	
	#define CM_TIMER0_CLKSEL				(PRCM_BASE_ADDR + 0x038C)
	#define CM_TIMER1_CLKSEL				(PRCM_BASE_ADDR + 0x0390)
	#define CM_TIMER2_CLKSEL				(PRCM_BASE_ADDR + 0x0394)
	#define CM_TIMER3_CLKSEL				(PRCM_BASE_ADDR + 0x0398)
	#define CM_TIMER4_CLKSEL				(PRCM_BASE_ADDR + 0x039C)
	#define CM_TIMER5_CLKSEL				(PRCM_BASE_ADDR + 0x03A0)
	#define CM_TIMER6_CLKSEL				(PRCM_BASE_ADDR + 0x03A4)
	#define CM_TIMER7_CLKSEL				(PRCM_BASE_ADDR + 0x03A8)


    //#define SIZE 0x8000
	//#define DATA_SIZE 10
	#define OCMC0RAM_BASE_ADDR 				0x40300000
	#define OCMC1RAM_BASE_ADDR 				0x40400000
	
	#define DMTIMER0_BASE_ADDR 				0x4802C000
	#define DMTIMER1_BASE_ADDR 				0x4802E000
	#define DMTIMER2_BASE_ADDR 				0x48040000
	#define DMTIMER3_BASE_ADDR 				0x48042000
	#define DMTIMER4_BASE_ADDR 				0x48044000
	#define DMTIMER5_BASE_ADDR 				0x48046000
	#define DMTIMER6_BASE_ADDR 				0x48048000
	#define DMTIMER7_BASE_ADDR 				0x4804A000

/*****************************************************************************/
	/*EMIF4 PRCM Defintion*/
	#define CM_DEFAULT_L3_FAST_CLKSTCTRL	(PRCM_BASE_ADDR + 0x0508)    
	#define CM_DEFAULT_EMIF_0_CLKCTRL		(PRCM_BASE_ADDR + 0x0520)
	#define CM_DEFAULT_EMIF_1_CLKCTRL    	(PRCM_BASE_ADDR + 0x0524)
	#define CM_DEFAULT_DMM_CLKCTRL 			(PRCM_BASE_ADDR + 0x0528)
	#define CM_DEFAULT_FW_CLKCTRL 			(PRCM_BASE_ADDR + 0x052C)
	/*end of EMIF4 PRCM definition*/
	
#define	   DDR0_PHY_BASE_ADDR	0x47C0C400
#define	   DDR1_PHY_BASE_ADDR	0x47C0C800
#define	   DDR0_IO_CTRL	       0x48140E04
#define	   DDR1_IO_CTRL	       0x48140E08
#define	   VTP0_CTRL_REG       0x48140E0C
#define	   VTP1_CTRL_REG       0x48140E10
#define	   EMIF4_0_CFG_BASE_ADDR		0x4C000000
#define    EMIF4_1_CFG_BASE_ADDR		0x4D000000 
#define	   DMM_BASE_ADDR			0x4E000000

//-DMM & EMIF4 MMR Declaration
#define DMM_LISA_MAP__0					(DMM_BASE_ADDR + 0x40)
#define DMM_LISA_MAP__1					(DMM_BASE_ADDR + 0x44)
#define DMM_LISA_MAP__2					(DMM_BASE_ADDR + 0x48)
#define DMM_LISA_MAP__3					(DMM_BASE_ADDR + 0x4C)
#define DMM_PAT_BASE_ADDR 				(DMM_BASE_ADDR + 0x460)

#define EMIF4_0_SDRAM_CONFIG			(EMIF4_0_CFG_BASE_ADDR + 0x08)	
#define EMIF4_0_SDRAM_CONFIG2			(EMIF4_0_CFG_BASE_ADDR + 0x0C)	
#define EMIF4_0_SDRAM_REF_CTRL			(EMIF4_0_CFG_BASE_ADDR + 0x10)	
#define EMIF4_0_SDRAM_REF_CTRL_SHADOW		(EMIF4_0_CFG_BASE_ADDR + 0x14)	
#define EMIF4_0_SDRAM_TIM_1			(EMIF4_0_CFG_BASE_ADDR + 0x18)	
#define EMIF4_0_SDRAM_TIM_1_SHADOW		(EMIF4_0_CFG_BASE_ADDR + 0x1C)	
#define EMIF4_0_SDRAM_TIM_2			(EMIF4_0_CFG_BASE_ADDR + 0x20)	
#define EMIF4_0_SDRAM_TIM_2_SHADOW		(EMIF4_0_CFG_BASE_ADDR + 0x24)	
#define EMIF4_0_SDRAM_TIM_3			(EMIF4_0_CFG_BASE_ADDR + 0x28)	
#define EMIF4_0_SDRAM_TIM_3_SHADOW		(EMIF4_0_CFG_BASE_ADDR + 0x2C)	
#define EMIF4_0_DDR_PHY_CTRL_1			(EMIF4_0_CFG_BASE_ADDR + 0xE4)	
#define EMIF4_0_DDR_PHY_CTRL_1_SHADOW		(EMIF4_0_CFG_BASE_ADDR + 0xE8)	
#define EMIF4_0_SDRAM_ZQCR					(EMIF4_0_CFG_BASE_ADDR + 0xC8)	
#define EMIF4_0_RDWR_LVL_RMP_CTRL		(EMIF4_0_CFG_BASE_ADDR + 0xD8)	
#define EMIF4_0_RDWR_LVL_CTRL			(EMIF4_0_CFG_BASE_ADDR + 0xDC)	


#define EMIF4_1_SDRAM_CONFIG			(EMIF4_1_CFG_BASE_ADDR + 0x08)	
#define EMIF4_1_SDRAM_CONFIG2			(EMIF4_1_CFG_BASE_ADDR + 0x0C)	
#define EMIF4_1_SDRAM_REF_CTRL			(EMIF4_1_CFG_BASE_ADDR + 0x10)	
#define EMIF4_1_SDRAM_REF_CTRL_SHADOW		(EMIF4_1_CFG_BASE_ADDR + 0x14)	
#define EMIF4_1_SDRAM_TIM_1			(EMIF4_1_CFG_BASE_ADDR + 0x18)	
#define EMIF4_1_SDRAM_TIM_1_SHADOW		(EMIF4_1_CFG_BASE_ADDR + 0x1C)	
#define EMIF4_1_SDRAM_TIM_2			(EMIF4_1_CFG_BASE_ADDR + 0x20)	
#define EMIF4_1_SDRAM_TIM_2_SHADOW		(EMIF4_1_CFG_BASE_ADDR + 0x24)	
#define EMIF4_1_SDRAM_TIM_3			(EMIF4_1_CFG_BASE_ADDR + 0x28)	
#define EMIF4_1_SDRAM_TIM_3_SHADOW		(EMIF4_1_CFG_BASE_ADDR + 0x2C)	
#define EMIF4_1_DDR_PHY_CTRL_1			(EMIF4_1_CFG_BASE_ADDR + 0xE4)	 
#define EMIF4_1_DDR_PHY_CTRL_1_SHADOW		(EMIF4_1_CFG_BASE_ADDR + 0xE8)	 
#define EMIF4_1_SDRAM_ZQCR					(EMIF4_1_CFG_BASE_ADDR + 0xC8)	
#define EMIF4_1_RDWR_LVL_RMP_CTRL		(EMIF4_1_CFG_BASE_ADDR + 0xD8)	
#define EMIF4_1_RDWR_LVL_CTRL			(EMIF4_1_CFG_BASE_ADDR + 0xDC)	




//- DDR0 Phy MMRs
#define	   CMD0_REG_PHY0_CTRL_SLAVE_RATIO_0	(0x01C + DDR0_PHY_BASE_ADDR)
#define	   CMD0_REG_PHY0_DLL_LOCK_DIFF_0 	(0x028 + DDR0_PHY_BASE_ADDR)
#define	   CMD0_REG_PHY0_INVERT_CLKOUT_0 	(0x02C + DDR0_PHY_BASE_ADDR)
#define	   CMD1_REG_PHY0_CTRL_SLAVE_RATIO_0 	(0x050 + DDR0_PHY_BASE_ADDR)
#define	   CMD1_REG_PHY0_DLL_LOCK_DIFF_0	(0x05C + DDR0_PHY_BASE_ADDR)
#define	   CMD1_REG_PHY0_INVERT_CLKOUT_0	(0x060 + DDR0_PHY_BASE_ADDR)
#define	   CMD2_REG_PHY0_CTRL_SLAVE_RATIO_0	(0x084 + DDR0_PHY_BASE_ADDR)
#define	   CMD2_REG_PHY0_DLL_LOCK_DIFF_0	(0x090 + DDR0_PHY_BASE_ADDR)
#define	   CMD2_REG_PHY0_INVERT_CLKOUT_0	(0x094 + DDR0_PHY_BASE_ADDR)

#define	   DATA0_REG_PHY0_RD_DQS_SLAVE_RATIO_0	(0x0C8 + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_WR_DQS_SLAVE_RATIO_0	(0x0DC + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_WRLVL_INIT_RATIO_0	(0x0F0 + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_WRLVL_INIT_MODE_0 	(0x0F8 + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_GATELVL_INIT_RATIO_0 	(0x0FC + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_GATELVL_INIT_MODE_0 	(0x104 + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 (0x108 + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_WR_DATA_SLAVE_RATIO_0 (0x120 + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_USE_RANK0_DELAYS 	(0x134 + DDR0_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY0_DLL_LOCK_DIFF_0 	(0x138 + DDR0_PHY_BASE_ADDR)

#define	   DATA1_REG_PHY0_RD_DQS_SLAVE_RATIO_0 	(0x16C + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_WR_DQS_SLAVE_RATIO_0 	(0x180 + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_WRLVL_INIT_RATIO_0 	(0x194 + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_WRLVL_INIT_MODE_0 	(0x19C + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_GATELVL_INIT_RATIO_0 	(0x1A0 + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_GATELVL_INIT_MODE_0 	(0x1A8 + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 (0x1AC + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_WR_DATA_SLAVE_RATIO_0 (0x1C4 + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_USE_RANK0_DELAYS 	(0x1D8 + DDR0_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY0_DLL_LOCK_DIFF_0 	(0x1DC + DDR0_PHY_BASE_ADDR)

#define	   DATA2_REG_PHY0_RD_DQS_SLAVE_RATIO_0 	(0x210 + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_WR_DQS_SLAVE_RATIO_0 	(0x224 + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_WRLVL_INIT_RATIO_0 	(0x238 + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_WRLVL_INIT_MODE_0 	(0x240 + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_GATELVL_INIT_RATIO_0 	(0x244 + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_GATELVL_INIT_MODE_0 	(0x24C + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 (0x250 + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_WR_DATA_SLAVE_RATIO_0 (0x268 + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_USE_RANK0_DELAYS 	(0x27C + DDR0_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY0_DLL_LOCK_DIFF_0 	(0x280 + DDR0_PHY_BASE_ADDR)

#define	   DATA3_REG_PHY0_RD_DQS_SLAVE_RATIO_0 	(0x2B4 + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_WR_DQS_SLAVE_RATIO_0 	(0x2C8 + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_WRLVL_INIT_RATIO_0 	(0x2DC + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_WRLVL_INIT_MODE_0 	(0x2E4 + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_GATELVL_INIT_RATIO_0 	(0x2E8 + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_GATELVL_INIT_MODE_0 	(0x2F0 + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 (0x2F4 + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_WR_DATA_SLAVE_RATIO_0 (0x30C + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_USE_RANK0_DELAYS 	(0x320 + DDR0_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY0_DLL_LOCK_DIFF_0 	(0x324 + DDR0_PHY_BASE_ADDR)


//- DDR1 Phy MMRs
#define	   CMD0_REG_PHY1_CTRL_SLAVE_RATIO_0	(0x01C + DDR1_PHY_BASE_ADDR)
#define	   CMD0_REG_PHY1_DLL_LOCK_DIFF_0 	(0x028 + DDR1_PHY_BASE_ADDR)
#define	   CMD0_REG_PHY1_INVERT_CLKOUT_0 	(0x02C + DDR1_PHY_BASE_ADDR)
#define	   CMD1_REG_PHY1_CTRL_SLAVE_RATIO_0 	(0x050 + DDR1_PHY_BASE_ADDR)
#define	   CMD1_REG_PHY1_DLL_LOCK_DIFF_0	(0x05C + DDR1_PHY_BASE_ADDR)
#define	   CMD1_REG_PHY1_INVERT_CLKOUT_0	(0x060 + DDR1_PHY_BASE_ADDR)
#define	   CMD2_REG_PHY1_CTRL_SLAVE_RATIO_0	(0x084 + DDR1_PHY_BASE_ADDR)
#define	   CMD2_REG_PHY1_DLL_LOCK_DIFF_0	(0x090 + DDR1_PHY_BASE_ADDR)
#define	   CMD2_REG_PHY1_INVERT_CLKOUT_0	(0x094 + DDR1_PHY_BASE_ADDR)

#define	   DATA0_REG_PHY1_RD_DQS_SLAVE_RATIO_0	(0x0C8 + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_WR_DQS_SLAVE_RATIO_0	(0x0DC + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_WRLVL_INIT_RATIO_0	(0x0F0 + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_WRLVL_INIT_MODE_0 	(0x0F8 + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_GATELVL_INIT_RATIO_0 	(0x0FC + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_GATELVL_INIT_MODE_0 	(0x104 + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_FIFO_WE_SLAVE_RATIO_0 (0x108 + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_WR_DATA_SLAVE_RATIO_0 (0x120 + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_USE_RANK0_DELAYS 	(0x134 + DDR1_PHY_BASE_ADDR)
#define	   DATA0_REG_PHY1_DLL_LOCK_DIFF_0 	(0x138 + DDR1_PHY_BASE_ADDR)

#define	   DATA1_REG_PHY1_RD_DQS_SLAVE_RATIO_0 	(0x16C + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_WR_DQS_SLAVE_RATIO_0 	(0x180 + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_WRLVL_INIT_RATIO_0 	(0x194 + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_WRLVL_INIT_MODE_0 	(0x19C + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_GATELVL_INIT_RATIO_0 	(0x1A0 + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_GATELVL_INIT_MODE_0 	(0x1A8 + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_FIFO_WE_SLAVE_RATIO_0 (0x1AC + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_WR_DATA_SLAVE_RATIO_0 (0x1C4 + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_USE_RANK0_DELAYS 	(0x1D8 + DDR1_PHY_BASE_ADDR)
#define	   DATA1_REG_PHY1_DLL_LOCK_DIFF_0 	(0x1DC + DDR1_PHY_BASE_ADDR)

#define	   DATA2_REG_PHY1_RD_DQS_SLAVE_RATIO_0 	(0x210 + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_WR_DQS_SLAVE_RATIO_0 	(0x224 + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_WRLVL_INIT_RATIO_0 	(0x238 + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_WRLVL_INIT_MODE_0 	(0x240 + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_GATELVL_INIT_RATIO_0 	(0x244 + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_GATELVL_INIT_MODE_0 	(0x24C + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_FIFO_WE_SLAVE_RATIO_0 (0x250 + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_WR_DATA_SLAVE_RATIO_0 (0x268 + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_USE_RANK0_DELAYS 	(0x27C + DDR1_PHY_BASE_ADDR)
#define	   DATA2_REG_PHY1_DLL_LOCK_DIFF_0 	(0x280 + DDR1_PHY_BASE_ADDR)

#define	   DATA3_REG_PHY1_RD_DQS_SLAVE_RATIO_0 	(0x2B4 + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_WR_DQS_SLAVE_RATIO_0 	(0x2C8 + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_WRLVL_INIT_RATIO_0 	(0x2DC + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_WRLVL_INIT_MODE_0 	(0x2E4 + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_GATELVL_INIT_RATIO_0 	(0x2E8 + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_GATELVL_INIT_MODE_0 	(0x2F0 + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_FIFO_WE_SLAVE_RATIO_0 (0x2F4 + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_WR_DATA_SLAVE_RATIO_0 (0x30C + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_USE_RANK0_DELAYS 	(0x320 + DDR1_PHY_BASE_ADDR)
#define	   DATA3_REG_PHY1_DLL_LOCK_DIFF_0 	(0x324 + DDR1_PHY_BASE_ADDR)

#define    DATA_MACRO_0             0
#define    DATA_MACRO_1             1
#define    DATA_MACRO_2             2
#define    DATA_MACRO_3             3
#define    DDR_PHY0		  0
#define    DDR_PHY1		  1

#define    DDR_FREQ		 800 // 333MHz

//- Common DDR PHY parameters
#define	   PHY_INVERT_CLKOUT_DEFINE		 0
#define	   DDR3_PHY_INVERT_CLKOUT_ON	 1
#define	   DDR3_PHY_INVERT_CLKOUT_OFF	 0

#define	   PHY_REG_USE_RANK0_DELAY_DEFINE	 0
#define	   PHY_DLL_LOCK_DIFF_DEFINE 	        0x4
#define	   PHY_CMD0_DLL_LOCK_DIFF_DEFINE	0x4

#define	   PHY_GATELVL_INIT_CS0_DEFINE           0x0
#define	   PHY_WRLVL_INIT_CS0_DEFINE		 0x0

#define	   PHY_GATELVL_INIT_CS1_DEFINE           0x0
#define	   PHY_WRLVL_INIT_CS1_DEFINE		 0x0
#define	   PHY_CTRL_SLAVE_RATIO_CS1_DEFINE       0x80 

//- DDR2 parameters

#define    DDR2_EMIF_READ_LATENCY_DEFINE	0x00173208
	
#define    DDR2_EMIF_TIM1_DEFINE			0x0888E4E2 
#define    DDR2_EMIF_TIM2_DEFINE			0x202D31D2 
#define    DDR2_EMIF_TIM3_DEFINE			0x500002AF
#define    DDR2_EMIF_REF_CTRL_DEFINE		0x00000A25
#define    DDR2_EMIF_SDRAM_CONFIG_DEFINE	0x41801832

#define	   DDR2_PHY_RD_DQS_CS0_DEFINE	0x34 //- Calculated using ratio calculator
#define	   DDR2_PHY_WR_DQS_CS0_DEFINE	0x10
#define	   DDR2_PHY_FIFO_WE_CS0_DEFINE	0xA0
#define	   DDR2_PHY_WR_DATA_CS0_DEFINE	0x50
#define	   DDR2_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE       0x80

//- DDR3 parameters

#define    DDR3_EMIF_REF_CTRL_DEFINE1			0x00004000
#define    DDR3_EMIF_SDRAM_ZQCR_DEFINE  		0x50074BE1


//DDR3 300 MHz - CL=5,CWL=5
#define    DDR3_EMIF_TIM1_DEFINE_300			0x0888A394
#define    DDR3_EMIF_TIM2_DEFINE_300			0x20237FE2
#define    DDR3_EMIF_TIM3_DEFINE_300			0x501F820F
#define    DDR3_EMIF_REF_CTRL_DEFINE2_300		0x00000924
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_300	0x61C009B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_300	0x00173208

//DDR3 333 MHz - CL=6,CWL=5
#define    DDR3_EMIF_TIM1_DEFINE_333			0x0888B414
#define    DDR3_EMIF_TIM2_DEFINE_333			0x20277FE2
#define    DDR3_EMIF_TIM3_DEFINE_333			0x501F824F
#define    DDR3_EMIF_REF_CTRL_DEFINE2_333		0x00000A25
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_333	0x61C011B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_333	0x00173209

//DDR3 400 MHz - CL=6,CWL=5
#define    DDR3_EMIF_TIM1_DEFINE_400			0x0AAAD4DB
#define    DDR3_EMIF_TIM2_DEFINE_400			0x682F7FDA
#define    DDR3_EMIF_TIM3_DEFINE_400			0x501F82BF
#define    DDR3_EMIF_REF_CTRL_DEFINE2_400		0x00000C30
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_400	0x61C011B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_400	0x00173209

//DDR3 450 MHz - CL=7,CWL=6
#define    DDR3_EMIF_TIM1_DEFINE_450			0x0CCCF55C
#define    DDR3_EMIF_TIM2_DEFINE_450			0x30357FE2
#define    DDR3_EMIF_TIM3_DEFINE_450			0x501F831F
#define    DDR3_EMIF_REF_CTRL_DEFINE2_450		0x00000DB6
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_450	0x61C119B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_450	0x0017320A

//DDR3 533 MHz - CL=8,CWL=6
#define    DDR3_EMIF_TIM1_DEFINE_533			0x0EEF2664
#define    DDR3_EMIF_TIM2_DEFINE_533			0x303F7FE2
#define    DDR3_EMIF_TIM3_DEFINE_533			0x501F83AF
#define    DDR3_EMIF_REF_CTRL_DEFINE2_533		0x0000103D
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_533	0x61C121B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_533	0x0017320B

//DDR3 666 MHz - CL=9,CWL=7
#define    DDR3_EMIF_TIM1_DEFINE_666			0x1333782C
#define    DDR3_EMIF_TIM2_DEFINE_666			0x404F7FE2
#define    DDR3_EMIF_TIM3_DEFINE_666			0x501F849F
#define    DDR3_EMIF_REF_CTRL_DEFINE2_666		0x0000144A
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_666	0x61C229B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_666	0x0017320C



#define	   DDR3_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE       0x80

#define	   DDR3_PHY_RD_DQS_CS0_DEFINE   0x30  // software leveling code @400MHz
#define	   DDR3_PHY_WR_DQS_CS0_DEFINE	0x21
#define	   DDR3_PHY_FIFO_WE_CS0_DEFINE	0xC0
#define	   DDR3_PHY_WR_DATA_CS0_DEFINE	0x44

    /*************************************************************************/
	
	//Clockout_Enable
	// CLKOUT2DIV THis  field controls the external clock divison factor
	//          0x0:      SYS_CLKOLUT2/1 
	//          0x1:      SYS_CLKOUT2/2 
	//          0x2:      SYS_CLKOUT2/4 
	//          0x3:      SYS_CLKOUT2/8 
	//          0x4:      SYS_CLKOUT2/16 
	
	// CLKOUT2SOURCE     This field selects the external output clock source
	//          0x0:      Source clock is MAIN_PLL_CLK5 
	//          0x1:      Source clock is DDR_PLL_CLK1 
	//          0x2:      Source clock is VIDEO_PLL_CLK1 
	//          0x3:      Source clock is AUDIO_PLL_CLK1 

	#define CLKOUT2EN    1
	#define CLKOUT2DIV  0
	#define CLKOUT2SRC  0 
	
	
	/**********************************************************************/
	//Pincntrl Configurations
#define	PINCNTL1	(	CTRL_MODULE_BASE_ADDR +	0x0800	)
#define	PINCNTL2	(	CTRL_MODULE_BASE_ADDR +	0x0804	)
#define	PINCNTL3	(	CTRL_MODULE_BASE_ADDR +	0x0808	)
#define	PINCNTL4	(	CTRL_MODULE_BASE_ADDR +	0x080C	)
#define	PINCNTL5	(	CTRL_MODULE_BASE_ADDR +	0x0810	)
#define	PINCNTL6	(	CTRL_MODULE_BASE_ADDR +	0x0814	)
#define	PINCNTL7	(	CTRL_MODULE_BASE_ADDR +	0x0818	)
#define	PINCNTL8	(	CTRL_MODULE_BASE_ADDR +	0x081C	)
#define	PINCNTL9	(	CTRL_MODULE_BASE_ADDR +	0x0820	)
#define	PINCNTL10	(	CTRL_MODULE_BASE_ADDR +	0x0824	)
#define	PINCNTL11	(	CTRL_MODULE_BASE_ADDR +	0x0828	)
#define	PINCNTL12	(	CTRL_MODULE_BASE_ADDR +	0x082C	)
#define	PINCNTL13	(	CTRL_MODULE_BASE_ADDR +	0x0830	)
#define	PINCNTL14	(	CTRL_MODULE_BASE_ADDR +	0x0834	)
#define	PINCNTL15	(	CTRL_MODULE_BASE_ADDR +	0x0838	)
#define	PINCNTL16	(	CTRL_MODULE_BASE_ADDR +	0x083C	)
#define	PINCNTL17	(	CTRL_MODULE_BASE_ADDR +	0x0840	)
#define	PINCNTL18	(	CTRL_MODULE_BASE_ADDR +	0x0844	)
#define	PINCNTL19	(	CTRL_MODULE_BASE_ADDR +	0x0848	)
#define	PINCNTL20	(	CTRL_MODULE_BASE_ADDR +	0x084C	)
#define	PINCNTL21	(	CTRL_MODULE_BASE_ADDR +	0x0850	)
#define	PINCNTL22	(	CTRL_MODULE_BASE_ADDR +	0x0854	)
#define	PINCNTL23	(	CTRL_MODULE_BASE_ADDR +	0x0858	)
#define	PINCNTL24	(	CTRL_MODULE_BASE_ADDR +	0x085C	)
#define	PINCNTL25	(	CTRL_MODULE_BASE_ADDR +	0x0860	)
#define	PINCNTL26	(	CTRL_MODULE_BASE_ADDR +	0x0864	)
#define	PINCNTL27	(	CTRL_MODULE_BASE_ADDR +	0x0868	)
#define	PINCNTL28	(	CTRL_MODULE_BASE_ADDR +	0x086C	)
#define	PINCNTL29	(	CTRL_MODULE_BASE_ADDR +	0x0870	)
#define	PINCNTL30	(	CTRL_MODULE_BASE_ADDR +	0x0874	)
#define	PINCNTL31	(	CTRL_MODULE_BASE_ADDR +	0x0878	)
#define	PINCNTL32	(	CTRL_MODULE_BASE_ADDR +	0x087C	)
#define	PINCNTL33	(	CTRL_MODULE_BASE_ADDR +	0x0880	)
#define	PINCNTL34	(	CTRL_MODULE_BASE_ADDR +	0x0884	)
#define	PINCNTL35	(	CTRL_MODULE_BASE_ADDR +	0x0888	)
#define	PINCNTL36	(	CTRL_MODULE_BASE_ADDR +	0x088C	)
#define	PINCNTL37	(	CTRL_MODULE_BASE_ADDR +	0x0890	)
#define	PINCNTL38	(	CTRL_MODULE_BASE_ADDR +	0x0894	)
#define	PINCNTL39	(	CTRL_MODULE_BASE_ADDR +	0x0898	)
#define	PINCNTL40	(	CTRL_MODULE_BASE_ADDR +	0x089C	)
#define	PINCNTL41	(	CTRL_MODULE_BASE_ADDR +	0x08A0	)
#define	PINCNTL42	(	CTRL_MODULE_BASE_ADDR +	0x08A4	)
#define	PINCNTL43	(	CTRL_MODULE_BASE_ADDR +	0x08A8	)
#define	PINCNTL44	(	CTRL_MODULE_BASE_ADDR +	0x08AC	)
#define	PINCNTL45	(	CTRL_MODULE_BASE_ADDR +	0x08B0	)
#define	PINCNTL46	(	CTRL_MODULE_BASE_ADDR +	0x08B4	)
#define	PINCNTL47	(	CTRL_MODULE_BASE_ADDR +	0x08B8	)
#define	PINCNTL48	(	CTRL_MODULE_BASE_ADDR +	0x08BC	)
#define	PINCNTL49	(	CTRL_MODULE_BASE_ADDR +	0x08C0	)
#define	PINCNTL50	(	CTRL_MODULE_BASE_ADDR +	0x08C4	)
#define	PINCNTL51	(	CTRL_MODULE_BASE_ADDR +	0x08C8	)
#define	PINCNTL52	(	CTRL_MODULE_BASE_ADDR +	0x08CC	)
#define	PINCNTL53	(	CTRL_MODULE_BASE_ADDR +	0x08D0	)
#define	PINCNTL54	(	CTRL_MODULE_BASE_ADDR +	0x08D4	)
#define	PINCNTL55	(	CTRL_MODULE_BASE_ADDR +	0x08D8	)
#define	PINCNTL56	(	CTRL_MODULE_BASE_ADDR +	0x08DC	)
#define	PINCNTL57	(	CTRL_MODULE_BASE_ADDR +	0x08E0	)
#define	PINCNTL58	(	CTRL_MODULE_BASE_ADDR +	0x08E4	)
#define	PINCNTL59	(	CTRL_MODULE_BASE_ADDR +	0x08E8	)
#define	PINCNTL60	(	CTRL_MODULE_BASE_ADDR +	0x08EC	)
#define	PINCNTL61	(	CTRL_MODULE_BASE_ADDR +	0x08F0	)
#define	PINCNTL62	(	CTRL_MODULE_BASE_ADDR +	0x08F4	)
#define	PINCNTL63	(	CTRL_MODULE_BASE_ADDR +	0x08F8	)
#define	PINCNTL64	(	CTRL_MODULE_BASE_ADDR +	0x08FC	)
#define	PINCNTL65	(	CTRL_MODULE_BASE_ADDR +	0x0900	)
#define	PINCNTL66	(	CTRL_MODULE_BASE_ADDR +	0x0904	)
#define	PINCNTL67	(	CTRL_MODULE_BASE_ADDR +	0x0908	)
#define	PINCNTL68	(	CTRL_MODULE_BASE_ADDR +	0x090C	)
#define	PINCNTL69	(	CTRL_MODULE_BASE_ADDR +	0x0910	)
#define	PINCNTL70	(	CTRL_MODULE_BASE_ADDR +	0x0914	)
#define	PINCNTL71	(	CTRL_MODULE_BASE_ADDR +	0x0918	)
#define	PINCNTL72	(	CTRL_MODULE_BASE_ADDR +	0x091C	)
#define	PINCNTL73	(	CTRL_MODULE_BASE_ADDR +	0x0920	)
#define	PINCNTL74	(	CTRL_MODULE_BASE_ADDR +	0x0924	)
#define	PINCNTL75	(	CTRL_MODULE_BASE_ADDR +	0x0928	)
#define	PINCNTL76	(	CTRL_MODULE_BASE_ADDR +	0x092C	)
#define	PINCNTL77	(	CTRL_MODULE_BASE_ADDR +	0x0930	)
#define	PINCNTL78	(	CTRL_MODULE_BASE_ADDR +	0x0934	)
#define	PINCNTL79	(	CTRL_MODULE_BASE_ADDR +	0x0938	)
#define	PINCNTL80	(	CTRL_MODULE_BASE_ADDR +	0x093C	)
#define	PINCNTL81	(	CTRL_MODULE_BASE_ADDR +	0x0940	)
#define	PINCNTL82	(	CTRL_MODULE_BASE_ADDR +	0x0944	)
#define	PINCNTL83	(	CTRL_MODULE_BASE_ADDR +	0x0948	)
#define	PINCNTL84	(	CTRL_MODULE_BASE_ADDR +	0x094C	)
#define	PINCNTL85	(	CTRL_MODULE_BASE_ADDR +	0x0950	)
#define	PINCNTL86	(	CTRL_MODULE_BASE_ADDR +	0x0954	)
#define	PINCNTL87	(	CTRL_MODULE_BASE_ADDR +	0x0958	)
#define	PINCNTL88	(	CTRL_MODULE_BASE_ADDR +	0x095C	)
#define	PINCNTL89	(	CTRL_MODULE_BASE_ADDR +	0x0960	)
#define	PINCNTL90	(	CTRL_MODULE_BASE_ADDR +	0x0964	)
#define	PINCNTL91	(	CTRL_MODULE_BASE_ADDR +	0x0968	)
#define	PINCNTL92	(	CTRL_MODULE_BASE_ADDR +	0x096C	)
#define	PINCNTL93	(	CTRL_MODULE_BASE_ADDR +	0x0970	)
#define	PINCNTL94	(	CTRL_MODULE_BASE_ADDR +	0x0974	)
#define	PINCNTL95	(	CTRL_MODULE_BASE_ADDR +	0x0978	)
#define	PINCNTL96	(	CTRL_MODULE_BASE_ADDR +	0x097C	)
#define	PINCNTL97	(	CTRL_MODULE_BASE_ADDR +	0x0980	)
#define	PINCNTL98	(	CTRL_MODULE_BASE_ADDR +	0x0984	)
#define	PINCNTL99	(	CTRL_MODULE_BASE_ADDR +	0x0988	)
#define	PINCNTL100	(	CTRL_MODULE_BASE_ADDR +	0x098C	)
#define	PINCNTL101	(	CTRL_MODULE_BASE_ADDR +	0x0990	)
#define	PINCNTL102	(	CTRL_MODULE_BASE_ADDR +	0x0994	)
#define	PINCNTL103	(	CTRL_MODULE_BASE_ADDR +	0x0998	)
#define	PINCNTL104	(	CTRL_MODULE_BASE_ADDR +	0x099C	)
#define	PINCNTL105	(	CTRL_MODULE_BASE_ADDR +	0x09A0	)
#define	PINCNTL106	(	CTRL_MODULE_BASE_ADDR +	0x09A4	)
#define	PINCNTL107	(	CTRL_MODULE_BASE_ADDR +	0x09A8	)
#define	PINCNTL108	(	CTRL_MODULE_BASE_ADDR +	0x09AC	)
#define	PINCNTL109	(	CTRL_MODULE_BASE_ADDR +	0x09B0	)
#define	PINCNTL110	(	CTRL_MODULE_BASE_ADDR +	0x09B4	)
#define	PINCNTL111	(	CTRL_MODULE_BASE_ADDR +	0x09B8	)
#define	PINCNTL112	(	CTRL_MODULE_BASE_ADDR +	0x09BC	)
#define	PINCNTL113	(	CTRL_MODULE_BASE_ADDR +	0x09C0	)
#define	PINCNTL114	(	CTRL_MODULE_BASE_ADDR +	0x09C4	)
#define	PINCNTL115	(	CTRL_MODULE_BASE_ADDR +	0x09C8	)
#define	PINCNTL116	(	CTRL_MODULE_BASE_ADDR +	0x09CC	)
#define	PINCNTL117	(	CTRL_MODULE_BASE_ADDR +	0x09D0	)
#define	PINCNTL118	(	CTRL_MODULE_BASE_ADDR +	0x09D4	)
#define	PINCNTL119	(	CTRL_MODULE_BASE_ADDR +	0x09D8	)
#define	PINCNTL120	(	CTRL_MODULE_BASE_ADDR +	0x09DC	)
#define	PINCNTL121	(	CTRL_MODULE_BASE_ADDR +	0x09E0	)
#define	PINCNTL122	(	CTRL_MODULE_BASE_ADDR +	0x09E4	)
#define	PINCNTL123	(	CTRL_MODULE_BASE_ADDR +	0x09E8	)
#define	PINCNTL124	(	CTRL_MODULE_BASE_ADDR +	0x09EC	)
#define	PINCNTL125	(	CTRL_MODULE_BASE_ADDR +	0x09F0	)
#define	PINCNTL126	(	CTRL_MODULE_BASE_ADDR +	0x09F4	)
#define	PINCNTL127	(	CTRL_MODULE_BASE_ADDR +	0x09F8	)
#define	PINCNTL128	(	CTRL_MODULE_BASE_ADDR +	0x09FC	)
#define	PINCNTL129	(	CTRL_MODULE_BASE_ADDR +	0x0A00	)
#define	PINCNTL130	(	CTRL_MODULE_BASE_ADDR +	0x0A04	)
#define	PINCNTL131	(	CTRL_MODULE_BASE_ADDR +	0x0A08	)
#define	PINCNTL132	(	CTRL_MODULE_BASE_ADDR +	0x0A0C	)
#define	PINCNTL133	(	CTRL_MODULE_BASE_ADDR +	0x0A10	)
#define	PINCNTL134	(	CTRL_MODULE_BASE_ADDR +	0x0A14	)
#define	PINCNTL135	(	CTRL_MODULE_BASE_ADDR +	0x0A18	)
#define	PINCNTL136	(	CTRL_MODULE_BASE_ADDR +	0x0A1C	)
#define	PINCNTL137	(	CTRL_MODULE_BASE_ADDR +	0x0A20	)
#define	PINCNTL138	(	CTRL_MODULE_BASE_ADDR +	0x0A24	)
#define	PINCNTL139	(	CTRL_MODULE_BASE_ADDR +	0x0A28	)
#define	PINCNTL140	(	CTRL_MODULE_BASE_ADDR +	0x0A2C	)
#define	PINCNTL141	(	CTRL_MODULE_BASE_ADDR +	0x0A30	)
#define	PINCNTL142	(	CTRL_MODULE_BASE_ADDR +	0x0A34	)
#define	PINCNTL143	(	CTRL_MODULE_BASE_ADDR +	0x0A38	)
#define	PINCNTL144	(	CTRL_MODULE_BASE_ADDR +	0x0A3C	)
#define	PINCNTL145	(	CTRL_MODULE_BASE_ADDR +	0x0A40	)
#define	PINCNTL146	(	CTRL_MODULE_BASE_ADDR +	0x0A44	)
#define	PINCNTL147	(	CTRL_MODULE_BASE_ADDR +	0x0A48	)
#define	PINCNTL148	(	CTRL_MODULE_BASE_ADDR +	0x0A4C	)
#define	PINCNTL149	(	CTRL_MODULE_BASE_ADDR +	0x0A50	)
#define	PINCNTL150	(	CTRL_MODULE_BASE_ADDR +	0x0A54	)
#define	PINCNTL151	(	CTRL_MODULE_BASE_ADDR +	0x0A58	)
#define	PINCNTL152	(	CTRL_MODULE_BASE_ADDR +	0x0A5C	)
#define	PINCNTL153	(	CTRL_MODULE_BASE_ADDR +	0x0A60	)
#define	PINCNTL154	(	CTRL_MODULE_BASE_ADDR +	0x0A64	)
#define	PINCNTL155	(	CTRL_MODULE_BASE_ADDR +	0x0A68	)
#define	PINCNTL156	(	CTRL_MODULE_BASE_ADDR +	0x0A6C	)
#define	PINCNTL157	(	CTRL_MODULE_BASE_ADDR +	0x0A70	)
#define	PINCNTL158	(	CTRL_MODULE_BASE_ADDR +	0x0A74	)
#define	PINCNTL159	(	CTRL_MODULE_BASE_ADDR +	0x0A78	)
#define	PINCNTL160	(	CTRL_MODULE_BASE_ADDR +	0x0A7C	)
#define	PINCNTL161	(	CTRL_MODULE_BASE_ADDR +	0x0A80	)
#define	PINCNTL162	(	CTRL_MODULE_BASE_ADDR +	0x0A84	)
#define	PINCNTL163	(	CTRL_MODULE_BASE_ADDR +	0x0A88	)
#define	PINCNTL164	(	CTRL_MODULE_BASE_ADDR +	0x0A8C	)
#define	PINCNTL165	(	CTRL_MODULE_BASE_ADDR +	0x0A90	)
#define	PINCNTL166	(	CTRL_MODULE_BASE_ADDR +	0x0A94	)
#define	PINCNTL167	(	CTRL_MODULE_BASE_ADDR +	0x0A98	)
#define	PINCNTL168	(	CTRL_MODULE_BASE_ADDR +	0x0A9C	)
#define	PINCNTL169	(	CTRL_MODULE_BASE_ADDR +	0x0AA0	)
#define	PINCNTL170	(	CTRL_MODULE_BASE_ADDR +	0x0AA4	)
#define	PINCNTL171	(	CTRL_MODULE_BASE_ADDR +	0x0AA8	)
#define	PINCNTL172	(	CTRL_MODULE_BASE_ADDR +	0x0AAC	)
#define	PINCNTL173	(	CTRL_MODULE_BASE_ADDR +	0x0AB0	)
#define	PINCNTL174	(	CTRL_MODULE_BASE_ADDR +	0x0AB4	)
#define	PINCNTL175	(	CTRL_MODULE_BASE_ADDR +	0x0AB8	)
#define	PINCNTL176	(	CTRL_MODULE_BASE_ADDR +	0x0ABC	)
#define	PINCNTL177	(	CTRL_MODULE_BASE_ADDR +	0x0AC0	)
#define	PINCNTL178	(	CTRL_MODULE_BASE_ADDR +	0x0AC4	)
#define	PINCNTL179	(	CTRL_MODULE_BASE_ADDR +	0x0AC8	)
#define	PINCNTL180	(	CTRL_MODULE_BASE_ADDR +	0x0ACC	)
#define	PINCNTL181	(	CTRL_MODULE_BASE_ADDR +	0x0AD0	)
#define	PINCNTL182	(	CTRL_MODULE_BASE_ADDR +	0x0AD4	)
#define	PINCNTL183	(	CTRL_MODULE_BASE_ADDR +	0x0AD8	)
#define	PINCNTL184	(	CTRL_MODULE_BASE_ADDR +	0x0ADC	)
#define	PINCNTL185	(	CTRL_MODULE_BASE_ADDR +	0x0AE0	)
#define	PINCNTL186	(	CTRL_MODULE_BASE_ADDR +	0x0AE4	)
#define	PINCNTL187	(	CTRL_MODULE_BASE_ADDR +	0x0AE8	)
#define	PINCNTL188	(	CTRL_MODULE_BASE_ADDR +	0x0AEC	)
#define	PINCNTL189	(	CTRL_MODULE_BASE_ADDR +	0x0AF0	)
#define	PINCNTL190	(	CTRL_MODULE_BASE_ADDR +	0x0AF4	)
#define	PINCNTL191	(	CTRL_MODULE_BASE_ADDR +	0x0AF8	)
#define	PINCNTL192	(	CTRL_MODULE_BASE_ADDR +	0x0AFC	)
#define	PINCNTL193	(	CTRL_MODULE_BASE_ADDR +	0x0B00	)
#define	PINCNTL194	(	CTRL_MODULE_BASE_ADDR +	0x0B04	)
#define	PINCNTL195	(	CTRL_MODULE_BASE_ADDR +	0x0B08	)
#define	PINCNTL196	(	CTRL_MODULE_BASE_ADDR +	0x0B0C	)
#define	PINCNTL197	(	CTRL_MODULE_BASE_ADDR +	0x0B10	)
#define	PINCNTL198	(	CTRL_MODULE_BASE_ADDR +	0x0B14	)
#define	PINCNTL199	(	CTRL_MODULE_BASE_ADDR +	0x0B18	)
#define	PINCNTL200	(	CTRL_MODULE_BASE_ADDR +	0x0B1C	)
#define	PINCNTL201	(	CTRL_MODULE_BASE_ADDR +	0x0B20	)
#define	PINCNTL202	(	CTRL_MODULE_BASE_ADDR +	0x0B24	)
#define	PINCNTL203	(	CTRL_MODULE_BASE_ADDR +	0x0B28	)
#define	PINCNTL204	(	CTRL_MODULE_BASE_ADDR +	0x0B2C	)
#define	PINCNTL205	(	CTRL_MODULE_BASE_ADDR +	0x0B30	)
#define	PINCNTL206	(	CTRL_MODULE_BASE_ADDR +	0x0B34	)
#define	PINCNTL207	(	CTRL_MODULE_BASE_ADDR +	0x0B38	)
#define	PINCNTL208	(	CTRL_MODULE_BASE_ADDR +	0x0B3C	)
#define	PINCNTL209	(	CTRL_MODULE_BASE_ADDR +	0x0B40	)
#define	PINCNTL210	(	CTRL_MODULE_BASE_ADDR +	0x0B44	)
#define	PINCNTL211	(	CTRL_MODULE_BASE_ADDR +	0x0B48	)
#define	PINCNTL212	(	CTRL_MODULE_BASE_ADDR +	0x0B4C	)
#define	PINCNTL213	(	CTRL_MODULE_BASE_ADDR +	0x0B50	)
#define	PINCNTL214	(	CTRL_MODULE_BASE_ADDR +	0x0B54	)
#define	PINCNTL215	(	CTRL_MODULE_BASE_ADDR +	0x0B58	)
#define	PINCNTL216	(	CTRL_MODULE_BASE_ADDR +	0x0B5C	)
#define	PINCNTL217	(	CTRL_MODULE_BASE_ADDR +	0x0B60	)
#define	PINCNTL218	(	CTRL_MODULE_BASE_ADDR +	0x0B64	)
#define	PINCNTL219	(	CTRL_MODULE_BASE_ADDR +	0x0B68	)
#define	PINCNTL220	(	CTRL_MODULE_BASE_ADDR +	0x0B6C	)
#define	PINCNTL221	(	CTRL_MODULE_BASE_ADDR +	0x0B70	)
#define	PINCNTL222	(	CTRL_MODULE_BASE_ADDR +	0x0B74	)
#define	PINCNTL223	(	CTRL_MODULE_BASE_ADDR +	0x0B78	)
#define	PINCNTL224	(	CTRL_MODULE_BASE_ADDR +	0x0B7C	)
#define	PINCNTL225	(	CTRL_MODULE_BASE_ADDR +	0x0B80	)
#define	PINCNTL226	(	CTRL_MODULE_BASE_ADDR +	0x0B84	)
#define	PINCNTL227	(	CTRL_MODULE_BASE_ADDR +	0x0B88	)
#define	PINCNTL228	(	CTRL_MODULE_BASE_ADDR +	0x0B8C	)
#define	PINCNTL229	(	CTRL_MODULE_BASE_ADDR +	0x0B90	)
#define	PINCNTL230	(	CTRL_MODULE_BASE_ADDR +	0x0B94	)
#define	PINCNTL231	(	CTRL_MODULE_BASE_ADDR +	0x0B98	)
#define	PINCNTL232	(	CTRL_MODULE_BASE_ADDR +	0x0B9C	)
#define	PINCNTL233	(	CTRL_MODULE_BASE_ADDR +	0x0BA0	)
#define	PINCNTL234	(	CTRL_MODULE_BASE_ADDR +	0x0BA4	)
#define	PINCNTL235	(	CTRL_MODULE_BASE_ADDR +	0x0BA8	)
#define	PINCNTL236	(	CTRL_MODULE_BASE_ADDR +	0x0BAC	)
#define	PINCNTL237	(	CTRL_MODULE_BASE_ADDR +	0x0BB0	)
#define	PINCNTL238	(	CTRL_MODULE_BASE_ADDR +	0x0BB4	)
#define	PINCNTL239	(	CTRL_MODULE_BASE_ADDR +	0x0BB8	)
#define	PINCNTL240	(	CTRL_MODULE_BASE_ADDR +	0x0BBC	)
#define	PINCNTL241	(	CTRL_MODULE_BASE_ADDR +	0x0BC0	)
#define	PINCNTL242	(	CTRL_MODULE_BASE_ADDR +	0x0BC4	)
#define	PINCNTL243	(	CTRL_MODULE_BASE_ADDR +	0x0BC8	)
#define	PINCNTL244	(	CTRL_MODULE_BASE_ADDR +	0x0BCC	)
#define	PINCNTL245	(	CTRL_MODULE_BASE_ADDR +	0x0BD0	)
#define	PINCNTL246	(	CTRL_MODULE_BASE_ADDR +	0x0BD4	)
#define	PINCNTL247	(	CTRL_MODULE_BASE_ADDR +	0x0BD8	)
#define	PINCNTL248	(	CTRL_MODULE_BASE_ADDR +	0x0BDC	)
#define	PINCNTL249	(	CTRL_MODULE_BASE_ADDR +	0x0BE0	)
#define	PINCNTL250	(	CTRL_MODULE_BASE_ADDR +	0x0BE4	)
#define	PINCNTL251	(	CTRL_MODULE_BASE_ADDR +	0x0BE8	)
#define	PINCNTL252	(	CTRL_MODULE_BASE_ADDR +	0x0BEC	)
#define	PINCNTL253	(	CTRL_MODULE_BASE_ADDR +	0x0BF0	)
#define	PINCNTL254	(	CTRL_MODULE_BASE_ADDR +	0x0BF4	)
#define	PINCNTL255	(	CTRL_MODULE_BASE_ADDR +	0x0BF8	)
#define	PINCNTL256	(	CTRL_MODULE_BASE_ADDR +	0x0BFC	)
#define	PINCNTL257	(	CTRL_MODULE_BASE_ADDR +	0x0C00	)
#define	PINCNTL258	(	CTRL_MODULE_BASE_ADDR +	0x0C04	)
#define	PINCNTL259	(	CTRL_MODULE_BASE_ADDR +	0x0C08	)
#define	PINCNTL260	(	CTRL_MODULE_BASE_ADDR +	0x0C0C	)
#define	PINCNTL261	(	CTRL_MODULE_BASE_ADDR +	0x0C10	)
#define	PINCNTL262	(	CTRL_MODULE_BASE_ADDR +	0x0C14	)
#define	PINCNTL263	(	CTRL_MODULE_BASE_ADDR +	0x0C18	)
#define	PINCNTL264	(	CTRL_MODULE_BASE_ADDR +	0x0C1C	)
#define	PINCNTL265	(	CTRL_MODULE_BASE_ADDR +	0x0C20	)
#define	PINCNTL266	(	CTRL_MODULE_BASE_ADDR +	0x0C24	)
#define	PINCNTL267	(	CTRL_MODULE_BASE_ADDR +	0x0C28	)
#define	PINCNTL268	(	CTRL_MODULE_BASE_ADDR +	0x0C2C	)
#define	PINCNTL269	(	CTRL_MODULE_BASE_ADDR +	0x0C30	)
#define	PINCNTL270	(	CTRL_MODULE_BASE_ADDR +	0x0C34	)
#define	PINCNTL271	(	CTRL_MODULE_BASE_ADDR +	0x0C38	)
 

/****************** PLL Configuration ******************************************/

    /***    PLL,Control Base Adress q Base Address   ***********/
    #define PLL_BASE_ADDRESS         0x481C5000 
    #define CONTROL_BASE_ADDRESS     0x48140000
    #define OSC_SRC_CTRL            (PLL_BASE_ADDRESS+0x02c0)
    #define ARM_SRC_CLK             (PLL_BASE_ADDRESS+0x02c4)
   
    /***    Top Level ADPLLJ  Base Address   ***********/
    #define L3_PLL_BASE             (PLL_BASE_ADDRESS+0x110)
    #define HDVICP_PLL_BASE            (PLL_BASE_ADDRESS+0x0E0)
    #define DSS_PLL_BASE            (PLL_BASE_ADDRESS+0x170)
    #define SGX_PLL_BASE            (PLL_BASE_ADDRESS+0x0B0)
    #define DSP_PLL_BASE            (PLL_BASE_ADDRESS+0x080)
    #define USB_PLL_BASE            (PLL_BASE_ADDRESS+0x260)
    #define AUDIO_PLL_BASE          (PLL_BASE_ADDRESS+0x230)
    #define VIDEO_0_PLL_BASE        (PLL_BASE_ADDRESS+0x1A0)
    #define VIDEO_1_PLL_BASE        (PLL_BASE_ADDRESS+0x1D0)
    #define HDMI_PLL_BASE           (PLL_BASE_ADDRESS+0x200)
    #define DDR_PLL_BASE            (PLL_BASE_ADDRESS+0x290)
	
	/********** ADPLL intrnal Offset Registers  ***********/
    #define CLKCTRL 				0x4
    #define TENABLE 				0x8
    #define TENABLEDIV 				0xC
    #define M2NDIV  				0x10
    #define MN2DIV 				    0x14
    #define STATUS 				    0x24

	/*********** A8 ADPLLS REGISTERS  *********/
	#define A8PLL_CLKCTRL		(PLL_BASE_ADDRESS+0x04c) 
    #define A8PLL_TENABLE		(PLL_BASE_ADDRESS+0x050) 
    #define A8PLL_TENABLEDIV    (PLL_BASE_ADDRESS+0x054)	
    #define A8PLL_M2NDIV    	(PLL_BASE_ADDRESS+0x058) 
    #define A8PLL_MN2DIV    	(PLL_BASE_ADDRESS+0x05c) 
    #define A8PLL_STATUS		(PLL_BASE_ADDRESS+0x06c) 
	
   /********   SATA PLL REGISTERS   **************/
    #define SATA_PLLCFG0            (CONTROL_BASE_ADDRESS+0x720) 
    #define SATA_PLLCFG1            (CONTROL_BASE_ADDRESS+0x724) 
    #define SATA_PLLCFG2            (CONTROL_BASE_ADDRESS+0x728) 
    #define SATA_PLLCFG3            (CONTROL_BASE_ADDRESS+0x72c) 
    #define SATA_PLLCFG4            (CONTROL_BASE_ADDRESS+0x730) 
    #define SATA_PLLSTATUS          (CONTROL_BASE_ADDRESS+0x734)
    #define SATA_RXSTATUS           (CONTROL_BASE_ADDRESS+0x738)
    #define SATA_TXSTATUS           (CONTROL_BASE_ADDRESS+0x73c)
 
   /********   PCIE PLL REGISTERS   **************/
    #define PCIE_PLLCFG0            (CONTROL_BASE_ADDRESS+0x6D8) 
    #define PCIE_PLLCFG1            (CONTROL_BASE_ADDRESS+0x6DC) 
    #define PCIE_PLLCFG2            (CONTROL_BASE_ADDRESS+0x6E0) 
    #define PCIE_PLLCFG3            (CONTROL_BASE_ADDRESS+0x6E4) 
    #define PCIE_PLLCFG4            (CONTROL_BASE_ADDRESS+0x6E8) 
    #define PCIE_PLLSTATUS          (CONTROL_BASE_ADDRESS+0x6EC)
    #define PCIE_RXSTATUS           (CONTROL_BASE_ADDRESS+0x6F0)
    #define PCIE_TXSTATUS           (CONTROL_BASE_ADDRESS+0x6F4)
    #define SERDES_REFCLK_CTL 	    (CONTROL_BASE_ADDRESS+0xE24)


    #define CONTROL_STATUS              (CTRL_MODULE_BASE_ADDR + 0x040)
	#define BANDGAP0_TRIM       (CTRL_MODULE_BASE_ADDR + 0x44C)
	#define BANDGAP1_TRIM       (CTRL_MODULE_BASE_ADDR + 0x454)
	#define PLL_SUBSYSTEM_BASE_ADDR       PLL_BASE_ADDRESS
	#define DSPPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x084)
	#define SGXPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x0B4)
	#define HDVICPPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x0E4)
	#define L3PLL_CLOCK_CONTROL        (PLL_SUBSYSTEM_BASE_ADDR + 0x114)
	#define DSSPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x174)
	#define VID0PLL_CLOCK_CONTROL      (PLL_SUBSYSTEM_BASE_ADDR + 0x1A4)
	#define VID1PLL_CLOCK_CONTROL      (PLL_SUBSYSTEM_BASE_ADDR + 0x1D4)
	#define HDMIPLL_CLOCK_CONTROL      (PLL_SUBSYSTEM_BASE_ADDR + 0x204)
	#define AUDIOPLL_CLOCK_CONTROL     (PLL_SUBSYSTEM_BASE_ADDR + 0x234)
	#define USBPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x264)
	#define DDRPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x294)
	#define A8PLL_CLOCK_CONTROL     (PLL_SUBSYSTEM_BASE_ADDR + 0x04C)


/*************************************************************************************************************
      						     ADPLLJ CLKCNTRL REGISTER CONFIGURATIONS
      						     
***************************************************************************************************************/      
	// ADPLLJ_CLKCRTL_Register Value Configurations
	//add ntrim values for test device  --- Rajesh/Hemanth(bits 28:24)
	#define ADPLLJ_CLKCRTL_HS2       0x00000801 //HS2 Mode,TINTZ =1  --used by all PLL's except HDMI 
	#define ADPLLJ_CLKCRTL_HS1       0x00001001 //HS1 Mode,TINTZ =1  --used only for HDMI 
	#define ADPLLJ_CLKCRTL_CLKDCO    0x200a0000 // Enable CLKDCOEN,CLKLDOEN,CLKDCOPWDNZ -- used for HDMI,USB


/****************************************************************************************************************/
   // CONTROL MMMR LOCK and UNLOCK Registers
   
	#define control_pllss_mmr_lock                     0x481C5040
	#define control_mmr_lock0                          0x48140060
	#define control_mmr_lock1                          0x48140064
	#define control_mmr_lock2                          0x48140068
	#define control_mmr_lock3                          0x4814006c
	#define control_mmr_lock4                          0x48140070
	
	#define control_pllss_mmr_lock_unlock_val          0x1EDA4C3D
	#define control_mmr_lock0_unlock_val               0x2FF1AC2B
	#define control_mmr_lock1_unlock_val               0xF757FDC0
	#define control_mmr_lock2_unlock_val               0xE2BC3A6D
	#define control_mmr_lock3_unlock_val               0x1EBF131D
	#define control_mmr_lock4_unlock_val               0x6F361E05
	

/****************************************************************************************************************/

/*******************************************************************************************************                               
    ****                               
    ****                                   ********* RANGE ************             
    ****   REF_CLK       = (OSC_FREQ)/N+1  [  REF_CLK < 2.5MHz      ] 
    ****   DCOCLK_HS2    = (REF_CLK)*M     [500  < DCOCLK < 1000MHz ] 
    ****   DCOCLK_HS1    = (REF_CLK)*M     [1000 < DCOCLK < 2000MHz ]--used for HDMI CLKDCO    
    ****   CLKOUT        =  DCOCLK/M2      [10   < CLKOUT < 2000MHz ]
    ****   N+1 			           		   [1..256]
    ****   M    		           		   [2..4095]
    ****   M2    		           		   [1..127]
    ****
    ****
	******************************************************************************************************/

/***************************************************************

 **** PLEASE DONT CHANGE THE BELOW CONFIGURED VALUES OF PLL_SETUP *****

   IF NOT required do not call ALL_ADPLL_CLOCKS_ENABLE function(hotmenu) 

***************************************************************/

int HSMODE,CLKOUT = 0;

PLL_SETUP(){
	   //pll_name (CLKINP,N , M, M2);
		cmdMPUPLL(CLKIN,1, 60 ,1);
		 
		cmdL3PLL(CLKIN,19,800,4);
		 
		cmdDSPPLL(CLKIN,19, 500, 1);
		 
		cmdDSSPLL(CLKIN,19, 800, 4);
 
		cmdHDVICPPLL(CLKIN,19, 532, 2);
		 
		cmdSGXPLL(CLKIN,19, 800, 4);
		 
		cmdUSBPLL(CLKIN,19,960,5);
		 
        cmdVIDEO0PLL(CLKIN,19, 540,10);
		 
	    cmdVIDEO1PLL(CLKIN,19, 594,4);
		 
	   	cmdHDMIPLL(CLKIN,19, 1485,10);
		 
//	    cmdDDRPLL(CLKIN,19,DDR_FREQ, 2); //DDR PLL config now done as a part of DDR hotmenus
	   
	   	cmdAUDIOPLL(CLKIN,19,800,4);

	   //cmdSATAPLL();

	   //cmdPCIEPLL();
 
}

 cmdMPUPLL(int CLKIN,int N, int M, int M2)
	{
	    A8_PLL_Config(CLKIN,N,M,M2);
	      GEL_TextOut("\t A8 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
	}
	
  cmdL3PLL(int CLKIN,int N, int M, int M2)
  	{
  	    DCOCLK_COMP(CLKIN,N,M);
  	    if(HSMODE == 2){ 
		PLL_Clocks_Config(L3_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	           GEL_TextOut("\t L3  ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else if (HSMODE == 1){
	      PLL_Clocks_Config(L3_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	           GEL_TextOut("\t L3  ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
	    }
	    else {
			   GEL_TextOut("\t L3 PLL NOT Configured.Wrong DCOCLK Output\n");
		}

	}
 cmdDSPPLL(int CLKIN,int N, int M, int M2)
	{
		DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(DSP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	           GEL_TextOut("\t DSP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(DSP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	          GEL_TextOut("\t DSP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else{
			      GEL_TextOut("\t DSP PLL NOT Configured.Wrong DCOCLK Output\n");
	    }

	}
 cmdDSSPLL(int CLKIN, int N, int M, int M2)
	{
	    DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(DSS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	           GEL_TextOut("\t DSS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(DSS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	           GEL_TextOut("\t DSS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t DSS PLL NOT Configured.Wrong DCOCLK Output\n");
	    }

	}
	
cmdSGXPLL(int CLKIN, int N, int M, int M2)
{
 		DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(SGX_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	  		   GEL_TextOut("\t SGX ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(SGX_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	         GEL_TextOut("\t SGX ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t SGX PLL NOT Configured.Wrong DCOCLK Output\n");
	    }
	
}
 cmdHDVICPPLL(int CLKIN,int N, int M, int M2)
{
	    DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(HDVICP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	         GEL_TextOut("\t HDVICP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(HDVICP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	         GEL_TextOut("\t HDVICP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t HDVICP PLL NOT Configured.Wrong DCOCLK Output\n");
	    }

}

// enabling the CLKOUTDCO,CLKDCOLDO
  cmdUSBPLL(int CLKIN,int N, int M, int M2)
{
		DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(USB_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2+ADPLLJ_CLKCRTL_CLKDCO); 
	         GEL_TextOut("\t USB ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(USB_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1+ADPLLJ_CLKCRTL_CLKDCO); 
	         GEL_TextOut("\t USB ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t USB PLL NOT Configured.Wrong DCOCLK Output\n");
	    }

}
  cmdVIDEO0PLL(int CLKIN,int N, int M, int M2)
{
		DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(VIDEO_0_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	         GEL_TextOut("\t VIDEO-0 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(VIDEO_0_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	         GEL_TextOut("\t VIDEO-0 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t VIDEO-0 PLL NOT Configured.Wrong DCOCLK Output\n");
	    }

	
}
  cmdVIDEO1PLL(int CLKIN,int N, int M, int M2)
{
		DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(VIDEO_1_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	         GEL_TextOut("\t VIDEO-1 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(VIDEO_1_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	         GEL_TextOut("\t VIDEO-1 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t VIDEO-1 PLL NOT Configured.Wrong DCOCLK Output\n");
	    }

}

  cmdHDMIPLL(int CLKIN,int N, int M, int M2)
{
		DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(HDMI_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2+ADPLLJ_CLKCRTL_CLKDCO); 
	         GEL_TextOut("\t VIDEO-2/HDMI ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(HDMI_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1+ADPLLJ_CLKCRTL_CLKDCO); 
	         GEL_TextOut("\t VIDEO-2/HDMI ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t VIDEO-2/HDMI PLL NOT Configured.Wrong DCOCLK Output\n");
	    }
	
}
  cmdDDRPLL(int CLKIN,int N, int M, int M2)
{
		DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(DDR_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	         GEL_TextOut("\t DDR ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(DDR_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	         GEL_TextOut("\t DDR ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t DDR PLL NOT Configured.Wrong DCOCLK Output\n");
	    }

	
}
  cmdAUDIOPLL(int CLKIN,int N, int M, int M2)
{
		DCOCLK_COMP(CLKIN,N,M);
		if(HSMODE == 2){  
			PLL_Clocks_Config(AUDIO_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2); 
	         GEL_TextOut("\t AUDIO ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
		}
	    else if (HSMODE == 1){
			PLL_Clocks_Config(AUDIO_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1); 
	         GEL_TextOut("\t AUDIO ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
	    else {
			      GEL_TextOut("\t AUDIO PLL NOT Configured.Wrong DCOCLK Output\n");
	    }

}
 menuitem "DM8148 INDIVIDUAL PLL Config"

int CLKIN =	20; 

//cmdxxxxPLL(int CLKIN,int N, int M, int M2)
hotmenu	MPU_PLL_CONFIG()
{
		GEL_TextOut("\t ****  DM8148 MPU ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
		cmdMPUPLL(CLKIN,1,60,1);
	
}

hotmenu L3_PLL_Config()
{
		GEL_TextOut("\t ****  DM8148 L3 ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
		cmdL3PLL(CLKIN,19, 800, 4);
		//GEL_TextOut("\t ****  DM8148 L3 ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu DSS_PLL_Config()
{
		 GEL_TextOut("\t ****  DM8148 DSS ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
  		 cmdDSSPLL(CLKIN,19, 600, 4);
  		 //GEL_TextOut("\t ****  DM8148 DSS ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu SGX_PLL_Config(){
		GEL_TextOut("\t ****  DM8148 SGX ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
		cmdSGXPLL(CLKIN,19, 800, 4);
		//GEL_TextOut("\t ****  DM8148 SGX ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu HDVICP_PLL_Config()
{
		GEL_TextOut("\t ****  DM8148 HDVICP ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdHDVICPPLL(CLKIN,19, 532, 2);
        //GEL_TextOut("\t ****  DM8148 HDVICP ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu USB_PLL_Config()
{
		GEL_TextOut("\t ****  DM8148 USB ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
		cmdUSBPLL(CLKIN,19, 960 ,5);
		//GEL_TextOut("\t ****  DM8148 USB ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu VIDEO_0_PLL_Config()
{
	GEL_TextOut("\t ****  DM8148 VIDEO-0 ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
	cmdVIDEO0PLL(CLKIN,19, 540,10);
	//GEL_TextOut("\t ****  DM8148 VIDEO-0 ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu VIDEO_1_PLL_Config()
{
	GEL_TextOut("\t ****  DM8148 VIDEO-1 ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
	cmdVIDEO1PLL(CLKIN,19, 600,4);
	//GEL_TextOut("\t ****  DM8148 VIDEO-1 ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu HDMI_PLL_Config()
{
	GEL_TextOut("\t ****  DM8148 HDMI ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
	cmdHDMIPLL(CLKIN,19, 1485,10);
	//GEL_TextOut("\t ****  DM8148 HDMI ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu AUDIO_PLL_Config()
{
	GEL_TextOut("\t ****  DM8148 AUDIO ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
   cmdAUDIOPLL(CLKIN,19,800,4);
   //GEL_TextOut("\t ****  DM8148 AUDIO ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu DDR_PLL_Config()
{
	GEL_TextOut("\t ****  DM8148 DDR ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
   cmdDDRPLL(CLKIN,19,DDR_FREQ, 2);
   //GEL_TextOut("\t ****  DM8148 DDR ADPLL INIT IS Done ......... \n","Output",1,1,1);
}
hotmenu SATA_PLL_Config()
{
	GEL_TextOut("\t ****  DM8148 SATA PLL INIT IS In Progress ......... \n","Output",1,1,1);	
	cmdSATAPLL();
	GEL_TextOut("\t ****  DM8148 SATA PLL INIT IS DONE  ********* \n","Output",1,1,1);	
	
}

hotmenu PCIE_PLL_Config(){
	GEL_TextOut("\t ****  DM8148 PCIE PLL INIT IS In Progress ......... \n","Output",1,1,1);
    cmdPCIEPLL();
	GEL_TextOut("\t ****  DM8148 PCIE PLL INIT IS DONE  ********* \n","Output",1,1,1);	
	    
}

#define CM_SYSCLK18_CLKSRC				(CTRL_MODULE_BASE_ADDR + 0x020F)
#define CM_SYSCLK18_CLKSEL				(PRCM_BASE_ADDR + 0x0378)
#define CM_DMTIMER_CLKSRC				(CTRL_MODULE_BASE_ADDR + 0x02E0)

hotmenu TIMER_CLOCKS_Config()
{
	GEL_TextOut("\t ***** Initializing Timer-6....***** \n");
	
	WR_MEM_32(CM_SYSCLK18_CLKSEL, 0x1);
	WR_MEM_32(CM_SYSCLK18_CLKSRC, 0x1); /* Set clksrc to 32.768 MHz, Lock Bit? */

	WR_MEM_32(CM_DMTIMER_CLKSRC, RD_MEM_32(CM_DMTIMER_CLKSRC) & 0xFE3FFFFF); /* Selected sysclk18 */
	
	WR_MEM_32(CM_TIMER6_CLKSEL, 0x1);

	WR_MEM_32(CM_ALWON_TIMER_6_CLKCTRL,    0x2); /* Enable Timer-6 Clock */
	while((RD_MEM_32(CM_ALWON_TIMER_6_CLKCTRL) & 0x0F) !=0x2);		/* Poll for Module is functional */
	
	WR_MEM_32(PINCNTL115, 0x00010040);
	GEL_TextOut("\t ***** Timer-6 Initialized....***** \n");
}

//PLL program sequence to get 125Mhz ethernet clockout.
cmdSATAPLL()
{
  GEL_TextOut("\t **** SATA PLL INIT IS In Progress Please wait ..... \n","Output",1,1,1);
  WR_MEM_32(SATA_PLLCFG0, 0x00000004);	//cfgpll0
  wait_delay(35);
  WR_MEM_32(SATA_PLLCFG1, 0xC12C003C);	//cfgpll1
  WR_MEM_32(SATA_PLLCFG3, 0x004008E0);	//cfgpll3
  wait_delay(850);
   //wait for bias to be stable --50us
  WR_MEM_32(SATA_PLLCFG0, 0x00000014);	//cfgpll0
  wait_delay(850);
  WR_MEM_32(SATA_PLLCFG0, 0x00000016);	//cfgpll0
  wait_delay(60);
  WR_MEM_32(SATA_PLLCFG0, 0xC0000016);	//cfgpll0 -----why 2 times???????
  wait_delay(2000);
  WR_MEM_32(SATA_PLLCFG0, 0xC0000017);	//cfgpll0
 //poll the status field to check if pll lock occured.
  while ((RD_MEM_32(SATA_PLLSTATUS) & 0x1) != 0x1);
  GEL_TextOut("\t **** SATA PLL INIT IS In DONE ***************** \n","Output",1,1,1);

}


//PLL program sequence to get 125Mhz ethernet clockout.
hotmenu cmdSATAPLL_Debug()
{
  GEL_TextOut("\t **** SATA PLL INIT IS In Progress Please wait ..... \n","Output",1,1,1);
  //WR_MEM_32(SATA_PLLCFG0, 0x00000004);	//cfgpll0
  //wait_delay(35);
  WR_MEM_32(SATA_PLLCFG1, 0xC12C003C);	//cfgpll1
  wait_delay(35);
  WR_MEM_32(SATA_PLLCFG3, 0x004008E0);	//cfgpll3
  wait_delay(850);
   //wait for bias to be stable --50us
  WR_MEM_32(SATA_PLLCFG0, 0x00000004);	//cfgpll0
  wait_delay(850);
  WR_MEM_32(SATA_PLLCFG0, 0x00000014);	//cfgpll0
  wait_delay(850);
  WR_MEM_32(SATA_PLLCFG0, 0xC0000016);	//cfgpll0 -----why 2 times???????
  wait_delay(850);
  WR_MEM_32(SATA_PLLCFG0, 0xC0000017);	//cfgpll0
 //poll the status field to check if pll lock occured.
  while ((RD_MEM_32(SATA_PLLSTATUS) & 0x1) != 0x1);
  GEL_TextOut("\t **** SATA PLL INIT IS In DONE ***************** \n","Output",1,1,1);

}


//pci express pll sequence
cmdPCIEPLL(){
    GEL_TextOut("\t **** PCIE PLL INIT IS In Progress Please wait ..... \n","Output",1,1,1);
    WR_MEM_32(SERDES_REFCLK_CTL,0x00000002); //PowerDown 0x00000000-DM81481
    WR_MEM_32(PCIE_PLLCFG0,0x00000000); //cfgpll0
    WR_MEM_32(PCIE_PLLCFG1,0x00640000); //cfgpll1
    WR_MEM_32(PCIE_PLLCFG2,0x00000000); //cfgpll2
    WR_MEM_32(PCIE_PLLCFG3,0x004008E0); //cfgpll3
    WR_MEM_32(PCIE_PLLCFG4,0x0000609C); //cfgpll4
    
	//WR_MEM_32(0x48141318,0x00000E7B); //pcie_serdes_cfg_misc DM8148 commented
    wait_delay(3); // Wait 100 ns
    WR_MEM_32(PCIE_PLLCFG0,0x00000004); //Config PLL CFG0 bit [2] - ENBGSC_REF
    wait_delay(3); // Wait 250 ns
    WR_MEM_32(PCIE_PLLCFG0,0x00000014); //Config PLL CFG0 bit [4] - DIGLDO
    wait_delay(3); // Wait 200 ns
    WR_MEM_32(PCIE_PLLCFG0,0x00000016); //Config PLL CFG0 bit [1] - ENPLLLDO
    wait_delay(3); // Wait 200 ns
    WR_MEM_32(PCIE_PLLCFG0,0x30000016); // Configure proxy TXLDO and RXLDO enables (DM8148 ECO 3/30/10)
    wait_delay(3); // Wait 200 ns
    WR_MEM_32(PCIE_PLLCFG0,0x70007016); // Configure multiplier
    wait_delay(3); // Wait 200 ns
    WR_MEM_32(PCIE_PLLCFG0,0x70007017);  // Enable PLL
	wait_delay(3); // Wait 200 ns
     //poll the status field to check if pll lock occured.
    while ((RD_MEM_32(PCIE_PLLSTATUS) & 0x1 )!= 0x1);
    GEL_TextOut("\t **** PCIE PLL INIT IS In DONE ***************** \n","Output",1,1,1);
}

wait_delay(UWORD32 noopcount)
 {
 int i;
  for(i=0;i<noopcount;i++)
  {
  }
 }
 

PLL_Clocks_Config(UWORD32 Base_Address,UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2,UWORD32 CLKCTRL_VAL)
{
    UWORD32 m2nval,mn2val,read_clkctrl,clk_out,ref_clk,clkout_dco = 0;
    m2nval = (M2<<16) | N;
    mn2val =  M;
	ref_clk     = CLKIN/(N+1);
    clkout_dco  = ref_clk*M;
    clk_out     = clkout_dco/M2;
    WR_MEM_32(Base_Address+CLKCTRL, RD_MEM_32(Base_Address+CLKCTRL)|0x00800000);
	while (( (RD_MEM_32(Base_Address+STATUS)) & 0x00000101) != 0x00000101);
    WR_MEM_32(Base_Address+CLKCTRL, RD_MEM_32(Base_Address+CLKCTRL)& 0xfffffffe);
	wait_delay(3);
	WR_MEM_32((Base_Address+M2NDIV    ),m2nval);
	WR_MEM_32((Base_Address+MN2DIV    ),mn2val);
	wait_delay(3);
	WR_MEM_32((Base_Address+TENABLEDIV),0x1);
	wait_delay(3);
	WR_MEM_32((Base_Address+TENABLEDIV),0x0);
	wait_delay(3);
	WR_MEM_32((Base_Address+TENABLE   ),0x1);
	wait_delay(3);
	WR_MEM_32((Base_Address+TENABLE   ),0x0);
	wait_delay(3);
	read_clkctrl = RD_MEM_32(Base_Address+CLKCTRL);
	//configure the TINITZ(bit0) and CLKDCO BITS IF REQUIRED
	WR_MEM_32(Base_Address+CLKCTRL,(read_clkctrl & 0xff7fe3ff) | CLKCTRL_VAL);
	read_clkctrl = RD_MEM_32(Base_Address+CLKCTRL);
	// poll for the freq,phase lock to occur
	while (( (RD_MEM_32(Base_Address+STATUS)) & 0x00000600) != 0x00000600);
	//wait fot the clocks to get stabized
	wait_delay(10);
    CLKOUT    = clk_out;
}




 A8_PLL_Config(UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2)
{
    UWORD32 rval_ctrl,ref_clk,clk_out = 0;
    UWORD32 m2nval,mn2val = 0;
	ref_clk     = CLKIN/(N+1);
    clk_out     = (ref_clk*M)/M2;

	m2nval = (M2<<16) | N; //need to check the bit position of M2
    mn2val =  M;
    WR_MEM_32(A8PLL_M2NDIV      ,m2nval);         
    WR_MEM_32(A8PLL_MN2DIV      ,mn2val);        
	WR_MEM_32(A8PLL_TENABLEDIV  ,0x1);  
	wait_delay(3);
    WR_MEM_32(A8PLL_TENABLEDIV  ,0x0);
	wait_delay(3);
    WR_MEM_32(A8PLL_TENABLE     ,0x1);
	wait_delay(3);
    WR_MEM_32(A8PLL_TENABLE     ,0x0);
	wait_delay(3);
    rval_ctrl = RD_MEM_32(A8PLL_CLKCTRL);
    WR_MEM_32(A8PLL_CLKCTRL,(rval_ctrl & 0xff7fffff) | 0x1);
    while (( (RD_MEM_32(A8PLL_STATUS)) & 0x00000600) != 0x00000600);
	wait_delay(10);
	CLKOUT = clk_out;
	
}

 DCOCLK_COMP(int CLKIN,int N, int M)
 {
	 	int DCOCLK;
		DCOCLK = (CLKIN/(N+1))*M;
		
		if(DCOCLK >= 500 && DCOCLK < 1000){
				HSMODE = 2;  //HS2 Mode 
		}
		else if(DCOCLK >= 1000 && DCOCLK < 2000){
				HSMODE = 1;  //HS1 Mode
		}
		else HSMODE = 0;  //wrong configuration
		
		//return HSMODE;
 }


	  ControlModule_ClkEnable()
	{
		GEL_TextOut("\tPRCM for Control Module in Progress \n","Output",1,1,1);	 									
		/*Enable the  Clocks*/
		WR_MEM_32(CM_CTRL_CLKCTRL,   2);
		while(((RD_MEM_32(CM_CTRL_CLKCTRL)&0x2))!=0x2);	
	    GEL_TextOut("\tPRCM for Control Module Done \n","Output",1,1,1);	 									
	}

	  PrcmAlwayOnClkEnable()
	{
		unsigned int fail=0, k=0;
		GEL_TextOut("\tPRCM for OCMCRAM0/1 Initialization in Progress \n","Output",1,1,1);	 									
		/*Enable the OCMC0RAM Clocks*/
		WR_MEM_32(CM_ALWON_OCMC_0_CLKSTCTRL, 2);
		WR_MEM_32(CM_ALWON_OCMC_0_CLKCTRL,   2);
		while(((RD_MEM_32(CM_ALWON_OCMC_0_CLKSTCTRL) & 0x100)>>8)!=1);
		while(((RD_MEM_32(CM_ALWON_OCMC_0_CLKCTRL)&0x30000)>>17)!=0);
	    GEL_TextOut("\tPRCM for OCMCRAM0 Initialization Done \n","Output",1,1,1);	 									
	
	
		/*for(k=0; k<SIZE; k++) {
		  WR_MEM_32(OCMC0RAM_BASE_ADDR+4*k, 0x12345678+k);
		  }	
	    for(k=0;  k<SIZE; k++) {
	      if(RD_MEM_32(OCMC0RAM_BASE_ADDR+4*k) != (0x12345678+k) ) {
		    fail++;
		    }
		  }
	
	    if(fail!=0) {
		   GEL_TextOut("\tOCMCRAM0 Accesses FAILED \n","Output",1,1,1);	 										
		   }
	
		GEL_TextOut("\tOCMCRAM0 Accesses PASSED \n","Output",1,1,1);	 										
	*/
	}



	  HDVICPClkEnable()
	{
	GEL_TextOut("\tPRCM for HDVICP is in Progress, Please wait.....  \n","Output",1,1,1);	 									
	WR_MEM_32(CM_HDVICP_CLKSTCTRL, 		2); /*Enable Power Domain Transition*/
	while(RD_MEM_32(PM_HDVICP_PWRSTST)!=0x37);	/*Check Power is ON*/
	WR_MEM_32(CM_HDVICP_CLKCTRL, 	2); /*Enable HDVICP Clocks*/
	WR_MEM_32(CM_HDVICP_SL2_CLKCTRL, 	2); /*Enable HDVICP SL2 Clocks*/

	while(((RD_MEM_32(CM_HDVICP_CLKSTCTRL)&0x100))!=0x100); /*HDVICP_GCLK is Active*/

	WR_MEM_32(RM_HDVICP_RSTCTRL, 	3); /*Enable HDVICP logic & SL2 */

	while((RD_MEM_32(RM_HDVICP_RSTST)&4)!=4);

	WR_MEM_32(0x58088000, 0xEAFFFFFE); /*Write Self Branch Instruction in ICONT1 ITCM 0 Location*/

	WR_MEM_32(0x58098000, 0xEAFFFFFE); /*Write Self Branch Instruction in ICONT2 ITCM 0 Location*/

	WR_MEM_32(RM_HDVICP_RSTCTRL, 	0); /*Bring ICONT1 & ICONT2 out of Reset*/
	
	while(RD_MEM_32(RM_HDVICP_RSTST)!=7); /*ICONT1 & ICONT2 are out of Reset*/

    GEL_TextOut("\tPRCM for HDVICP is Done Successfully  \n","Output",1,1,1);	 									
    GEL_TextOut("\tUser Can Connect to ICONT1 & ICONT2 of HDVICP  \n","Output",1,1,1);	 									
}

  C674xClkEnable()
{
	unsigned int i=0, k=0, fail=0;

	GEL_TextOut("\tPRCM for C674x is in Progress, Please wait.....  \n","Output",1,1,1);	 									

	/*Cortex A8 must be in Supervisor Mode to Access the following two registers*/
	WR_MEM_32(DSPBOOTADDR, 		    0x00800000); /*DSPBOOT ADDRESS*/
	
	GEL_TextOut("\t CP0...Done \n");
	
	/*Enable Clock to MMU CFG*/
	WR_MEM_32(CM_MMUCFG_CLKSTCTRL, 		2); 
	WR_MEM_32(CM_ALWON_MMUCFG_CLKCTRL, 		2); 
	while(((RD_MEM_32(CM_ALWON_MMUCFG_CLKCTRL)&0x0))!=0x0); 
	while(((RD_MEM_32(CM_MMUCFG_CLKSTCTRL)&0x100))!=0x100); 

	GEL_TextOut("\t CP1...Done \n");

	/*Enable Clock to Data*/
	WR_MEM_32(CM_MMU_CLKSTCTRL, 		2); 
	WR_MEM_32(CM_ALWON_MMUDATA_CLKCTRL, 		2); 
	while(((RD_MEM_32(CM_ALWON_MMUDATA_CLKCTRL)&0x0))!=0x0); 
	while(((RD_MEM_32(CM_MMU_CLKSTCTRL)&0x100))!=0x100); 

	GEL_TextOut("\t CP2...Done \n");

    /*Enable Clock to C674x*/
	WR_MEM_32(CM_C674x_CLKSTCTRL, 		2); /*Enable Power Domain Transition*/
	while(RD_MEM_32(PM_ACTIVE_PWRSTST)!=0x37);	/*Check Power is ON*/
	WR_MEM_32(CM_ACTIVE_C674x_CLKCTRL, 	2); /*Enable C674x Clocks*/

	GEL_TextOut("\t CP3...Done \n");

	while(((RD_MEM_32(CM_C674x_CLKSTCTRL)&0x700))!=0x700); /*C674x Clocks are Active*/

	WR_MEM_32(RM_ACTIVE_RSTCTRL, 	1); /*Issue C674x Warm Reset To access C674x memories */

    while(((RD_MEM_32(RM_ACTIVE_RSTST)&0x2))!=0x2); /*C674x Warm Reset has been Asserted*/

	GEL_TextOut("\t CP4...Done \n");

    for(i=0; i<8; i++) {
	  WR_MEM_32((C674x_L2RAM_BASE_ADDR+4*i), 0x12); /*Write Self Branch Instruction*/
    }

	GEL_TextOut("\t CP5...Done \n");

	WR_MEM_32(RM_ACTIVE_RSTCTRL, 	0); /*Bring C674x Core out of Reset*/
	
    while(((RD_MEM_32(RM_ACTIVE_RSTST)&0x3))!=0x3); /*C674x core core is out of Reset*/

	GEL_TextOut("\t CP6...Done \n");

	/*for(k=0; k<SIZE; k++) {
	  WR_MEM_32(C674x_L2RAM_BASE_ADDR+0x100+4*k, 0x12345678+k);
	  }

	GEL_TextOut("\t CP7...Done");

    for(k=0;  k<SIZE; k++) {
      if(RD_MEM_32(C674x_L2RAM_BASE_ADDR+0x100+4*k) != (0x12345678+k) ) {
	    fail++;
	    }
	  }
    if(fail!=0) {
	GEL_TextOut("\tC674x L2 RAM Accesses are FAILED \n","Output",1,1,1);	 										
    GEL_TextOut("\tPRCM for C674x is Failed  \n","Output",1,1,1);	 									
    GEL_TextOut("\tDebug the Failed Scenario   \n","Output",1,1,1);	 									
	   }

	GEL_TextOut("\tC674x L2 RAM Accesses are PASSED \n","Output",1,1,1);	 										
    GEL_TextOut("\tPRCM for C674x is Done Successfully  \n","Output",1,1,1);	 									
  */  
  GEL_TextOut("\tUser Can Connect to C674x   \n","Output",1,1,1);	
  GEL_TextOut("\tPRCM for C674x is DONE ******  \n","Output",1,1,1); 									
}


  GPMC_ClkEnable()
{
	unsigned int i,data_fail = 0;
	GEL_TextOut("\tEnabling Clock for GPMC is in Progress, Please wait.....  \n","Output",1,1,1);
	WR_MEM_32(CM_ALWON_GPMC_CLKCTRL,    0x2); /*Enable GPMC Clock*/
	while(RD_MEM_32(CM_ALWON_GPMC_CLKCTRL)!=0x2);
	GEL_TextOut("\tGPMC Clock is Active\n","Output",1,1,1);

}

hotmenu Ethernet_PinMux_Setup()
{
	GEL_TextOut("\t ***** Configuring ethernet Clk and Mux....***** \n");	 									
	/*
	PINCNTL232 :- rmii_refClk			[40001]
	PINCNTL233 :- rmdio_mclk			[A0001]
	PINCNTL234 :- mdio_d				[E0001]
	*/
	
	/* PIN MUX for EMAC0 */
	
	WR_MEM_32(PINCNTL232, 0x00040001);  
	WR_MEM_32(PINCNTL233, 0x000A0001);  
	WR_MEM_32(PINCNTL234, 0x000E0001);   
	
	WR_MEM_32(PINCNTL235, 0x000C0001);  
	WR_MEM_32(PINCNTL236, 0x000C0001);  
	WR_MEM_32(PINCNTL237, 0x000C0001); 
	WR_MEM_32(PINCNTL238, 0x000C0001);  
	WR_MEM_32(PINCNTL239, 0x00040001);  
	WR_MEM_32(PINCNTL240, 0x00040001); 
	WR_MEM_32(PINCNTL241, 0x00040001);  
	WR_MEM_32(PINCNTL242, 0x00040001);  
	WR_MEM_32(PINCNTL243, 0x00040001); 
	WR_MEM_32(PINCNTL244, 0x00040001);  
	WR_MEM_32(PINCNTL245, 0x00040001);  
	WR_MEM_32(PINCNTL246, 0x00040001); 
    WR_MEM_32(PINCNTL247, 0x00040001); 
	WR_MEM_32(PINCNTL248, 0x00040001);
	WR_MEM_32(PINCNTL249, 0x00000001);
	WR_MEM_32(PINCNTL250, 0x00000001);
	WR_MEM_32(PINCNTL251, 0x00000001);
	WR_MEM_32(PINCNTL252, 0x00000001);  	
	WR_MEM_32(PINCNTL253, 0x00000001);  	
	WR_MEM_32(PINCNTL254, 0x00000001);  	
	WR_MEM_32(PINCNTL255, 0x00000001); 
	WR_MEM_32(PINCNTL256, 0x00000001);  	
	WR_MEM_32(PINCNTL257, 0x00000001);  	
	WR_MEM_32(PINCNTL258, 0x00000001); 

	/* PIN MUX for EMAC1 */	
	WR_MEM_32(PINCNTL204, 0x000C0002);  
	WR_MEM_32(PINCNTL205, 0x000C0002);  
	WR_MEM_32(PINCNTL206, 0x000C0002); 
	WR_MEM_32(PINCNTL207, 0x000C0002);  
	WR_MEM_32(PINCNTL208, 0x00040002);  
	WR_MEM_32(PINCNTL209, 0x00040002); 
	WR_MEM_32(PINCNTL210, 0x00040002);  
	WR_MEM_32(PINCNTL211, 0x00040002);  
	WR_MEM_32(PINCNTL212, 0x00040002); 
	WR_MEM_32(PINCNTL213, 0x00040002);  
	WR_MEM_32(PINCNTL214, 0x00040002);  
	WR_MEM_32(PINCNTL215, 0x00040002); 
    WR_MEM_32(PINCNTL216, 0x00040002); 
	WR_MEM_32(PINCNTL217, 0x00040002);
	WR_MEM_32(PINCNTL218, 0x00000002);
	WR_MEM_32(PINCNTL219, 0x00000002);
	WR_MEM_32(PINCNTL220, 0x00000002);
	WR_MEM_32(PINCNTL221, 0x00000002);  	
	WR_MEM_32(PINCNTL222, 0x00000002);  	
	WR_MEM_32(PINCNTL223, 0x00000002);  	
	WR_MEM_32(PINCNTL224, 0x00000002); 
	WR_MEM_32(PINCNTL225, 0x00000002);  	
	WR_MEM_32(PINCNTL226, 0x00000002);  	
	WR_MEM_32(PINCNTL227, 0x00000002);  
	
	WR_MEM_32(MC_ALWON_ETHNET_CLKSTCTRL,    0x2); /* Enable Ethernet Clock*/
	while((RD_MEM_32(MC_ALWON_ETHNET_CLKSTCTRL) & 0x0F) !=0x2);		/*Poll for Module is functional*/
	
	WR_MEM_32(MC_ALWON_ETH_0_CLKSTCTRL,    0x2); /*Enable Ethernet Clock*/
	while((RD_MEM_32(MC_ALWON_ETH_0_CLKSTCTRL) & 0x0F) !=0x2);		/*Poll for Module is functional*/
	
	WR_MEM_32(MC_ALWON_ETH_1_CLKSTCTRL,    0x2); /*Enable Ethernet Clock*/
	while((RD_MEM_32(MC_ALWON_ETH_1_CLKSTCTRL) & 0x0F) !=0x2);		/*Poll for Module is functional*/

	while(RD_MEM_32(MC_ALWON_ETHNET_CLKSTCTRL)!=0x302);		/*Poll for Module is functional*/	
	
	GEL_TextOut("\t ***** GMII pin mux and Clk initialized....***** \n");	 									
}

hotmenu SPI_Setup()
{
	GEL_TextOut("\tPRCM for SPI-0 CS-0 is in Progress, Please wait.....  \n","Output",1,1,1);	 									
	
	WR_MEM_32(PINCNTL81, 0x00060001);  	/* SPI0-CS[0] */
	WR_MEM_32(PINCNTL82, 0x00060001);  	/* SPI0-SCLK */
	WR_MEM_32(PINCNTL83, 0x00060001);  	/* SPI0-D0 */
	WR_MEM_32(PINCNTL84, 0x00060001);  	/* SPI0-D1 */
	
	WR_MEM_32(CM_ALWON_SPI_0_CLKSTCTRL,    0x2); /*Enable UART0 Clock*/
	while(RD_MEM_32(CM_ALWON_SPI_0_CLKSTCTRL)!=0x2);		/*Poll for Module is functional*/

	GEL_TextOut("\t ***** SPI-0 CS-0 is initialized....***** \n");	 									

}

hotmenu SD_MMC0_Setup()
{
	GEL_TextOut("\tPRCM for SD/MMC0 are in Progress, Please wait.....  \n","Output",1,1,1);	 									
	
	WR_MEM_32(PINCNTL1, 0x00050001);  
	WR_MEM_32(PINCNTL2, 0x00060001);  
	WR_MEM_32(PINCNTL3, 0x00060001);  
	WR_MEM_32(PINCNTL4, 0x00060001);  
	WR_MEM_32(PINCNTL5, 0x00060001);  	
	WR_MEM_32(PINCNTL6, 0x00060001);  
	
	WR_MEM_32(CM_ALWON_MMC_HS_1_CLKSTCTRL,    0x2); /*Enable UART0 Clock*/
	while(RD_MEM_32(CM_ALWON_MMC_HS_1_CLKSTCTRL)!=0x2);		/*Poll for Module is functional*/

	GEL_TextOut("\t ***** MMC0/SD is initialized....***** \n");	 									

}

UARTClkEnable()
{
	GEL_TextOut("\tPRCM for UART0, UART1, and UART2 are in Progress, Please wait.....  \n","Output",1,1,1);	 									

	WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

	WR_MEM_32(CM_ALWON_UART_0_CLKCTRL,    0x2); /*Enable UART0 Clock*/
	while(RD_MEM_32(CM_ALWON_UART_0_CLKCTRL)!=0x2);

	WR_MEM_32(CM_ALWON_UART_1_CLKCTRL,    0x2); /*Enable UART1 Clock*/
	while(RD_MEM_32(CM_ALWON_UART_1_CLKCTRL)!=0x2);

	WR_MEM_32(CM_ALWON_UART_2_CLKCTRL,    0x2); /*Enable UART2 Clock*/
	while(RD_MEM_32(CM_ALWON_UART_2_CLKCTRL)!=0x2);
	
	while(RD_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL) & 0x2100 !=0x2100);

	GEL_TextOut("\tPRCM for UART0, UART1, and UART2 are Done Successfully.....  \n","Output",1,1,1);	 									
}


  Unlock_PLL_Control_MMR()

{
WR_MEM_32(control_pllss_mmr_lock,control_pllss_mmr_lock_unlock_val);
WR_MEM_32(control_mmr_lock0,control_mmr_lock0_unlock_val);
WR_MEM_32(control_mmr_lock1,control_mmr_lock1_unlock_val);
WR_MEM_32(control_mmr_lock2,control_mmr_lock2_unlock_val);
WR_MEM_32(control_mmr_lock3,control_mmr_lock3_unlock_val);
WR_MEM_32(control_mmr_lock4,control_mmr_lock4_unlock_val);
GEL_TextOut("\n PLL and Control MMR unlock done ... \n");   

}


  mmr_unlock()
{
*(unsigned int *)0x481C504c |= 0x06000000;
*(unsigned int *)0x481C5040 = 0x1EDA4C3D;
*(unsigned int *)0x48140060 = 0x2FF1AC2B;
*(unsigned int *)0x48140064 = 0xF757FDC0;
*(unsigned int *) 0x48140068 = 0xE2BC3A6D;
*(unsigned int *)0x4814006c = 0x1EBF131D;
*(unsigned int *)0x48140070 = 0x6F361E05;
GEL_TextOut("\tInitialized Successfully.....  \n","Output",1,1,1);
}

  emac_clkenable()

{
   GEL_TextOut("CONFIGURE PRCM CLOCKS of EMAC in progress \n\r");
   *((unsigned int*)(0x48181404)) = 0x2;
   *((unsigned int*)(0x481815d4)) = 0x2;
     while(RD_MEM_32(0x48181404)!=0x0302);
     while((RD_MEM_32(0x481815d4)&0x2)!=0x2);
   GEL_TextOut("PRCM CLOCKS of EMAC  is complete \n\r");

}



  Clockout_Enable()
{
//*(unsigned int *)0x481402e4 =0 ;             // clkout0,1 selection
 *(unsigned int *)0x481C52e4 =0;
*(unsigned int *)0x481409f8 =0x10 ;   // clkout1
*(unsigned int *)0x48140c08 =0x4 ;     //clkout0
*(unsigned int *)0x48180100 = ( (CLKOUT2EN << 7) | (CLKOUT2DIV << 3) | (CLKOUT2SRC << 0) ); 
GEL_TextOut("\tDM8148 clkout done.... \n","Output",1,1,1);	
  
}

  DSSClkEnable()
{
*(unsigned int *)0x48180E10 =0;
GEL_TextOut("\tPower Enabled.....  \n","Output",1,1,1);
/* Enabling DSS Clocks */
	*(unsigned int *)0x48180800=2 ;
	delay();
	*(unsigned int *)0x48180820=2 ;
	delay();
	*(unsigned int *)0x48180824=2 ;	
	delay();


	GEL_TextOut("\tPRCM for DSS in Progress, Please wait.....  \n","Output",1,1,1);
	while ( (*(unsigned int *)0x48180800 & 0x100) != 0x100)
	{
	}

/*Deasserting resets */

*(unsigned int *)0x48180E10 =0;
	GEL_TextOut("\tPRCM for DSS Done Successfully.....  \n","Output",1,1,1);	 							
		
}



  MLBClkEnable()
{
	GEL_TextOut("\tPRCM for MLB is in Progress, Please wait.....  \n","Output",1,1,1);	 									

	WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

	WR_MEM_32(CM_ALWON_TIMER_2_CLKCTRL, 0x2); /*Enable MLB Clk domain */
	while(RD_MEM_32(CM_ALWON_TIMER_2_CLKCTRL) != 0x2);
	//while(((RD_MEM_32(CM_ALWON_MLB_CLKCTRL)) & (0x3 << 16)) != 0);
	GEL_TextOut("\t1st while loop done...\n");

	/*Ensure the Clk domains are fully functional */

	/* SHB Clk */
	while(RD_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL) & 0x100 != 0x100);
	GEL_TextOut("\t 2nd while loop done...\n");

	/* SPB and SYS Clk Domain */
	while(RD_MEM_32(CM_ALWON_SYSCLK5_CLKSTCTRL) & 0x100 != 0x100);
	GEL_TextOut("\t 3rd while loop done ... \n");
	// mlb data pin mux
	WR_MEM_32(PINCNTL60, 0x00040001);  
/* 0000 0000 0000 0100 0000 0000 0000 0001*/
	// mlb sig pin mux
	WR_MEM_32(PINCNTL59, 0x00040001);  

	GEL_TextOut("\tPRCM for MLB has been done successfully.\n","Output",1,1,1);

}


  DCANClkEnable()
{
	GEL_TextOut("\tPRCM for DCAN is in Progress, Please wait.....  \n","Output",1,1,1);	 									

	WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

	WR_MEM_32(CM_ALWON_DCAN_0_1_CLKCTRL, 0x2); /*Enable DCAN Clk domain */
	while(RD_MEM_32(CM_ALWON_DCAN_0_1_CLKCTRL) != 0x2);
	// DCAN0 RX pin mux
	WR_MEM_32(PINCNTL69, 0x00040001);  
	// DCAN0 TX pin mux
//	WR_MEM_32(PINCNTL68, 0x00000001);  
	// DCAN1 RX pin mux, func4
//	WR_MEM_32(PINCNTL73, 0x00040008);  
	// DCAN1 TX pin mux, func4
	WR_MEM_32(PINCNTL72, 0x00000008);  
	GEL_TextOut("\t1st while loop done...\n");

	GEL_TextOut("\tPRCM for DCAN has been done successfully.\n","Output",1,1,1);
	

}


  delay()
{
	int del_cnt;
	for(del_cnt=0;del_cnt<200;del_cnt++);
}

/*********************************     **********************************************************************
 
  
                   EMIF/DDR FUNCTIONS

********************************************************************************************************************/

cmd_DDR2_EMIF0_EMIF1_Config(UWORD32 ddr2_phy_rd_dqs_cs0_arg,UWORD32 ddr2_phy_wr_dqs_cs0_arg,UWORD32 ddr2_phy_fifo_we_cs0_arg,UWORD32 ddr2_phy_wr_data_cs0_arg,UWORD32 ddr2_emif_read_latency_arg,UWORD32 ddr2_emif_tim1_arg,UWORD32 ddr2_emif_tim2_arg,UWORD32 ddr2_emif_tim3_arg,UWORD32 ddr2_emif_ref_ctrl_arg,UWORD32 ddr2_emif_sdram_config_arg)
{

	GEL_TextOut("\EMIF PRCM is in progress ....... \n","Output",1,1,1);
	Emif_PRCM_Clk_Enable();
	GEL_TextOut("\EMIF PRCM Done \n","Output",1,1,1);
	Cmd_Macro_Config(DDR_PHY0,PHY_INVERT_CLKOUT_DEFINE,DDR2_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
	Data_Macro_Config(DATA_MACRO_0,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_1,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_2,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_3,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);

	Cmd_Macro_Config(DDR_PHY1,PHY_INVERT_CLKOUT_DEFINE,DDR2_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
	Data_Macro_Config(DATA_MACRO_0,DDR_PHY1,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_1,DDR_PHY1,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_2,DDR_PHY1,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_3,DDR_PHY1,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
	GEL_TextOut("\DDR PHY Configuration Done \n","Output",1,1,1);
	WR_MEM_32(DDR0_IO_CTRL,0x00030303);
	WR_MEM_32(DDR1_IO_CTRL,0x00030303);
	
	Vtp_Enable();
	
	GEL_TextOut("\VTP Done \n","Output",1,1,1);
	
	/*Program the DMM to Access EMIF0 and EMIF1*/
	WR_MEM_32(DMM_LISA_MAP__0, 0x80600100);
	WR_MEM_32(DMM_LISA_MAP__1, 0x80600100);
	WR_MEM_32(DMM_LISA_MAP__2, 0xC0600200);
	WR_MEM_32(DMM_LISA_MAP__3, 0xC0600200);
		
	GEL_TextOut("\tBusy reading back DMM registers Please wait ...\n","Output",1,1,1);
	while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80600100);
	while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80600100);
	while(RD_MEM_32(DMM_LISA_MAP__2)!=0xC0600200);
	while(RD_MEM_32(DMM_LISA_MAP__3)!=0xC0600200);
	GEL_TextOut("\tDMM register read successfully  \n","Output",1,1,1);

	WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);

	Emif0_MMR_Config(ddr2_emif_read_latency_arg,ddr2_emif_tim1_arg,ddr2_emif_tim2_arg,ddr2_emif_tim3_arg,ddr2_emif_ref_ctrl_arg,ddr2_emif_sdram_config_arg);
	Emif1_MMR_Config(ddr2_emif_read_latency_arg,ddr2_emif_tim1_arg,ddr2_emif_tim2_arg,ddr2_emif_tim3_arg,ddr2_emif_ref_ctrl_arg,ddr2_emif_sdram_config_arg);
}

cmd_DDR3_EMIF0_EMIF1_Config(UWORD32 ddr3_phy_rd_dqs_cs0_arg,UWORD32 ddr3_phy_wr_dqs_cs0_arg,UWORD32 ddr3_phy_fifo_we_cs0_arg,UWORD32 ddr3_phy_wr_data_cs0_arg,UWORD32 ddr3_emif_read_latency_arg,UWORD32 ddr3_emif_tim1_arg,UWORD32 ddr3_emif_tim2_arg,UWORD32 ddr3_emif_tim3_arg,UWORD32 ddr3_emif_ref_ctrl_arg,UWORD32 ddr3_emif_sdram_config_arg)
{

	Emif_PRCM_Clk_Enable();

	Cmd_Macro_Config(DDR_PHY0,DDR3_PHY_INVERT_CLKOUT_OFF,DDR3_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
	Data_Macro_Config(DATA_MACRO_0,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_1,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_2,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_3,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);

	Cmd_Macro_Config(DDR_PHY1,DDR3_PHY_INVERT_CLKOUT_OFF,DDR3_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
	Data_Macro_Config(DATA_MACRO_0,DDR_PHY1,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_1,DDR_PHY1,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_2,DDR_PHY1,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
	Data_Macro_Config(DATA_MACRO_3,DDR_PHY1,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);

	WR_MEM_32(DDR0_IO_CTRL,0x00030303);
	WR_MEM_32(DDR1_IO_CTRL,0x00030303);
	
	Vtp_Enable();

	/*Program the DMM to Access EMIF0 and EMIF1*/
	WR_MEM_32(DMM_LISA_MAP__0, 0x80600100);
	WR_MEM_32(DMM_LISA_MAP__1, 0x80600100);
	WR_MEM_32(DMM_LISA_MAP__2, 0xC0600200);
	WR_MEM_32(DMM_LISA_MAP__3, 0xC0600200);
		
	GEL_TextOut("\tBusy reading back DMM registers Please wait ...\n","Output",1,1,1);
	while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80600100);
	while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80600100);
	while(RD_MEM_32(DMM_LISA_MAP__2)!=0xC0600200);
	while(RD_MEM_32(DMM_LISA_MAP__3)!=0xC0600200);
	GEL_TextOut("\tDMM register read successfully  \n","Output",1,1,1);

	WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);

	Emif0_MMR_Config(ddr3_emif_read_latency_arg,ddr3_emif_tim1_arg,ddr3_emif_tim2_arg,ddr3_emif_tim3_arg,ddr3_emif_ref_ctrl_arg,ddr3_emif_sdram_config_arg);
	Emif1_MMR_Config(ddr3_emif_read_latency_arg,ddr3_emif_tim1_arg,ddr3_emif_tim2_arg,ddr3_emif_tim3_arg,ddr3_emif_ref_ctrl_arg,ddr3_emif_sdram_config_arg);
}


Data_Macro_Config(UWORD32 dataMacroNum,UWORD32 ddr_phy_num,UWORD32 rd_dqs_cs0,UWORD32 wr_dqs_cs0,UWORD32 fifo_we_cs0,UWORD32 wr_data_cs0)
{
UWORD32 BaseAddrOffset;
	if(dataMacroNum == DATA_MACRO_0)
		BaseAddrOffset = 0x00;
	else if(dataMacroNum == DATA_MACRO_1)
		BaseAddrOffset = 0xA4;
	else if(dataMacroNum == DATA_MACRO_2)
		BaseAddrOffset = 0x148;
	else if(dataMacroNum == DATA_MACRO_3)
		BaseAddrOffset = 0x1EC;
	if(ddr_phy_num == DDR_PHY1)
		BaseAddrOffset = BaseAddrOffset + 0x400;//- phy1 is at offset of 0x400 from phy0

	WR_MEM_32((DATA0_REG_PHY0_RD_DQS_SLAVE_RATIO_0 + BaseAddrOffset), (rd_dqs_cs0 << 10 | rd_dqs_cs0)); 
	WR_MEM_32((DATA0_REG_PHY0_WR_DQS_SLAVE_RATIO_0 + BaseAddrOffset), (wr_dqs_cs0 << 10 | wr_dqs_cs0));
	WR_MEM_32((DATA0_REG_PHY0_WRLVL_INIT_RATIO_0 + BaseAddrOffset),   (PHY_WRLVL_INIT_CS1_DEFINE << 10  | PHY_WRLVL_INIT_CS0_DEFINE));
	WR_MEM_32((DATA0_REG_PHY0_GATELVL_INIT_RATIO_0 + BaseAddrOffset), (PHY_GATELVL_INIT_CS1_DEFINE << 10 | PHY_GATELVL_INIT_CS0_DEFINE));
	WR_MEM_32((DATA0_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 + BaseAddrOffset),(fifo_we_cs0 << 10  | fifo_we_cs0)); 
	WR_MEM_32((DATA0_REG_PHY0_WR_DATA_SLAVE_RATIO_0 + BaseAddrOffset),(wr_data_cs0 << 10 | wr_data_cs0)); 
	//-WR_MEM_32((DATA0_REG_PHY0_USE_RANK0_DELAYS + BaseAddrOffset),     PHY_REG_USE_RANK0_DELAY_DEFINE);//- default is 0;
	WR_MEM_32((DATA0_REG_PHY0_DLL_LOCK_DIFF_0 + BaseAddrOffset),      PHY_DLL_LOCK_DIFF_DEFINE);
}

Cmd_Macro_Config(UWORD32 ddr_phy_num,UWORD32 invert_clk_out,UWORD32 ctrl_slave_ratio_cs0,UWORD32 cmd_dll_lock_diff)
{
	if(ddr_phy_num == DDR_PHY0)
	{
	WR_MEM_32(CMD0_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);
	WR_MEM_32(CMD1_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);
	WR_MEM_32(CMD2_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);

	WR_MEM_32(CMD0_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0)); 
	WR_MEM_32(CMD1_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0)); 
	WR_MEM_32(CMD2_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0)); 

	WR_MEM_32(CMD0_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
	WR_MEM_32(CMD1_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
	WR_MEM_32(CMD2_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
	}
	else if(ddr_phy_num == DDR_PHY1)
	{
		WR_MEM_32(CMD0_REG_PHY1_INVERT_CLKOUT_0, invert_clk_out);
		WR_MEM_32(CMD1_REG_PHY1_INVERT_CLKOUT_0, invert_clk_out);
		WR_MEM_32(CMD2_REG_PHY1_INVERT_CLKOUT_0, invert_clk_out);
	
		WR_MEM_32(CMD0_REG_PHY1_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0)); 
		WR_MEM_32(CMD1_REG_PHY1_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0)); 
		WR_MEM_32(CMD2_REG_PHY1_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0)); 
	
		WR_MEM_32(CMD0_REG_PHY1_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
		WR_MEM_32(CMD1_REG_PHY1_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
		WR_MEM_32(CMD2_REG_PHY1_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
	}
}


Emif0_MMR_Config(UWORD32 read_latency,UWORD32 tim1,UWORD32 tim2,UWORD32 tim3,UWORD32 ref_ctrl,UWORD32 sdram_config)
{
	/*Program EMIF0 CFG Registers*/
	WR_MEM_32(EMIF4_0_DDR_PHY_CTRL_1, read_latency);
	WR_MEM_32(EMIF4_0_DDR_PHY_CTRL_1_SHADOW, read_latency);

	WR_MEM_32(EMIF4_0_SDRAM_TIM_1, tim1);
	WR_MEM_32(EMIF4_0_SDRAM_TIM_1_SHADOW, tim1);

	WR_MEM_32(EMIF4_0_SDRAM_TIM_2, tim2);
	WR_MEM_32(EMIF4_0_SDRAM_TIM_2_SHADOW, tim2);

	WR_MEM_32(EMIF4_0_SDRAM_TIM_3, tim3);
	WR_MEM_32(EMIF4_0_SDRAM_TIM_3_SHADOW, tim3);

	WR_MEM_32(EMIF4_0_SDRAM_CONFIG, sdram_config);

	WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, 0x10000000|DDR3_EMIF_REF_CTRL_DEFINE1); 
	WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);
	
	WR_MEM_32(EMIF4_0_SDRAM_ZQCR,DDR3_EMIF_SDRAM_ZQCR_DEFINE);
	
	WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, DDR3_EMIF_REF_CTRL_DEFINE1); 
	WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);

	WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, ref_ctrl); 
	WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, ref_ctrl);
}

Emif1_MMR_Config(UWORD32 read_latency,UWORD32 tim1,UWORD32 tim2,UWORD32 tim3,UWORD32 ref_ctrl,UWORD32 sdram_config)
{
	/*Program EMIF0 CFG Registers*/
	WR_MEM_32(EMIF4_1_DDR_PHY_CTRL_1, read_latency);
	WR_MEM_32(EMIF4_1_DDR_PHY_CTRL_1_SHADOW, read_latency);

	WR_MEM_32(EMIF4_1_SDRAM_TIM_1, tim1);
	WR_MEM_32(EMIF4_1_SDRAM_TIM_1_SHADOW, tim1);

	WR_MEM_32(EMIF4_1_SDRAM_TIM_2, tim2);
	WR_MEM_32(EMIF4_1_SDRAM_TIM_2_SHADOW, tim2);

	WR_MEM_32(EMIF4_1_SDRAM_TIM_3, tim3);
	WR_MEM_32(EMIF4_1_SDRAM_TIM_3_SHADOW, tim3);

	
	WR_MEM_32(EMIF4_1_SDRAM_CONFIG, sdram_config);
	
	WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL, 0x10000000|DDR3_EMIF_REF_CTRL_DEFINE1); 
	WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);
	
	WR_MEM_32(EMIF4_1_SDRAM_ZQCR,DDR3_EMIF_SDRAM_ZQCR_DEFINE);
	
	WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL, DDR3_EMIF_REF_CTRL_DEFINE1); 
	WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);

	WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL, ref_ctrl); 
	WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL_SHADOW, ref_ctrl);
}


Emif_PRCM_Clk_Enable()
{
	WR_MEM_32(CM_DEFAULT_FW_CLKCTRL, 0x2); 		  /*Enable the EMIF FireWall Clocks*/
	WR_MEM_32(CM_DEFAULT_L3_FAST_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Fast Domain Peripheral*/
	WR_MEM_32(CM_DEFAULT_EMIF_0_CLKCTRL,    0x2); /*Enable EMIF0 Clock*/
	WR_MEM_32(CM_DEFAULT_EMIF_1_CLKCTRL,    0x2); /*Enable EMIF1 Clock*/
	WR_MEM_32(CM_DEFAULT_DMM_CLKCTRL,       0x2); /*Enable EMIF1 Clock*/
	while((RD_MEM_32(CM_DEFAULT_L3_FAST_CLKSTCTRL) & 0x300)!=0x300);	/*Poll for L3_FAST_GCLK  & DDR_GCLK  are active*/
	while(RD_MEM_32(CM_DEFAULT_EMIF_0_CLKCTRL)!=0x2);		/*Poll for Module is functional*/
	while(RD_MEM_32(CM_DEFAULT_EMIF_1_CLKCTRL)!=0x2);		/*Poll for Module is functional*/
	while(RD_MEM_32(CM_DEFAULT_DMM_CLKCTRL)!=0x2);			/*Poll for Module is functional*/
}

Vtp_Enable()
{
	// Write 1 to ENABLE bit
	WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) | 0x00000040 ); 
	WR_MEM_32(VTP1_CTRL_REG, RD_MEM_32(VTP1_CTRL_REG) | 0x00000040 ); 

	// Write 0 to CLRZ bit
	WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) & 0xfffffffe ); 
	WR_MEM_32(VTP1_CTRL_REG, RD_MEM_32(VTP1_CTRL_REG) & 0xfffffffe ); 
	
	// Write 1 to CLRZ bit
	WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) | 0x00000001 ); 
	WR_MEM_32(VTP1_CTRL_REG, RD_MEM_32(VTP1_CTRL_REG) | 0x00000001 ); 

	// Read VTP control registers & check READY bits
	while( (RD_MEM_32(VTP0_CTRL_REG) & 0x00000020) != 0x20);
	while( (RD_MEM_32(VTP1_CTRL_REG) & 0x00000020) != 0x20);
}


/*************************************************************************************************/
	
	/********************************************************************************
            DDR Initialization and Configurations   		
    *********************************************************************************/

   menuitem "DM8148 DDR Configuration"
   

	hotmenu DDR2_EMIF0_EMIF1_333MHz_Config()
	{
	    GEL_TextOut("\t ****  Configuring DDR PLL to 333 MHz......... \n");
		cmdDDRPLL(CLKIN,19,666, 2);	  
		GEL_TextOut("\t ****  DM8148 DDR2 EVM EMIF0 and EMIF1 configuration in progress......... \n","Output",1,1,1);
		cmd_DDR2_EMIF0_EMIF1_Config(DDR2_PHY_RD_DQS_CS0_DEFINE,DDR2_PHY_WR_DQS_CS0_DEFINE,DDR2_PHY_FIFO_WE_CS0_DEFINE,DDR2_PHY_WR_DATA_CS0_DEFINE,DDR2_EMIF_READ_LATENCY_DEFINE,DDR2_EMIF_TIM1_DEFINE,DDR2_EMIF_TIM2_DEFINE,DDR2_EMIF_TIM3_DEFINE,DDR2_EMIF_REF_CTRL_DEFINE,DDR2_EMIF_SDRAM_CONFIG_DEFINE);
		GEL_TextOut("\t ****  DM8148 DDR2 EVM EMIF0 and EMIF1 configuration is DONE **** \n","Output",1,1,1);	
	}

	hotmenu DDR2_EMIF0_EMIF1_400MHz_Config()
	{
	    GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
		cmdDDRPLL(CLKIN,19,800, 2);
		GEL_TextOut("\t ****  DM8148 DDR2 EVM EMIF0 and EMIF1 configuration in progress......... \n","Output",1,1,1);
		cmd_DDR2_EMIF0_EMIF1_Config(DDR2_PHY_RD_DQS_CS0_DEFINE,DDR2_PHY_WR_DQS_CS0_DEFINE,DDR2_PHY_FIFO_WE_CS0_DEFINE,DDR2_PHY_WR_DATA_CS0_DEFINE,DDR2_EMIF_READ_LATENCY_DEFINE,DDR2_EMIF_TIM1_DEFINE,DDR2_EMIF_TIM2_DEFINE,DDR2_EMIF_TIM3_DEFINE,DDR2_EMIF_REF_CTRL_DEFINE,DDR2_EMIF_SDRAM_CONFIG_DEFINE);
		GEL_TextOut("\t ****  DM8148 DDR2 EVM EMIF0 and EMIF1 configuration is DONE **** \n","Output",1,1,1);	
	}

	hotmenu DDR3_EMIF0_EMIF1_300MHz_Config()
	{
	    GEL_TextOut("\t ****  Configuring DDR PLL to 300 MHz......... \n");
		cmdDDRPLL(CLKIN,19,600, 2);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n","Output",1,1,1);	
		cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_300,DDR3_EMIF_TIM1_DEFINE_300,DDR3_EMIF_TIM2_DEFINE_300,DDR3_EMIF_TIM3_DEFINE_300,DDR3_EMIF_REF_CTRL_DEFINE2_300,DDR3_EMIF_SDRAM_CONFIG_DEFINE_300);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n","Output",1,1,1);		
	}

		hotmenu DDR3_EMIF0_EMIF1_333MHz_Config()
	{
	    GEL_TextOut("\t ****  Configuring DDR PLL to 333 MHz......... \n");
		cmdDDRPLL(CLKIN,19,666, 2);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n","Output",1,1,1);	
		cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_333,DDR3_EMIF_TIM1_DEFINE_333,DDR3_EMIF_TIM2_DEFINE_333,DDR3_EMIF_TIM3_DEFINE_333,DDR3_EMIF_REF_CTRL_DEFINE2_333,DDR3_EMIF_SDRAM_CONFIG_DEFINE_333);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n","Output",1,1,1);		
	}
	hotmenu DDR3_EMIF0_EMIF1_400MHz_Config()
	{
	    GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
		cmdDDRPLL(CLKIN,19,800, 2);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n","Output",1,1,1);
		cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_400,DDR3_EMIF_TIM1_DEFINE_400,DDR3_EMIF_TIM2_DEFINE_400,DDR3_EMIF_TIM3_DEFINE_400,DDR3_EMIF_REF_CTRL_DEFINE2_400,DDR3_EMIF_SDRAM_CONFIG_DEFINE_400);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n","Output",1,1,1);	
	}
	hotmenu DDR3_EMIF0_EMIF1_450MHz_Config()
	{
	    GEL_TextOut("\t ****  Configuring DDR PLL to 450 MHz......... \n");
		cmdDDRPLL(CLKIN,19,900, 2);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n","Output",1,1,1);	
		cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_450,DDR3_EMIF_TIM1_DEFINE_450,DDR3_EMIF_TIM2_DEFINE_450,DDR3_EMIF_TIM3_DEFINE_450,DDR3_EMIF_REF_CTRL_DEFINE2_450,DDR3_EMIF_SDRAM_CONFIG_DEFINE_450);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n","Output",1,1,1);		
	}
	hotmenu DDR3_EMIF0_EMIF1_533MHz_Config()
	{
	    GEL_TextOut("\t ****  Configuring DDR PLL to 533 MHz......... \n");
		cmdDDRPLL(CLKIN,19,1066, 2);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n","Output",1,1,1);
		cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_533,DDR3_EMIF_TIM1_DEFINE_533,DDR3_EMIF_TIM2_DEFINE_533,DDR3_EMIF_TIM3_DEFINE_533,DDR3_EMIF_REF_CTRL_DEFINE2_533,DDR3_EMIF_SDRAM_CONFIG_DEFINE_533);
		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n","Output",1,1,1);	
	}
//	hotmenu DDR3_EMIF0_EMIF1_666MHz_Config()
//	{
//	    GEL_TextOut("\t ****  Configuring DDR PLL to 666 MHz......... \n");
//		cmdDDRPLL(CLKIN,19,1332, 2);
//		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n","Output",1,1,1);	
//		cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_666,DDR3_EMIF_TIM1_DEFINE_666,DDR3_EMIF_TIM2_DEFINE_666,DDR3_EMIF_TIM3_DEFINE_666,DDR3_EMIF_REF_CTRL_DEFINE2_666,DDR3_EMIF_SDRAM_CONFIG_DEFINE_666);
//		GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n","Output",1,1,1);		
//	}


OnTargetConnect()
{
    GEL_TextOut( "\nConnecting Target...\n" );

	GEL_Reset();
    ALL_ADPLL_CLOCKS_ENABLE_API();
	C674xClkEnable_API();    
	ControlModule_ClkEnable();
	PrcmAlwayOnClkEnable();
    Ethernet_PinMux_Setup();
	SPI_Setup();
	SD_MMC0_Setup();
	DDR3_EMIF0_EMIF1_533MHz_Config();
	
    GEL_TextOut( "Connecting Target... Done.\n\n" );
}


/*************************************************************************************************/
