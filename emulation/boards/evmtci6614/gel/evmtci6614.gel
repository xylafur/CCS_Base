// *  TCI6614LXE EVM GEL File
// *
// *  This is the GEL file for use in Code Composer Studio for the 6614LXE platform.
// *
// *  REVISION HISTORY:                                                            
// *  Version 0.1 	(11/10/2011)	         		
// *	-	Baselined from C6670L EVM GEL file.                                           
// *	-	Added TCI6614 system debug  functions.                           		                     		
// *                         		
// *	Version 0.2		(11/15/2011)	
// *	- 	Removed extraneous comments from previous file merges
//	*	-	Updated the ECO#1 implementation to be compatible with TCI6614 DDR3 controller specifics 
// *		+ 	Added data_[8:0]_reg_phy_RD_dqs_slave_ratio register definitions (DDR3_CONFIG_REG_[60:52] registers)
// *		+	Uses the DDR3_CONFIG_REG_[60:52] registers in place of DDR3_CONFIG_REG_23 to write the phy_RD_dqs_slave_ratio 
//	*
//	* 	- 	Updated the DDR3 PLL init sequence in ddr3_setup
//	*		+	Added missing step to put DDR3 PLL into bypass before setting up multipliers, dividers and bandwidth adjust registers
// *		+	Added missing step to wait for at least 500 * REFCLK cycles * (PLLD + 1) (PLL lock time) after de-asserting PLL reset
// *		+	Added missing step to take DDR3 PLL out of bypass (coupled to step above to put it into bypass)
//	*	
// *	- 	Updated the Main PLL init sequence
// *		+	Set_Pll1() now follows the recommended setup flow for the Main PLL
// *		+	This also includes resets that are distrubuted to the DDR3 and PA-SS PLL as well
//	*		+ 	Added all MAINPLLCTL0 and MAINPLLCTL1 bit field definitions needed
//	*	
// *	-	Removed hotmenu Init_PLL()
// *		+ This was an extraneous function leftover from a previous merge
// *		+ Set_Pll1() is the only PLL init function for the Main PLL
// *
// *	-	Removed menuitem "EVMTCI6614LXE HW Setup"
// *		+ This was an extraneous function leftover from a previous merge	
// *		+ All EVM specific setup functions are now located under the "EVMTCI6614LXE MENU"
// *
// *	-	Re-arranged hotmenu for CPSW functionality to be below the "EVMTCI6614LXE HW Setup"
// *
// *	Version 0.3		(11/16/2011)	
// *	-	Added VID value decode to the TCI6614_psc_voltage_control_identification() function
// *
// * 	Version 0.4		(11/17/2011)
// *	-	Corrected the offset for BWADJ programming into MAINPLLCTL1
// *	-	Corrected the PLLENSRC MASK offset
// *	- 	Updated the DDR3 PLL init sequence to maintain bypass bits
// *	- 	Updated the DDR3 register definitions to match spec - found a bug
// *	- 	Updated the DDR3 ECO#1 workaround to make use of the new registers in TCI6614
// *	
// * 	Version 0.5		(12/06/2011)
// *	-	Modified Set_Pll1 to use the proper PLL output dividers an an example
// *		+	Changed to PLLDIV2, PLLDIV5, and PLLDIV8 - these are actually programmable 
// *		+	Previous example was not modifying anything as those dividers are fixed and registers are read-only
//	*	- Modified Set_Pll1 
//	*		+	set debug_info_on = 0 to make console output cleaner
// *	-	Added function linux_noboot_init()
// *		+	Sets up the DEVSTAT register based on the PLL configuration selected
// *				-	needed for Linux kernel to scale properly
// *		+	Enables the UART0 transmitter and receiver in the PWREMU_MGMT register
// *				-	needed for Linux kernel to communicate over UART0 during boot 
// *	- 	Added the UART0 and UART1 registers and memory map
// *	-	Changed name of ddr3_setup_auto_lvl_1333 to ddr3_setup because this function will now support multiple DDR3 configurations 
// *	-	Modified DATA1_GTLVL_INIT_RATIO in DDR3-1333 configuration in ddr3_setup function
//	*		+	There was a typo from a previous update - now it is in sync with the value generated from the latest ddr3_configuration_spreadsheet_rev_0.5
// *	-	Added DDR3-800 MHz configuration to ddr3_setup function
// *		+ All register values taken from 800 MHz configuration in the latest ddr3_configuration_spreadsheet_rev_0.5	
// *	
// *	
// *************************************************************************
// * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
// * 
// * 
// *  Redistribution and use in source and binary forms, with or without 
// *  modification, are permitted provided that the following conditions 
// *  are met:
// *
// *    Redistributions of source code must retain the above copyright 
// *    notice, this list of conditions and the following disclaimer.
// *
// *    Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the 
// *    documentation and/or other materials provided with the   
// *    distribution.
// *
// *    Neither the name of Texas Instruments Incorporated nor the names of
// *    its contributors may be used to endorse or promote products derived
// *    from this software without specific prior written permission.
// *
// *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// *************************************************************************

#define GEL_VERSION     0.6

// Enable for when Manually using CCS and AVV Framework style memory map
#define SYSTEM_RESET_BEFORE_FILE_LOAD_ENABLE	(0)
#define ON_RESET_CODE_ENABLE						(1)
#define ON_TARGET_CONNECT_CODE_ENABLE			(1)
#define ON_FILE_LOAD_CODE_ENABLE					(1)
#define AVV_MEM_MAP									(0)

///*********************************************************************
///
///	EVMTCI6614LXE HW Setup Functions
///
///*********************************************************************


#define DDR3_BASE_ADDRESS							0x80000000

// Global Register and constant definitions

// Global timeout value
#define GTIMEOUT 2000

//*****************************************************
// Power definitions
#define PSC_BASE            0x02350000
#define PSC_PTCMD           *( unsigned int* )( PSC_BASE+0x120 )
#define PSC_PTSTAT          *( unsigned int* )( PSC_BASE+0x128 )
#define PSC_PDCTL_BASE      ( PSC_BASE+0x300 )
#define PSC_MDSTAT_BASE     ( PSC_BASE+0x800 )
#define PSC_MDCTL_BASE      ( PSC_BASE+0xA00 )

// Modules on power domain 0
#define LPSC_SMARTRFLX (1)
#define LPSC_DDR3      (2)
#define LPSC_VUSR     (3)
#define LPSC_VCP2A     (4)

// Modules on power domain 1
#define LPSC_DEBUG     (5)
#define LPSC_TETB      (6)

// Modules on power domain 2
#define LPSC_PA        (7)
#define LPSC_SGMII     (8)
#define LPSC_SA        (9)

// Modules on power domain 3
#define LPSC_PCIE      (10)

// Modules on power domain 4
#define LPSC_SRIO      (11)

// Modules on power domain 5
#define LPSC_BCP     (12)

// Modules on power domain 6
#define LPSC_ARM    (13)

// Modules on power domain 7
#define LPSC_MSMCRAM   (14)

// Modules on power domain 8
#define LPSC_RACA_RACB (15)
#define LPSC_TAC       (16)

// Modules on power domain 9
#define LPSC_FFTCA_FFTCB (17)

// Modules on power domain 10
#define LPSC_AIF2      (18)

// Modules on power domain 11
#define LPSC_TCP3DA    (19)

// Modules on power domain 12
#define LPSC_VCP2B     (20)
#define LPSC_VCP2C     (21)
#define LPSC_VCP2D     (22)

// Modules on power domain 13
#define LPSC_C0_TIM0   (23)

// Modules on power domain 14
#define LPSC_C1_TIM1   (24)
#define LPSC_C1_RSA    (25)

// Modules on power domain 15
#define LPSC_C2_TIM2   (26)
#define LPSC_C2_RSA    (27)

// Modules on power domain 16
#define LPSC_C3_TIM3   (28)

// Modules on power domain 17
#define LPSC_TCP3dB    (29)


// Power domains definitions
#define PD0         (0)     // Power Domain-0
#define PD1         (1)     // Power Domain-1
#define PD2         (2)     // Power Domain-2
#define PD3         (3)     // Power Domain-3
#define PD4         (4)     // Power Domain-4
#define PD5         (5)     // Power Domain-5
#define PD6         (6)     // Power Domain-6
#define PD7         (7)     // Power Domain-7
#define PD8         (8)     // Power Domain-8
#define PD9         (9)     // Power Domain-9
#define PD10        (10)    // Power Domain-10
#define PD11        (11)    // Power Domain-11
#define PD12        (12)    // Power Domain-12
#define PD13        (13)    // Power Domain-13
#define PD14        (14)    // Power Domain-14
#define PD15        (15)    // Power Domain-15
#define PD16        (16)    // Power Domain-16
#define PD17        (17)    // Power Domain-17

#define PSC_SYNCRESET (0x1)
#define PSC_DISABLE   (0x2)
#define PSC_ENABLE    (0x3)

//*****************************************************
// BOOT and CONFIG dsp system modules Definitions
#define CHIP_LEVEL_REG  0x02620000
#define DEVSTAT         *(unsigned int*)(CHIP_LEVEL_REG + 0x0020)

// Boot cfg registers
#define KICK0				*(unsigned int*)(CHIP_LEVEL_REG + 0x0038)
#define KICK1				*(unsigned int*)(CHIP_LEVEL_REG + 0x003C)
#define KICK0_UNLOCK 	(0x83E70B13)
#define KICK1_UNLOCK 	(0x95A4F1E0)
#define KICK_LOCK    	0
#define TINPSEL         *(unsigned int*)(CHIP_LEVEL_REG + 0x0300)
#define TOUTPSEL        *(unsigned int*)(CHIP_LEVEL_REG + 0x0304)
#define MAINPLLCTL0		*(unsigned int*)(CHIP_LEVEL_REG + 0x0328)
#define MAINPLLCTL1		*(unsigned int*)(CHIP_LEVEL_REG + 0x032C)
	#define MAIN_PLLD_OFFSET	0
	#define MAIN_PLLD_MASK		0xFFFFFFC0
	#define MAIN_PLLM_OFFSET 	12
	#define MAIN_PLLM_MASK		0xFFF80FFF
	#define MAIN_BWADJ0_OFFSET	24
	#define MAIN_BWADJ0_MASK	0x00FFFFFF
	#define MAIN_ENSAT_OFFSET	6
	#define MAIN_ENSAT_MASK		0xFFFFFFBF
	#define MAIN_BWADJ1_OFFSET	0
	#define MAIN_BWADJ1_MASK	0xFFFFFFF0

#define DDR3PLLCTL0		*(unsigned int*)(CHIP_LEVEL_REG + 0x0330)
#define DDR3PLLCTL1		*(unsigned int*)(CHIP_LEVEL_REG + 0x0334)
#define PAPLLCTL0			*(unsigned int*)(CHIP_LEVEL_REG + 0x0338)
#define PAPLLCTL1			*(unsigned int*)(CHIP_LEVEL_REG + 0x033C)
#define OBSCLKCTL       *(unsigned int*)(CHIP_LEVEL_REG + 0x03AC)

/* PA PLL Observation Clock Control Register */
#define PA_PLL_OBS_CLK_SEL_MASK (1 << 4) /* OBSCLKCTL Register Bit 4 - set to 0 to see PA PLL reference (input) clock, set to 1 to see PA PLL output*/
#define PA_PLL_OBS_CLK_EN_MASK  (1 << 5) /* OBSCLKCTL Register Bit 5 - set to 1 to enable power to PA PLL observation clock*/

/* PA PLL Registers */
#define BYPASS_BIT_SHIFT 23
#define CLKF_BIT_SHIFT   6
#define PASSCLKSEL_MASK    (1 << 17)    /* Tells the configuration of the PASSCLKSEL pin */
#define PA_PLL_BYPASS_MASK (1 << BYPASS_BIT_SHIFT)    /* Tells whether the PA PLL is in BYPASS mode or not */
#define PA_PLL_CLKOD_MASK  (0x00780000) /* Tells the output divider value for the PA PLL */
#define PA_PLL_CLKF_MASK   (0x0007FFC0) /* Tells the multiplier value for the PA PLL */
#define PA_PLL_CLKR_MASK   (0x0000003F) /* Tells the divider value for the PA PLL */

// DDR3 tuning registers
#define DATA0_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x043C))
#define DATA1_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0440))
#define DATA2_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0444))
#define DATA3_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0448))
#define DATA4_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x044C))
#define DATA5_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0450))
#define DATA6_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0454))
#define DATA7_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0458))
#define DATA8_GTLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x045C))

#define DATA0_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x040C))
#define DATA1_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0410))
#define DATA2_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0414))
#define DATA3_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0418))
#define DATA4_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x041C))
#define DATA5_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0420))
#define DATA6_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0424))
#define DATA7_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x0428))
#define DATA8_WRLVL_INIT_RATIO	(*(unsigned int*)(CHIP_LEVEL_REG + 0x042C))

#define DDR3_CONFIG_REG_0  		(*(unsigned int*)(CHIP_LEVEL_REG + 0x0404))
#define DDR3_CONFIG_REG_12 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x0434)) 
#define DDR3_CONFIG_REG_13 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x0438)) 

#define DDR3_CONFIG_REG_52 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04D4)) 
#define DDR3_CONFIG_REG_53 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04D8)) 
#define DDR3_CONFIG_REG_54 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04DC)) 
#define DDR3_CONFIG_REG_55 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04E0)) 
#define DDR3_CONFIG_REG_56 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04E4)) 
#define DDR3_CONFIG_REG_57 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04E8)) 
#define DDR3_CONFIG_REG_58 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04EC)) 
#define DDR3_CONFIG_REG_59 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04F0)) 
#define DDR3_CONFIG_REG_60 		(*(unsigned int*)(CHIP_LEVEL_REG + 0x04F4)) 

//*****************************************************
// Timeout definitions
int _GEL_Global_Timeout1 = 0;

#define TIMEOUT_ID 10

//*****************************************************
// Extended Memory Controller (XMC) Configuration
#define XMC_BASE_ADDR (0x08000000)
#define XMPAX2_L     (*(unsigned int*)(XMC_BASE_ADDR + 0x00000010))
#define XMPAX2_H     (*(unsigned int*)(XMC_BASE_ADDR + 0x00000014))

// DDR3 definitions
#define DDR_BASE_ADDR 0x21000000

#define DDR_MIDR               (*(unsigned int*)(DDR_BASE_ADDR + 0x00000000))
#define DDR_SDCFG              (*(unsigned int*)(DDR_BASE_ADDR + 0x00000008))
#define DDR_SDRFC              (*(unsigned int*)(DDR_BASE_ADDR + 0x00000010))
#define DDR_SDTIM1             (*(unsigned int*)(DDR_BASE_ADDR + 0x00000018))
#define DDR_SDTIM2             (*(unsigned int*)(DDR_BASE_ADDR + 0x00000020))
#define DDR_SDTIM3             (*(unsigned int*)(DDR_BASE_ADDR + 0x00000028))
#define DDR_PMCTL              (*(unsigned int*)(DDR_BASE_ADDR + 0x00000038))
#define DDR_ZQCFG    			 (*(unsigned int*)(DDR_BASE_ADDR + 0x000000C8))
#define DDR_TMPALRT  			 (*(unsigned int*)(DDR_BASE_ADDR + 0x000000CC))
#define DDR_RDWR_LVL_RMP_CTRL  (*(unsigned int*)(DDR_BASE_ADDR + 0x000000D8))
#define DDR_RDWR_LVL_CTRL      (*(unsigned int*)(DDR_BASE_ADDR + 0x000000DC))
#define DDR_DDRPHYC            (*(unsigned int*)(DDR_BASE_ADDR + 0x000000E4))



//*****************************************************
// PLL 1 definitions (DSP and ARM clock and subsystems)
#define PLL1_BASE           0x02310000
#define PLL1_PLLCTL         (*(unsigned int*)(PLL1_BASE + 0x100))   // PLL1 Control
#define PLL1_SECCTL         (*(unsigned int*)(PLL1_BASE + 0x108))	  // PLL1 Secondary Control
#define PLL1_PLLM           (*(unsigned int*)(PLL1_BASE + 0x110))   // PLL1 Multiplier
#define PLL1_DIV1           (*(unsigned int*)(PLL1_BASE + 0x118))   // DIV1 divider
#define PLL1_DIV2           (*(unsigned int*)(PLL1_BASE + 0x11C))   // DIV2 divider
#define PLL1_DIV3           (*(unsigned int*)(PLL1_BASE + 0x120))   // DIV3 divider
#define PLL1_CMD            (*(unsigned int*)(PLL1_BASE + 0x138))   // CMD control
#define PLL1_STAT           (*(unsigned int*)(PLL1_BASE + 0x13C))   // STAT control
#define PLL1_ALNCTL         (*(unsigned int*)(PLL1_BASE + 0x140))   // ALNCTL control
#define PLL1_DCHANGE        (*(unsigned int*)(PLL1_BASE + 0x144))   // DCHANGE status
#define PLL1_CKEN           (*(unsigned int*)(PLL1_BASE + 0x148))   // CKEN control
#define PLL1_CKSTAT         (*(unsigned int*)(PLL1_BASE + 0x14C))   // CKSTAT status
#define PLL1_SYSTAT         (*(unsigned int*)(PLL1_BASE + 0x150))   // SYSTAT status
#define PLL1_DIV4           (*(unsigned int*)(PLL1_BASE + 0x160))   // DIV4 divider
#define PLL1_DIV5           (*(unsigned int*)(PLL1_BASE + 0x164))   // DIV5 divider
#define PLL1_DIV6           (*(unsigned int*)(PLL1_BASE + 0x168))   // DIV6 divider
#define PLL1_DIV7           (*(unsigned int*)(PLL1_BASE + 0x16C))   // DIV7 divider
#define PLL1_DIV8           (*(unsigned int*)(PLL1_BASE + 0x170))   // DIV8 divider
#define PLL1_DIV9           (*(unsigned int*)(PLL1_BASE + 0x174))   // DIV9 divider
#define PLL1_DIV10          (*(unsigned int*)(PLL1_BASE + 0x178))   // DIV10 divider
#define PLL1_DIV11          (*(unsigned int*)(PLL1_BASE + 0x17C))   // DIV11 divider
#define PLL1_DIV12          (*(unsigned int*)(PLL1_BASE + 0x180))   // DIV12 divider
#define PLL1_DIV13          (*(unsigned int*)(PLL1_BASE + 0x184))   // DIV13 divider
#define PLL1_DIV14          (*(unsigned int*)(PLL1_BASE + 0x188))   // DIV14 divider
#define PLL1_DIV15          (*(unsigned int*)(PLL1_BASE + 0x18C))   // DIV15 divider
#define PLL1_DIV16          (*(unsigned int*)(PLL1_BASE + 0x190))   // DIV16 divider
	#define PLLPWRDN_OFFSET			1
	#define PLLPWRDN_MASK			0xFFFFFFFD
	#define PLLRST_OFFSET			3
	#define PLLRST_MASK				0xFFFFFFF7
	#define PLLENSRC_OFFSET			5
	#define PLLENSRC_MASK			0xFFFFFFDF
	#define PLLEN_OFFSET				0
	#define PLLEN_MASK				0xFFFFFFFE
	#define OUTPUT_DIVIDE_OFFSET	19
	#define OUTPUT_DIVIDE_MASK		0xFF87FFFF	
	#define BYPASS_OFFSET			23
	#define BYPASS_MASK				0xFF7FFFFF
	#define PLLM_OFFSET				0
	#define PLLM_MASK					0xFFFFFFC0
	#define GOSET_OFFSET				0
	#define GOSET_MASK				0xFFFFFFFE
	#define GOSTAT_OFFSET			0
	#define GOSTAT_MASK				0xFFFFFFFE

//*****************************************************
// CACHE definitions
#define CACHE_BASE          0x01840000
#define CACHE_L2CFG         *( unsigned int* )( CACHE_BASE )
#define CACHE_L1PCFG        *( unsigned int* )( CACHE_BASE + 0x0020 )
#define CACHE_L1DCFG        *( unsigned int* )( CACHE_BASE + 0x0040 )
#define L2WBINV             (CACHE_BASE + 0x5004) // L2WBINV Control
#define L2INV               (CACHE_BASE + 0x5008) // L2INV Control
#define L1PINV              (CACHE_BASE + 0x5028) // L1PINV Control
#define L1DWBINV            (CACHE_BASE + 0x5044) // L1DWBINV Control
#define L1DINV              (CACHE_BASE + 0x5048) // L1DINV Control

//*****************************************************
// EDMA3 definitions
#define EDMA3_TPCC0_BASE    0x02700000
#define IERH_0                (EDMA3_TPCC0_BASE + 0x1054) // IERH Control
#define EERH_0                (EDMA3_TPCC0_BASE + 0x1024) // EERH Control
#define ICRH_0                (EDMA3_TPCC0_BASE + 0x1074) // ICRH Control
#define ECRH_0                (EDMA3_TPCC0_BASE + 0x100C) // ECRH Control
#define IER_0                 (EDMA3_TPCC0_BASE + 0x1050) // IER Control
#define EER_0                 (EDMA3_TPCC0_BASE + 0x1020) // EER Control
#define ICR_0                 (EDMA3_TPCC0_BASE + 0x1070) // ICR Control
#define ECR_0                 (EDMA3_TPCC0_BASE + 0x1008) // ECR Control
#define IECRH_0               (EDMA3_TPCC0_BASE + 0x105C) // IECRH Control
#define IECR_0                (EDMA3_TPCC0_BASE + 0x1058) // IECR Control
#define EECRH_0               (EDMA3_TPCC0_BASE + 0x102C) // EECRH Control
#define EECR_0                (EDMA3_TPCC0_BASE + 0x1028) // EECR Control

#define EDMA3_TPCC1_BASE    0x02720000
#define IERH_1                (EDMA3_TPCC1_BASE + 0x1054) // IERH Control
#define EERH_1                (EDMA3_TPCC1_BASE + 0x1024) // EERH Control
#define ICRH_1                (EDMA3_TPCC1_BASE + 0x1074) // ICRH Control
#define ECRH_1                (EDMA3_TPCC1_BASE + 0x100C) // ECRH Control
#define IER_1                 (EDMA3_TPCC1_BASE + 0x1050) // IER Control
#define EER_1                 (EDMA3_TPCC1_BASE + 0x1020) // EER Control
#define ICR_1                 (EDMA3_TPCC1_BASE + 0x1070) // ICR Control
#define ECR_1                 (EDMA3_TPCC1_BASE + 0x1008) // ECR Control
#define IECRH_1               (EDMA3_TPCC1_BASE + 0x105C) // IECRH Control
#define IECR_1                (EDMA3_TPCC1_BASE + 0x1058) // IECR Control
#define EECRH_1               (EDMA3_TPCC1_BASE + 0x102C) // EECRH Control
#define EECR_1                (EDMA3_TPCC1_BASE + 0x1028) // EECR Control

#define EDMA3_TPCC2_BASE    0x02740000
#define IERH_2                (EDMA3_TPCC2_BASE + 0x1054) // IERH Control
#define EERH_2                (EDMA3_TPCC2_BASE + 0x1024) // EERH Control
#define ICRH_2                (EDMA3_TPCC2_BASE + 0x1074) // ICRH Control
#define ECRH_2                (EDMA3_TPCC2_BASE + 0x100C) // ECRH Control
#define IER_2                 (EDMA3_TPCC2_BASE + 0x1050) // IER Control
#define EER_2                 (EDMA3_TPCC2_BASE + 0x1020) // EER Control
#define ICR_2                 (EDMA3_TPCC2_BASE + 0x1070) // ICR Control
#define ECR_2                 (EDMA3_TPCC2_BASE + 0x1008) // ECR Control
#define IECRH_2               (EDMA3_TPCC2_BASE + 0x105C) // IECRH Control
#define IECR_2                (EDMA3_TPCC2_BASE + 0x1058) // IECR Control
#define EECRH_2               (EDMA3_TPCC2_BASE + 0x102C) // EECRH Control
#define EECR_2                (EDMA3_TPCC2_BASE + 0x1028) // EECR Control

//*****************************************************
// GPIO definitions
#define GPIO_BASE           0x02320000
#define GPIO_BITEN          (*(unsigned int*)(GPIO_BASE + 0x0008)) // BITEN Control
#define GPIO_DIR            (*(unsigned int*)(GPIO_BASE + 0x0010)) // DIR Control
#define GPIO_OUT_DATA       (*(unsigned int*)(GPIO_BASE + 0x0014)) // OUT_DATA Control
#define GPIO_IN_DATA        (*(unsigned int*)(GPIO_BASE + 0x0020)) // IN_DATA Register
#define GPIO_CLR_RIS_TRIG   (*(unsigned int*)(GPIO_BASE + 0x0028)) // CLR_RIS_TRIG Control
#define GPIO_CLR_FAL_TRIG   (*(unsigned int*)(GPIO_BASE + 0x0030)) // CLR_FAL_TRIG Control

#define GPIO_DEFAULT_DIR    0xFFFF2CFF  // GP08,GP09,GP12,GP14,GP15 (Nand) are outputs
#define GPIO_DEFAULT_OUT    0x0000D000  // GP15, GP14, GP12 default to HIGH

// Used for eeprom programming
#define LITTLE_END 1
#define BIG_END 2

#define BOOTCFG_BASE    				0x02620000
#define SGMII_SERDES_BASE				0x02090000
#define SGMII_SLIVER_BASE1				0x02090900
#define SGMII_SLIVER_BASE2				0x02090940
#define SGMII_SERDES_CFGPLL			*((int*)(BOOTCFG_BASE + 0x340))
#define SGMII_SERDES_CFGRX0			*((int*)(BOOTCFG_BASE + 0x344))
#define SGMII_SERDES_CFGTX0			*((int*)(BOOTCFG_BASE + 0x348))
#define SGMII_SERDES_CFGRX1			*((int*)(BOOTCFG_BASE + 0x34C))
#define SGMII_SERDES_CFGTX1			*((int*)(BOOTCFG_BASE + 0x350))
#define SGMII_SERDES_CONTROL_PORT1	*((int*)(SGMII_SERDES_BASE + 0x210))
#define SGMII_SERDES_MR_ADV_PORT1	*((int*)(SGMII_SERDES_BASE + 0x218))
#define SGMII_SERDES_AUX_CFG_PORT1	*((int*)(SGMII_SERDES_BASE + 0x238))
#define SGMII_SERDES_CONTROL_PORT0	*((int*)(SGMII_SERDES_BASE + 0x110))
#define SGMII_SERDES_MR_ADV_PORT0	*((int*)(SGMII_SERDES_BASE + 0x118))
#define SGMII_SERDES_AUX_CFG_PORT0	*((int*)(SGMII_SERDES_BASE + 0x138))
#define SGMII_SLIVER_MACCONTROL1		*((int*)(SGMII_SLIVER_BASE1 + 0x4))
#define SGMII_SLIVER_MAXLEN1			*((int*)(SGMII_SLIVER_BASE1 + 0x10))
#define SGMII_SLIVER_MACCONTROL2		*((int*)(SGMII_SLIVER_BASE2 + 0x4))
#define SGMII_SLIVER_MAXLEN2			*((int*)(SGMII_SLIVER_BASE2 + 0x10))

#define CPSW3G_BASE             0x02090800
#define CPSW3G_CONTROL_REG		        	*((int*)(CPSW3G_BASE + 0x4))
#define CPSW3G_STAT_PORT_REG		    	*((int*)(CPSW3G_BASE + 0xC))
#define CPSW3G_ALE_CONTROL_REG		   *((int*)(CPSW3G_BASE + 0x608))
#define CPSW3G_ALE_PORT_0_CTL_REG		*((int*)(CPSW3G_BASE + 0x640))
#define CPSW3G_ALE_PORT_1_CTL_REG		*((int*)(CPSW3G_BASE + 0x644))
#define CPSW3G_ALE_PORT_2_CTL_REG		*((int*)(CPSW3G_BASE + 0x648))
#define CPSW3G_ALE_PORT_STATE_FORWARD  0x3

#define UARTA_BASE			0x02540000
#define UARTA_RBR_THR		(*(unsigned int*)(UARTA_BASE + 0x00))	// RBR (read-only) / THR (write-only)
#define UARTA_IER				(*(unsigned int*)(UARTA_BASE + 0x04))	// IER 	
#define UARTA_IIR_FCR		(*(unsigned int*)(UARTA_BASE + 0x08))	// IIR (read-only) / FCR (write-only) 	
#define UARTA_LCR				(*(unsigned int*)(UARTA_BASE + 0x0C))	// LCR
#define UARTA_MCR				(*(unsigned int*)(UARTA_BASE + 0x10))	// MCR
#define UARTA_LSR				(*(unsigned int*)(UARTA_BASE + 0x14))	// LSR
#define UARTA_MSR				(*(unsigned int*)(UARTA_BASE + 0x18))	// MSR
#define UARTA_SCR				(*(unsigned int*)(UARTA_BASE + 0x1C))	// SCR
#define UARTA_DLL				(*(unsigned int*)(UARTA_BASE + 0x20))	// DLL
#define UARTA_DLH				(*(unsigned int*)(UARTA_BASE + 0x24))	// DLH
#define UARTA_REVID1			(*(unsigned int*)(UARTA_BASE + 0x28))	// REVID1
#define UARTA_REVID2			(*(unsigned int*)(UARTA_BASE + 0x2C))	// REVID2
#define UARTA_PWREMU_MGMT	(*(unsigned int*)(UARTA_BASE + 0x30))	// PWREMU_MGMT
#define UARTA_PWREMU_MDR	(*(unsigned int*)(UARTA_BASE + 0x34))	// MDR

#define UARTB_BASE	0x02541000
#define UARTB_RBR_THR		(*(unsigned int*)(UARTB_BASE + 0x00))	// RBR (read-only) / THR (write-only)
#define UARTB_IER				(*(unsigned int*)(UARTB_BASE + 0x04))	// IER 	
#define UARTB_IIR_FCR		(*(unsigned int*)(UARTB_BASE + 0x08))	// IIR (read-only) / FCR (write-only) 	
#define UARTB_LCR				(*(unsigned int*)(UARTB_BASE + 0x0C))	// LCR
#define UARTB_MCR				(*(unsigned int*)(UARTB_BASE + 0x10))	// MCR
#define UARTB_LSR				(*(unsigned int*)(UARTB_BASE + 0x14))	// LSR
#define UARTB_MSR				(*(unsigned int*)(UARTB_BASE + 0x18))	// MSR
#define UARTB_SCR				(*(unsigned int*)(UARTB_BASE + 0x1C))	// SCR
#define UARTB_DLL				(*(unsigned int*)(UARTB_BASE + 0x20))	// DLL
#define UARTB_DLH				(*(unsigned int*)(UARTB_BASE + 0x24))	// DLH
#define UARTB_REVID1			(*(unsigned int*)(UARTB_BASE + 0x28))	// REVID1
#define UARTB_REVID2			(*(unsigned int*)(UARTB_BASE + 0x2C))	// REVID2
#define UARTB_PWREMU_MGMT	(*(unsigned int*)(UARTB_BASE + 0x30))	// PWREMU_MGMT
#define UARTB_PWREMU_MDR	(*(unsigned int*)(UARTB_BASE + 0x34))	// MDR


/****************************************************************************
 *
 * NAME
 *      OnPreFileLoaded
 *
 * PURPOSE:
 *      Called by CCS when you do in menu File->LoadProgram, File->LoadSymbols,
 *      etc, before loading anything.
 *
 * USAGE
 *      This routine is a callback routine and called by CCS only.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
OnPreFileLoaded()
{
	if (ON_FILE_LOAD_CODE_ENABLE == 1)
	{
		// System reset to assure reliablity between projects
		if (SYSTEM_RESET_BEFORE_FILE_LOAD_ENABLE == 1)
		{
			GEL_TextOut( "System Reset...\n" );
			GEL_AdvancedReset("System Reset");
			GEL_TextOut( "System Reset... Done.\n" );
			// Let core get stable from reset
			Wait_Soft(4000);
		}

		// Purge all the cache
		Invalidate_Cache();

		// Disable interrupts
		IER = 0;

		// Is used to be sure dsp is ready to load a file
		// Can be comment out if not needed...  (Must be used if using DDR, see OnReset() which is called by CCS when GEL_Reset() is executed)
		GEL_TextOut( "DSP Reset CPU...\n" );
		GEL_Reset();
		GEL_TextOut( "DSP Reset CPU... Done.\n" );

		// Slow down the speed at which the cores get their code loaded to maintain JTAG stability when using multiple cores simultaneously.
		Wait_Soft(5000 + (DNUM * 10000));
	}
}


/****************************************************************************
 *
 * NAME
 *      StartUp
 *
 * PURPOSE:
 *      Perform CCS Memory Map configuration.
 *      This function is called each time CCS is started.
 *
 * USAGE
 *      This routine is a callback routine and called by CCS only.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
StartUp( )
{
    Setup_Memory_Map( );
}


/*--------------------------------------------------------------*/
/* OnTargetConnect()                                            */
/* This function is called by CCS when you do Debug->Connect on */
/* CCS 3.X.                                                     */
/*--------------------------------------------------------------*/
OnTargetConnect()
{
    /*------------------------------------------------------*/
    /* GEL_Reset() is used to deal with the worst case      */
    /* senario of unknown target state.  If for some reason */
    /* a reset is not desired upon target connection,       */
    /* GEL_Reset() may be removed and replaced with         */
    /* something "less brutal" like a cache initialization  */
    /* function.                                            */
    /*------------------------------------------------------*/
    //GEL_Reset();
    //Set_DSP_Cache();
	if (ON_TARGET_CONNECT_CODE_ENABLE == 1)
	{
		if (DNUM == 0)
		{
			Global_Default_Setup();
		}
		else
		{
			// Set DSP cache to pre defined values...
			Set_DSP_Cache();
		}
		// Slow down the speed at which the cores connect to maintain JTAG stability when using multiple cores simultaneously.
		Wait_Soft(5000 + (DNUM * 5000));
	}
}


/*--------------------------------------------------------------*/
/* OnReset()                                                    */
/* This function is called by CCS when you do Debug->Reset.    */
/* The goal is to put the C6x into a known good state with      */
/* respect to cache, edma and interrupts.                       */
/*--------------------------------------------------------------*/
OnReset( int nErrorCode )
{
	if (ON_RESET_CODE_ENABLE == 1)
	{
		if (DNUM == 0)
		{
			// Setup DDR timing @ 533.3 MHz (ext clock * 8)
			//xmc_setup();
			//Set_DDR3_533_3_MHz();

			// Setup DDR
			//xmc_setup();
			//ddr3_setup_auto_lvl_1333(0);

			// Wait for DDR to be stable before continuing.
			//Wait_Soft(4000);
		}
		ddr3_setup(0);
		Wait_Soft(5000 + (DNUM * 15000));
	}
}

/*--------------------------------------------------------------*/
/* xmc_setup()                                                  */
/* XMC MPAX register setting to access DDR3 config space        */
/*--------------------------------------------------------------*/

#define XMC_BASE_ADDR (0x08000000)
#define XMPAX2_L     (*(int*)(XMC_BASE_ADDR + 0x00000010))
#define XMPAX2_H     (*(int*)(XMC_BASE_ADDR + 0x00000014))

xmc_setup()
{  
    	/* mapping for ddr emif registers XMPAX*2 */
    	XMPAX2_L = 0x100000FF;     /* replacement addr + perm*/
    	XMPAX2_H =  0x2100000B;    /* base addr + seg size (64KB)*/	//"1B"-->"B" by xj
		GEL_TextOut("XMC setup complete.\n");
}

/*--------------------------------------------------------------*/
/* ddr3_setup()                                                  */
/* DDR3 initialization                                          */
/*--------------------------------------------------------------*/
ddr3_setup(int index)
{
    int i,TEMP,startlo, stoplo,starthi, stophi;
    unsigned int multiplier, divider;
    KICK0 = KICK0_UNLOCK;
    KICK1 = KICK1_UNLOCK;
    
	if(index == 0){// DDR3-1333 MHz configuration
		/***************** DDR3 PLL Configuration ************/
        
        multiplier = 19;
        divider    = 0;
        
        /* Usage Note 9: For optimal PLL operation, the ENSAT bit in the PLL control *
         * registers for the Main PLL, DDR3 PLL, and PA PLL should be set to 1.      *
         * The PLL initialization sequence in the boot ROM sets this bit to 0 and    *
         * could lead to non-optimal PLL operation. Software can set the bit to the  *
         * optimal value of 1 after boot                                             *
         * DDR3PLLCTL1 Bit map                                                       *
         * |31...7   |6     |5 4       |3...0      |                                 *
         * |Reserved |ENSAT |Reserved  |BWADJ[11:8]|                                 */
		DDR3PLLCTL1 |= 0x00000040;
        
        /* Put the PLL in PLL Mode                                                   *
         * DDR3PLLCTL0 Bit map                                                       *
         * |31...24    |23     |22...19       |18...6   |5...0 |                     *
         * |BWADJ[7:0] |BYPASS |Reserved      |PLLM     |PLLD  |                     */
		DDR3PLLCTL0 |= 0x00800000;
		
        /* Program the necessary mulipliers/dividers and BW adjustments              *
         * Set the divider values                                                    */
        DDR3PLLCTL0 &= ~(0x0000003F);
        DDR3PLLCTL0 |= (divider & 0x00000003F);
         
        /* Set the multipler values */
        DDR3PLLCTL0 &= ~(0x0007FFC0);
        DDR3PLLCTL0 |= ((multiplier << 6) & 0x0007FFC0);
        
        /* Set the BWADJ */
        TEMP = ((multiplier + 1) >> 1) - 1;
        DDR3PLLCTL0 &= ~(0xFF000000);
        DDR3PLLCTL0 |= ((TEMP << 24) & 0xFF000000);
        DDR3PLLCTL1 &= ~(0x0000000F);
        DDR3PLLCTL1 |= ((TEMP >> 8) & 0X0000000F);
        
        /* In PLL Controller, reset the PLL (bit 13 in DDR3PLLCTL1 register)        */
        DDR3PLLCTL1 |= 0x00002000;
        
        /* Wait for the PLL Reset time (min: 5 us)                                   */
        for(i = 0; i < 1000; i++);
        
        /* In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset */
        DDR3PLLCTL1 &= ~(0x00002000);
        
        /* Wait at least 500 * REFCLK cycles * PLLD (this is the PLL lock time) */
        for(i = 0; i < 1000; i++);
        
        /* Put the PLL in PLL Mode                                                     *
         * DDR3PLLCTL0 Bit Map                                                         *
         * |31...24     |23     |22...19        |18...6     |5...0  |                  *
         * |BWADJ[7:0]  |BYPASS |Reserved       |PLLM       |PLLD   |                  */
        DDR3PLLCTL0 &= ~(0x00800000); /* Reset bit 23 */
         
        GEL_TextOut( "DDR3 PLL Setup... Done.\n" );
		
		/**************** 3.0 Leveling Register Configuration ********************/
		/* Using partial automatic leveling due to errata */

		/**************** 3.2 Invert Clock Out and set DLL lock time to maximum ********************/
		DDR3_CONFIG_REG_0  &= ~(0x007FE000);  // clear ctrl_slave_ratio field
		DDR3_CONFIG_REG_0  |= 0x00200000;     // set ctrl_slave_ratio to 0x100
		DDR3_CONFIG_REG_12 |= 0x08000000;     // Set invert_clkout = 1
		DDR3_CONFIG_REG_0  |= 0xF;            // set dll_lock_diff to 15
			
		//Values with invertclkout = 1
		/**************** 3.3+3.4 Partial Automatic Leveling ********************/
		//set bit 9, leave bits 8:0 default 0x34
		DDR3_CONFIG_REG_52 |= 0x00000200;
		DDR3_CONFIG_REG_53 |= 0x00000200;
		DDR3_CONFIG_REG_54 |= 0x00000200;
		DDR3_CONFIG_REG_55 |= 0x00000200;
		DDR3_CONFIG_REG_56 |= 0x00000200;
		DDR3_CONFIG_REG_57 |= 0x00000200;
		DDR3_CONFIG_REG_58 |= 0x00000200;
		DDR3_CONFIG_REG_59 |= 0x00000200;
		DDR3_CONFIG_REG_60 |= 0x00000200;
		
		DATA0_WRLVL_INIT_RATIO = 0x20;
		DATA1_WRLVL_INIT_RATIO = 0x24;
		DATA2_WRLVL_INIT_RATIO = 0x3A;
		DATA3_WRLVL_INIT_RATIO = 0x38;
		DATA4_WRLVL_INIT_RATIO = 0x51;
		DATA5_WRLVL_INIT_RATIO = 0x5E;
		DATA6_WRLVL_INIT_RATIO = 0x5E;
		DATA7_WRLVL_INIT_RATIO = 0x5E;
		DATA8_WRLVL_INIT_RATIO = 0x44;

		DATA0_GTLVL_INIT_RATIO = 0xA1;
		DATA1_GTLVL_INIT_RATIO = 0xA0;
		DATA2_GTLVL_INIT_RATIO = 0xA7;
		DATA3_GTLVL_INIT_RATIO = 0xA9;
		DATA4_GTLVL_INIT_RATIO = 0xCA;
		DATA5_GTLVL_INIT_RATIO = 0xBE;
		DATA6_GTLVL_INIT_RATIO = 0xDD;
		DATA7_GTLVL_INIT_RATIO = 0xDD;
		DATA8_GTLVL_INIT_RATIO = 0xBA;
	  
		//Do a PHY reset. Toggle DDR_PHY_CTRL_1 bit 15 0->1->0
		DDR_DDRPHYC &= ~(0x00008000);
		DDR_DDRPHYC |= (0x00008000);
		DDR_DDRPHYC &= ~(0x00008000);

		/***************** 2.3 Basic Controller and DRAM configuration ************/
		DDR_SDRFC    = 0x00005162;    // enable configuration 

		DDR_SDTIM1   = 0x1113783C;
		DDR_SDTIM2   = 0x304F7FE3;
		DDR_SDTIM3   = 0x559F849F;
	 
		DDR_DDRPHYC  = 0x0010010F;
		DDR_ZQCFG    = 0x70073214; 
		DDR_PMCTL    = 0x0;
		DDR_SDCFG    = 0x63062A32; //New value with DYN_ODT disabled and SDRAM_DRIVE = RZQ/7 //0x63222A32;    // last config write DRAM init occurs
		DDR_SDRFC 	 = 0x00001450; //Refresh rate = (7.8*666MHz]

		DDR_RDWR_LVL_RMP_CTRL = 0x80000000; //enable full leveling
		DDR_RDWR_LVL_CTRL 	 = 0x80000000; //Trigger full leveling - This ignores read DQS leveling result and uses ratio forced value 							//(0x34) instead
		
		//Wait for min 1048576 DDR clock cycles for leveling to complete = 1048576 * 1.5ns = 1572864ns = 1.57ms.
		//Actual time = ~10-15 ms

		GEL_TextOut("DDR3-1333, 64-bit, initialization is complete.\n");
	}
	
	if(index == 1){// DDR3-800 MHz configuration
		/***************** 2.2 DDR3 PLL Configuration ************/
        
        multiplier = 5;
        divider    = 0;
        
        /* Usage Note 9: For optimal PLL operation, the ENSAT bit in the PLL control *
         * registers for the Main PLL, DDR3 PLL, and PA PLL should be set to 1.      *
         * The PLL initialization sequence in the boot ROM sets this bit to 0 and    *
         * could lead to non-optimal PLL operation. Software can set the bit to the  *
         * optimal value of 1 after boot                                             *
         * DDR3PLLCTL1 Bit map                                                       *
         * |31...7   |6     |5 4       |3...0      |                                 *
         * |Reserved |ENSAT |Reserved  |BWADJ[11:8]|                                 */
		DDR3PLLCTL1 |= 0x00000040;
        
        /* Put the PLL in PLL Mode                                                   *
         * DDR3PLLCTL0 Bit map                                                       *
         * |31...24    |23     |22...19       |18...6   |5...0 |                     *
         * |BWADJ[7:0] |BYPASS |Reserved      |PLLM     |PLLD  |                     */
		DDR3PLLCTL1 |= 0x00800000;
		
        /* Program the necessary mulipliers/dividers and BW adjustments              *
         * Set the divider values                                                    */
        DDR3PLLCTL0 &= ~(0x0000003F);
        /* Desired divider values are zero. To change, use:                          *
         * DDR3PLLCTL0 |= (DIVIDER_VALUE & 0x00000003F);                             */
         
        /* Set the multipler values */
        DDR3PLLCTL0 &= ~(0x0007FFC0);
        DDR3PLLCTL0 |= ((multiplier << 6) & 0x0007FFC0);
        
        /* Set the BWADJ */
        TEMP = ((multiplier + 1) >> 1) - 1;
        DDR3PLLCTL0 &= ~(0xFF000000);
        DDR3PLLCTL0 |= ((TEMP << 24) & 0xFF000000);
        DDR3PLLCTL1 &= ~(0x0000000F);
        DDR3PLLCTL1 |= ((TEMP >> 8) & 0X0000000F);
        
        /* In PLL Controller, reset the PLL (bit 13 in DDR3PLLCTL1 register)        */
        DDR3PLLCTL1 |= 0x00002000;
        
        /* Wait for the PLL Reset time (min: 5 us)                                   */
        for(i = 0; i < 1000; i++);
        
        /* In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset */
        DDR3PLLCTL1 &= ~(0x00002000);
        
        /* Wait at least 500 * REFCLK cycles * PLLD (this is the PLL lock time) */
        for(i = 0; i < 1000; i++);
        
        /* Put the PLL in PLL Mode                                                     *
         * DDR3PLLCTL0 Bit Map                                                         *
         * |31...24     |23     |22...19        |18...6     |5...0  |                  *
         * |BWADJ[7:0]  |BYPASS |Reserved       |PLLM       |PLLD   |                  */
        DDR3PLLCTL0 &= ~(0x00800000); /* Reset bit 23 */
         
        GEL_TextOut( "DDR3 PLL Setup... Done.\n" );
		
		/**************** 3.0 Leveling Register Configuration ********************/
		/* Using partial automatic leveling due to errata */

		/**************** 3.2 Invert Clock Out and set DLL lock time to maximum ********************/
		DDR3_CONFIG_REG_0  &= ~(0x007FE000);  // clear ctrl_slave_ratio field
		DDR3_CONFIG_REG_0  |= 0x00200000;     // set ctrl_slave_ratio to 0x100
		DDR3_CONFIG_REG_12 |= 0x08000000;     // Set invert_clkout = 1
		DDR3_CONFIG_REG_0  |= 0xF;            // set dll_lock_diff to 15
			
		//Values with invertclkout = 1
		/**************** 3.3+3.4 Partial Automatic Leveling ********************/
		//set bit 9, leave bits 8:0 default 0x34
		DDR3_CONFIG_REG_52 |= 0x00000200;
		DDR3_CONFIG_REG_53 |= 0x00000200;
		DDR3_CONFIG_REG_54 |= 0x00000200;
		DDR3_CONFIG_REG_55 |= 0x00000200;
		DDR3_CONFIG_REG_56 |= 0x00000200;
		DDR3_CONFIG_REG_57 |= 0x00000200;
		DDR3_CONFIG_REG_58 |= 0x00000200;
		DDR3_CONFIG_REG_59 |= 0x00000200;
		DDR3_CONFIG_REG_60 |= 0x00000200;
		
		DATA0_WRLVL_INIT_RATIO = 0x13;
		DATA1_WRLVL_INIT_RATIO = 0x15;
		DATA2_WRLVL_INIT_RATIO = 0x23;
		DATA3_WRLVL_INIT_RATIO = 0x22;
		DATA4_WRLVL_INIT_RATIO = 0x31;
		DATA5_WRLVL_INIT_RATIO = 0x38;
		DATA6_WRLVL_INIT_RATIO = 0x39;
		DATA7_WRLVL_INIT_RATIO = 0x39;
		DATA8_WRLVL_INIT_RATIO = 0x29;

		DATA0_GTLVL_INIT_RATIO = 0x77;
		DATA1_GTLVL_INIT_RATIO = 0x75;
		DATA2_GTLVL_INIT_RATIO = 0x7B;
		DATA3_GTLVL_INIT_RATIO = 0x7C;
		DATA4_GTLVL_INIT_RATIO = 0x8F;
		DATA5_GTLVL_INIT_RATIO = 0x88;
		DATA6_GTLVL_INIT_RATIO = 0x9B;
		DATA7_GTLVL_INIT_RATIO = 0x9B;
		DATA8_GTLVL_INIT_RATIO = 0x85;
	  
		//Do a PHY reset. Toggle DDR_PHY_CTRL_1 bit 15 0->1->0
		DDR_DDRPHYC &= ~(0x00008000);
		DDR_DDRPHYC |= (0x00008000);
		DDR_DDRPHYC &= ~(0x00008000);

		/***************** 2.3 Basic Controller and DRAM configuration ************/
		DDR_SDRFC    = 0x000030D4;    // enable configuration 

		DDR_SDTIM1   = 0x0AAAE523;
		DDR_SDTIM2   = 0x202F7FDA;
		DDR_SDTIM3   = 0x559F82BF;
	 
		DDR_DDRPHYC  = 0x0010010C;
		DDR_ZQCFG    = 0x70073214; 
		DDR_PMCTL    = 0x0;
		DDR_SDCFG    = 0x63222A32; // last config write DRAM init occurs
		DDR_SDRFC 	 = 0x00000C30; // Refresh rate = (7.8*400MHz]

		DDR_RDWR_LVL_RMP_CTRL = 0x80000000; //enable full leveling
		DDR_RDWR_LVL_CTRL 	 = 0x80000000; //Trigger full leveling - This ignores read DQS leveling result and uses ratio forced value 							//(0x34) instead
		
		//Wait for min 1048576 DDR clock cycles for leveling to complete = 1048576 * 2.5ns = 2.621440ns = 2.62ms.
		//Actual time = ~10-15 ms

		GEL_TextOut("DDR3-800, 64-bit, initialization is complete.\n");
	}	
}

/*--------------------------------------------------------------*/
/* EVMTCI6614LXE MENU                                              */
/*--------------------------------------------------------------*/
menuitem "EVMTCI6614LXE MENU";

/****************************************************************************
 *
 * NAME
 *      Global_Default_Setup
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Global_Default_Setup()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Global_Default_Setup()
{
    GEL_TextOut( "Global Default Setup...\n" );
    Global_Default_Setup_Silent();
    GEL_TextOut( "Global Default Setup... Done.\n" );
}

hotmenu Memory_Test()
{
	//int data_set[4];
	//= {0xAAAAAAAA, 0x55555555, 0xFFFFFFFF, 0x00000000};
	unsigned int write_data = 0xAAAAAAAA;
	unsigned int read_data = 0x0;
	unsigned int errors = 0;
	int dw;
	unsigned int i, mem_start, mem_size, mem_location;
	mem_start = DDR3_BASE_ADDRESS + (DNUM * 0x01000000);
	mem_size = 0x100;
	for(dw=0;dw<4;dw++)
	{
		if (dw == 0) write_data = 0xAAAAAAAA;
		if (dw == 1) write_data = 0x55555555;
		if (dw == 2) write_data = 0xFFFFFFFF;
		if (dw == 3) write_data = 0x00000000;
		mem_location = mem_start;
		GEL_TextOut( "Memory Test Write Core: %d, Mem Start: 0x%x, Mem Size: 0x%x, value: 0x%x ...\n",,2,,,DNUM,mem_start,mem_size,write_data);
		for(i=0;i<mem_size;i++)
		{
			*( unsigned int* )(mem_location) = write_data;
			mem_location += 4;
		}
		mem_location = mem_start;
		GEL_TextOut( "Memory Test Read Core: %d, Mem Start: 0x%x, Mem Size: 0x%x ...\n",,2,,,DNUM,mem_start,mem_size);
		for (i=0;i<mem_size;i++)
		{
			read_data = *( unsigned int* )(mem_location);
			if (read_data != write_data)
			{
				GEL_TextOut("DDR3 Data Error: DSP Core: %d, Mem Addr: 0x%x, read: 0x%x, expected: 0x%x \n",,2,,,DNUM,(DDR3_BASE_ADDRESS + (i * 4)),read_data,write_data);
				errors++;
			}
			mem_location += 4;
		}
		if (errors == 0)
		{
			GEL_TextOut( "Memory Test Done, no errors found.\n" );
		}
		else
		{
			GEL_TextOut("Memory Test Done, %d errors were encounterd. \n",,2,,,errors);
		}
	}
	GEL_TextOut( "All Memory Test Completed on core: %d with %d errors.\n",,2,,,DNUM,errors);
}

/****************************************************************************
 *
 * NAME
 *      Invalidate_Cache
 *
 * PURPOSE:
 *      Invalidate L1P, L1D and L2 cache (purge all cache contents).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Invalidate_Cache()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Invalidate_Cache()
{
    GEL_TextOut( "Invalidate All Cache...\n" );

    /* Invalidate L1P cache */
    *(int*)L1PINV = 1;

    // Wait for cache operation to finish
    // Set timeout before polling...
    Set_Timeout(GTIMEOUT);

    // Wait for transition to finish for max timeout time...
    while( Get_Timeout() && ( *(int*)L1PINV & 0x0001 ) );

    // Check if we got timeout error while waiting
    if (!Get_Timeout())
    {
        GEL_TextOut( "Invalidate All Cache... Timeout Error #01!\n",,2,,,);
    }

    /* Invalidate L1D cache */
    *(int*)L1DINV = 1;

    // Wait for cache operation to finish
    // Set timeout before polling...
    Set_Timeout(GTIMEOUT);

    // Wait for transition to finish for max timeout time...
    while( Get_Timeout() && ( *(int*)L1DINV & 0x0001 ) );

    // Check if we got timeout error while waiting
    if (!Get_Timeout())
    {
        GEL_TextOut( "Invalidate All Cache... Timeout Error #02!\n",,2,,,);
    }

    /* Invalidate L2 cache */
    *(int*)L2INV = 1;

    // Wait for cache operation to finish
    // Set timeout before polling...
    Set_Timeout(GTIMEOUT);

    // Wait for transition to finish for max timeout time...
    while( Get_Timeout() && ( *(int*)L2INV & 0x0001 ) );

    // Check if we got timeout error while waiting
    if (!Get_Timeout())
    {
        GEL_TextOut( "Invalidate All Cache... Timeout Error #03!\n",,2,,,);
    }

    Kill_Timeout();

    GEL_TextOut( "Invalidate All Cache... Done.\n" );
}

hotmenu Reset()
{
    GEL_Reset();
}

hotmenu InitXMC()
{
    xmc_setup();
}

hotmenu InitDDR3_64b_1333()
{
   
   ddr3_setup(0);
}
hotmenu InitDDR3_64b_800()
{
   
   ddr3_setup(1);
}

/****************************************************************************
 *
 * NAME
 *      Set_DSP_Cache
 *
 * PURPOSE:
 *      Setup the DSP caches with predefined cache size.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_DSP_Cache()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_DSP_Cache( )
{
    int l1p, l1d, l2;

    GEL_TextOut( "Setup Cache... \n");

    // Modify for the desired cache settings needed
    //CACHE_L1PCFG = 7;           // L1P on, MAX size
    //CACHE_L1DCFG = 7;           // L1D on, MAX size
    CACHE_L1PCFG = 0;           // L1P off, MAX size
    CACHE_L1DCFG = 0;           // L1D off, MAX size
    CACHE_L2CFG  = 0;           // L2 off, use as RAM

    l1p = (CACHE_L1PCFG & 0x7);

    if ( l1p == 0 )
    {
        GEL_TextOut( "L1P = 0K   \n" );
    }
    if ( l1p == 1 )
    {
        GEL_TextOut( "L1P = 4K   \n" );
    }
    if ( l1p == 2 )
    {
        GEL_TextOut( "L1P = 8K   \n" );
    }
    if ( l1p == 3 )
    {
        GEL_TextOut( "L1P = 16K   \n" );
    }
    if ( l1p >= 4 )
    {
        GEL_TextOut( "L1P = 32K   \n" );
    }

    l1d = (CACHE_L1DCFG & 0x7);
    if ( l1d == 0 )
    {
        GEL_TextOut( "L1D = 0K   \n" );
    }
    if ( l1d == 1 )
    {
        GEL_TextOut( "L1D = 4K   \n" );
    }
    if ( l1d == 2 )
    {
        GEL_TextOut( "L1D = 8K   \n" );
    }
    if ( l1d == 3 )
    {
        GEL_TextOut( "L1D = 16K   \n" );
    }
    if ( l1d >= 4 )
    {
        GEL_TextOut( "L1D = 32K   \n" );
    }

    l2 = (CACHE_L2CFG & 0x7);
    if ( l2 == 0 )
    {
        GEL_TextOut( "L2 = ALL SRAM   \n" );
    }
    if ( l2 == 1 )
    {
        GEL_TextOut( "L2 = 31/32 SRAM   \n" );
    }
    if ( l2 == 2 )
    {
        GEL_TextOut( "L2 = 15/16 SRAM   \n" );
    }
    if ( l2 == 3 )
    {
        GEL_TextOut( "L2 = 7/8 SRAM   \n" );
    }
    if ( l2 == 4 )
    {
        GEL_TextOut( "L2 = 3/4 SRAM   \n" );
    }
    if ( l2 == 5 )
    {
        GEL_TextOut( "L2 = 1/2 SRAM   \n" );
    }
    if ( l2 >= 6 )
    {
        GEL_TextOut( "L2 = ALL CACHE   \n" );
    }

    GEL_TextOut( "Setup Cache... Done.\n");
}

/****************************************************************************
 *
 * NAME
 *      Set_Psc_All_On
 *
 * PURPOSE:
 *      Enable all PSC modules and DSP power domains on ALWAYSON, and wait
 *      for these power transitions to complete.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Psc_All_On()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Psc_All_On( )
{
    unsigned int i=0;

   // Only core0 can set PSC
    if (DNUM == 0)
    {
        GEL_TextOut( "Power on all PSC modules and DSP domains... \n");
    
        Set_PSC_State(PD0, LPSC_SMARTRFLX, PSC_ENABLE);
		Set_PSC_State(PD0, LPSC_DDR3, PSC_ENABLE);
		Set_PSC_State(PD0, LPSC_VUSR, PSC_ENABLE);
		Set_PSC_State(PD0, LPSC_VCP2A, PSC_ENABLE);
		Set_PSC_State(PD1, LPSC_DEBUG, PSC_ENABLE);
		Set_PSC_State(PD1, LPSC_TETB, PSC_ENABLE);
		Set_PSC_State(PD2, LPSC_PA, PSC_ENABLE);
		Set_PSC_State(PD2, LPSC_SGMII, PSC_ENABLE);
		Set_PSC_State(PD2, LPSC_SA, PSC_ENABLE);
		Set_PSC_State(PD3, LPSC_PCIE, PSC_ENABLE);
		Set_PSC_State(PD4, LPSC_SRIO, PSC_ENABLE);
		Set_PSC_State(PD5, LPSC_BCP, PSC_ENABLE);
		Set_PSC_State(PD6, LPSC_ARM, PSC_ENABLE);
		Set_PSC_State(PD7, LPSC_MSMCRAM, PSC_ENABLE);
		Set_PSC_State(PD8, LPSC_RACA_RACB, PSC_ENABLE);
		Set_PSC_State(PD8, LPSC_TAC, PSC_ENABLE);
		Set_PSC_State(PD9, LPSC_FFTCA_FFTCB, PSC_ENABLE);
		Set_PSC_State(PD10, LPSC_AIF2, PSC_ENABLE);
		Set_PSC_State(PD11, LPSC_TCP3DA, PSC_ENABLE);
		Set_PSC_State(PD12, LPSC_VCP2B, PSC_ENABLE);
		Set_PSC_State(PD12, LPSC_VCP2C, PSC_ENABLE);
		Set_PSC_State(PD12, LPSC_VCP2D, PSC_ENABLE);
		Set_PSC_State(PD13, LPSC_C0_TIM0, PSC_ENABLE);
		Set_PSC_State(PD14, LPSC_C1_TIM1, PSC_ENABLE);
		Set_PSC_State(PD14, LPSC_C1_RSA, PSC_ENABLE);
		Set_PSC_State(PD15, LPSC_C2_TIM2, PSC_ENABLE);
		Set_PSC_State(PD15, LPSC_C2_RSA, PSC_ENABLE);
		Set_PSC_State(PD16, LPSC_C3_TIM3, PSC_ENABLE);
		Set_PSC_State(PD17, LPSC_TCP3dB, PSC_ENABLE);
    
        GEL_TextOut( "Power on all PSC modules and DSP domains... Done.\n" );
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set PSC.\n",,2,,,DNUM);
    }
}


/****************************************************************************
 *
 * NAME
 *      Set_PSC_State
 *
 * PURPOSE:
 *      Set a new power state for the specified domain id in a power controler
 *      domain. Wait for the power transition to complete.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_PSC_State(unsigned int pd,unsigned int id,unsigned int state)
 *
 *      pd    - (i) power domain.
 *
 *      id    - (i) module id to use for module in the specified power domain
 *
 *      state - (i) new state value to set
 *                  0 = RESET
 *                  1 = SYNC RESET
 *                  2 = DISABLE
 *                  3 = ENABLE
 *
 * RETURN VALUE
 *      0 if ok, !=0 for error
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_PSC_State(unsigned int pd,unsigned int id,unsigned int state)
{
    unsigned int* mdctl;
    unsigned int* mdstat;
    unsigned int* pdctl;
    int ret=0;

    // Only core0 can set PSC
    if (DNUM == 0)
    {
        mdctl = ( unsigned int* )(PSC_MDCTL_BASE + ( 4 * id ));
        mdstat = ( unsigned int* )( PSC_MDSTAT_BASE + ( 4 * id ));
        pdctl = ( unsigned int* )(PSC_PDCTL_BASE + ( 4 * pd ));
    
        // If state is already set, do nothing
        if ( ( *mdstat & 0x1f ) == state )
        {
            return(0);
        }
    
        // Wait for GOSTAT to clear
        Set_Timeout(GTIMEOUT);
        while( Get_Timeout() && (PSC_PTSTAT & (0x1 << pd)) != 0 );
    
        // Check if we got timeout error while waiting
        if (!Get_Timeout())
        {
            GEL_TextOut( "Set_PSC_State... Timeout Error #01 pd=%d, md=%d!\n",,2,,,pd,id);
            ret=1;
        }
        else
        {
            // Set power domain control
            *pdctl = (*pdctl) | 0x00000001;
            
            // Set MDCTL NEXT to new state
            *mdctl = ((*mdctl) & ~(0x1f)) | state;
    
            // Start power transition by setting PTCMD GO to 1
            PSC_PTCMD = (PSC_PTCMD) | (0x1<<pd);
    
            // Wait for PTSTAT GOSTAT to clear
            Set_Timeout(GTIMEOUT);
            while( Get_Timeout() && (PSC_PTSTAT & (0x1 << pd)) != 0 );
    
            // Check if we got timeout error while waiting
            if (!Get_Timeout())
            {
                GEL_TextOut( "Set_PSC_State... Timeout Error #02 pd=%d, md=%d!\n",,2,,,pd,id);
                ret=2;
            }
            else
            {
                // Verify state changed
                Set_Timeout(GTIMEOUT);
                while(Get_Timeout() && ( *mdstat & 0x1f ) != state );
    
                // Check if we got timeout error while waiting
                if (!Get_Timeout())
                {
                    GEL_TextOut( "Set_PSC_State... Timeout Error #03 pd=%d, md=%d!\n",,2,,,pd,id);
                    ret=3;
                }
            }
        }
    
        // Kill the currently running timeout
        Kill_Timeout();
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set PSC.\n",,2,,,DNUM);
    }

    return(ret);
}

/****************************************************************************
 *
 * NAME
 *      Set_Timeout
 *
 * PURPOSE:
 *      Starts a timeout period of msec. The running timeout period can be
 *      query with Get_Timeout. To kill a running timeout before the end,
 *      call Kill_Timeout. Only one timeout period can be used at any time.
 *      A timeout period can be used to measure a period of time while doing
 *      anything else. Not accurate, sets timer at least as big as desired.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Timeout(msec)
 *
 *      msec - (i) timeout period in msec (not very precise < sec range)
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_Timeout(msec)
{
    // Cancel the current timer if not already expired
    GEL_CancelTimer(TIMEOUT_ID);

    // Starts the timeout period
    _GEL_Global_Timeout1=1;

    // Setup a callback routine with specified timeout
    GEL_SetTimer(msec, TIMEOUT_ID, "_Timeout_Callback()");
}

/****************************************************************************
 *
 * NAME
 *      Get_Timeout
 *
 * PURPOSE:
 *      Query the running state of a timeout period started by Set_Timeout.
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Get_Timeout()
 *
 * RETURN VALUE
 *      0:expired, 1:running
 *
 * REFERENCE
 *
 ****************************************************************************/
Get_Timeout()
{
    if (!_GEL_Global_Timeout1)
    {
        // Cancel the current timer
        GEL_CancelTimer(TIMEOUT_ID);
    }

    // Return the global timeout status 1=running, 0=expired
    return _GEL_Global_Timeout1;
}

/****************************************************************************
 *
 * NAME
 *      Kill_Timeout
 *
 * PURPOSE:
 *      Cancel a running timeout period before it expires
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Kill_Timeout()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Kill_Timeout()
{
    // Cancel the current timer
    GEL_CancelTimer(TIMEOUT_ID);

    // The timeout period is expired
    _GEL_Global_Timeout1=0;
}

/****************************************************************************
 *
 * NAME
 *      _Timeout_Callback
 *
 * PURPOSE:
 *      Internal Callback function used by Set_timeout
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine must not be called by itself.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
_Timeout_Callback()
{
    // The timeout period is expired
    _GEL_Global_Timeout1=0;
}

/****************************************************************************
 *
 * NAME
 *      Setup_Memory_Map
 *
 * PURPOSE:
 *      Setup the Memory Map for EVMTCI6614LXE.
 *      Defined memory location avoid debugger access outside these locations.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Setup_Memory_Map()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *      Based on TMS320TCI6614 datasheet.
 *
 ****************************************************************************/
hotmenu Setup_Memory_Map( )
{
    GEL_TextOut("Setup_Memory_Map...\n",,);

    GEL_MapOn( );
    GEL_MapReset( );

    if (AVV_MEM_MAP == 1)
	{
		GEL_MapAddStr( 0x00800000, 0, 0x00004000, "PRAM", 0 );   // Local L2 SRAM L2RAM_INPUT_DAT_MEM
		GEL_MapAddStr( 0x00804000, 0, 0x00000040, "PRAM", 0 );   // Local L2 SRAM L2RAM_TEST_RESULTS
		GEL_MapAddStr( 0x00804040, 0, 0x000fbfc0, "R|W|AS4", 0 );   // Local L2 SRAM
	}
	else
	{
		GEL_MapAddStr( 0x00800000, 0, 0x00100000, "R|W|AS4", 0 );   // Local L2 SRAM
	}
    GEL_MapAddStr( 0x00E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Local L1P SRAM
    GEL_MapAddStr( 0x00F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Local L1D SRAM
    GEL_MapAddStr( 0x01000000, 0, 0x01C00000, "R|W|AS4", 0 );   // C66x CorePac Registers
    GEL_MapAddStr( 0x01D00000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 0
    GEL_MapAddStr( 0x01D08000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 1
    GEL_MapAddStr( 0x01D10000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 2
    GEL_MapAddStr( 0x01D18000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 3
    GEL_MapAddStr( 0x01D20000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 4
    GEL_MapAddStr( 0x01D28000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 5
    GEL_MapAddStr( 0x01D30000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 6
    GEL_MapAddStr( 0x01D38000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 7
    GEL_MapAddStr( 0x01D40000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 8
    GEL_MapAddStr( 0x01D48000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 9
    GEL_MapAddStr( 0x01D50000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 10
    GEL_MapAddStr( 0x01D58000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 11
    GEL_MapAddStr( 0x01D60000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 12
    GEL_MapAddStr( 0x01D68000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 13
    GEL_MapAddStr( 0x01D70000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 14
    GEL_MapAddStr( 0x01D78000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 15
    GEL_MapAddStr( 0x01F00000, 0, 0x00080000, "R|W|AS4", 0 );   // AIF2 Control
    GEL_MapAddStr( 0x01F80000, 0, 0x00010000, "R|W|AS4", 0 );   // RAC_B - FEI Control
    GEL_MapAddStr( 0x01F90000, 0, 0x00010000, "R|W|AS4", 0 );   // RAC_B - BEI Control
    GEL_MapAddStr( 0x01FA0000, 0, 0x00020000, "R|W|AS4", 0 );   // RAC_B - GCCP 0 Control
    GEL_MapAddStr( 0x01FC0000, 0, 0x00020000, "R|W|AS4", 0 );   // RAC_B - GCCP 1 Control
    GEL_MapAddStr( 0x02000000, 0, 0x00090000, "R|W|AS4", 0 );   // Packet Accelerator Configuration
    GEL_MapAddStr( 0x02090000, 0, 0x00030000, "R|W|AS4", 0 );   // Ethernet Switch Subsystem Configuration
    GEL_MapAddStr( 0x020C0000, 0, 0x00040000, "R|W|AS4", 0 );   // Crypto Subsystem Configuration
    GEL_MapAddStr( 0x02100000, 0, 0x00010000, "R|W|AS4", 0 );   // RAC_A - FEI Control
    GEL_MapAddStr( 0x02110000, 0, 0x00010000, "R|W|AS4", 0 );   // RAC_A - BEI Control
    GEL_MapAddStr( 0x02120000, 0, 0x00020000, "R|W|AS4", 0 );   // RAC_A - GCCP 0 Control
    GEL_MapAddStr( 0x02140000, 0, 0x00020000, "R|W|AS4", 0 );   // RAC_A - GCCP 1 Control
    GEL_MapAddStr( 0x02180000, 0, 0x00008000, "R|W|AS4", 0 );   // TAC - FEI Control
    GEL_MapAddStr( 0x02188000, 0, 0x00008000, "R|W|AS4", 0 );   // TAC - BEI Control
    GEL_MapAddStr( 0x02190000, 0, 0x00010000, "R|W|AS4", 0 );   // TAC - SGCCP 0 Control
    GEL_MapAddStr( 0x021A0000, 0, 0x00010000, "R|W|AS4", 0 );   // TAC - SGCCP 1 Control
    GEL_MapAddStr( 0x021C0000, 0, 0x00000400, "R|W|AS4", 0 );   // TCP3d-A
    GEL_MapAddStr( 0x021C8000, 0, 0x00000400, "R|W|AS4", 0 );   // TCP3d-B
    GEL_MapAddStr( 0x021D0000, 0, 0x00000100, "R|W|AS4", 0 );   // VCP2-A
    GEL_MapAddStr( 0x021D4000, 0, 0x00000100, "R|W|AS4", 0 );   // VCP2-B
    GEL_MapAddStr( 0x021D8000, 0, 0x00000100, "R|W|AS4", 0 );   // VCP2-C
    GEL_MapAddStr( 0x021DC000, 0, 0x00000100, "R|W|AS4", 0 );   // VCP2-D
    GEL_MapAddStr( 0x021E0000, 0, 0x00001000, "R|W|AS4", 0 );   // TCP3e
    GEL_MapAddStr( 0x021F0000, 0, 0x00000800, "R|W|AS4", 0 );   // FFTC-A Configuration
    GEL_MapAddStr( 0x021F4000, 0, 0x00000800, "R|W|AS4", 0 );   // FFTC-B Configuration
    GEL_MapAddStr( 0x02200000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer0
    GEL_MapAddStr( 0x02210000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer1
    GEL_MapAddStr( 0x02220000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer2
    GEL_MapAddStr( 0x02230000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer3
    GEL_MapAddStr( 0x02240000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer4
    GEL_MapAddStr( 0x02250000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer5
    GEL_MapAddStr( 0x02260000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer6
    GEL_MapAddStr( 0x02270000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer7
    GEL_MapAddStr( 0x02310000, 0, 0x00000200, "R|W|AS4", 0 );   // PLL Controller
    GEL_MapAddStr( 0x02320000, 0, 0x00000100, "R|W|AS4", 0 );   // GPIO
    GEL_MapAddStr( 0x02330000, 0, 0x00000400, "R|W|AS4", 0 );   // SmartReflex
    GEL_MapAddStr( 0x02350000, 0, 0x00001000, "R|W|AS4", 0 );   // Power Sleep Controller
    GEL_MapAddStr( 0x02360000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 0
    GEL_MapAddStr( 0x02368000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 1
    GEL_MapAddStr( 0x02370000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 2
    GEL_MapAddStr( 0x02378000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 3
    GEL_MapAddStr( 0x02380000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 4
    GEL_MapAddStr( 0x02440000, 0, 0x00004000, "R|W|AS4", 0 );   // DSP Trace Formatter 0
    GEL_MapAddStr( 0x02450000, 0, 0x00004000, "R|W|AS4", 0 );   // DSP Trace Formatter 1
    GEL_MapAddStr( 0x02460000, 0, 0x00004000, "R|W|AS4", 0 );   // DSP Trace Formatter 2
    GEL_MapAddStr( 0x02470000, 0, 0x00004000, "R|W|AS4", 0 );   // DSP Trace Formatter 3
    GEL_MapAddStr( 0x02530000, 0, 0x00000080, "R|W|AS4", 0 );   // I2C Data & Control
    GEL_MapAddStr( 0x02540000, 0, 0x00000040, "R|W|AS4", 0 );   // UARTA
	 GEL_MapAddStr( 0x02541000, 0, 0x00000040, "R|W|AS4", 0 );   // UARTB
    GEL_MapAddStr( 0x02600000, 0, 0x00002000, "R|W|AS4", 0 );   // Secondary Interrupt Controller (INTC) 0
    GEL_MapAddStr( 0x02604000, 0, 0x00002000, "R|W|AS4", 0 );   // Secondary Interrupt Controller (INTC) 1
    GEL_MapAddStr( 0x02608000, 0, 0x00002000, "R|W|AS4", 0 );   // Secondary Interrupt Controller (INTC) 2
    GEL_MapAddStr( 0x02620000, 0, 0x00000400, "R|W|AS4", 0 );   // Chip-Level Registers
    GEL_MapAddStr( 0x02640000, 0, 0x00000800, "R|W|AS4", 0 );   // Semaphore
    GEL_MapAddStr( 0x02700000, 0, 0x00008000, "R|W|AS4", 0 );   // EDMA Channel Controller (TPCC) 0
    GEL_MapAddStr( 0x02720000, 0, 0x00008000, "R|W|AS4", 0 );   // EDMA Channel Controller (TPCC) 1
    GEL_MapAddStr( 0x02740000, 0, 0x00008000, "R|W|AS4", 0 );   // EDMA Channel Controller (TPCC) 2
    GEL_MapAddStr( 0x02760000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC0 Transfer Controller (TPTC) 0
    GEL_MapAddStr( 0x02768000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC0 Transfer Controller (TPTC) 1
    GEL_MapAddStr( 0x02770000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC1 Transfer Controller (TPTC) 0
    GEL_MapAddStr( 0x02778000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC1 Transfer Controller (TPTC) 1
    GEL_MapAddStr( 0x02780000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC1 Transfer Controller (TPTC) 2
    GEL_MapAddStr( 0x02788000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC1 Transfer Controller (TPTC) 3
    GEL_MapAddStr( 0x02790000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC2 Transfer Controller (TPTC) 0
    GEL_MapAddStr( 0x02798000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC2 Transfer Controller (TPTC) 1
    GEL_MapAddStr( 0x027A0000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC2 Transfer Controller (TPTC) 2
    GEL_MapAddStr( 0x027A8000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC2 Transfer Controller (TPTC) 3
    GEL_MapAddStr( 0x027D0000, 0, 0x00004000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - Core 0
    GEL_MapAddStr( 0x027E0000, 0, 0x00004000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - Core 1
    GEL_MapAddStr( 0x027F0000, 0, 0x00004000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - Core 2
    GEL_MapAddStr( 0x02800000, 0, 0x00004000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - Core 3
    GEL_MapAddStr( 0x02850000, 0, 0x00008000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - System
    GEL_MapAddStr( 0x02900000, 0, 0x00008000, "R|W|AS4", 0 );   // Serial RapidIO Configuration
    GEL_MapAddStr( 0x02A00000, 0, 0x00100000, "R|W|AS4", 0 );   // Queue Manager Subsystem Configuration
    GEL_MapAddStr( 0x08000000, 0, 0x00010000, "R|W|AS4", 0 );   // Extended Memory Controller (XMC) Configuration
    GEL_MapAddStr( 0x0BC00000, 0, 0x00100000, "R|W|AS4", 0 );   // Multicore Shared Memory Controller (MSMC) Config
    GEL_MapAddStr( 0x0C000000, 0, 0x00200000, "R|W|AS4", 0 );   // Multicore Shared Memory (MSM)
    GEL_MapAddStr( 0x10800000, 0, 0x00100000, "R|W|AS4", 0 );   // Core0 L2 SRAM
    GEL_MapAddStr( 0x10E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core0 L1P SRAM
    GEL_MapAddStr( 0x10F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core0 L1D SRAM
    GEL_MapAddStr( 0x11800000, 0, 0x00100000, "R|W|AS4", 0 );   // Core1 L2 SRAM
    GEL_MapAddStr( 0x11E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core1 L1P SRAM
    GEL_MapAddStr( 0x11F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core1 L1D SRAM
    GEL_MapAddStr( 0x12800000, 0, 0x00100000, "R|W|AS4", 0 );   // Core2 L2 SRAM
    GEL_MapAddStr( 0x12E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core2 L1P SRAM
    GEL_MapAddStr( 0x12F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core2 L1D SRAM
    GEL_MapAddStr( 0x13800000, 0, 0x00100000, "R|W|AS4", 0 );   // Core3 L2 SRAM
    GEL_MapAddStr( 0x13E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core3 L1P SRAM
    GEL_MapAddStr( 0x13F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core3 L1D SRAM
    GEL_MapAddStr( 0x20000000, 0, 0x00100000, "R|W|AS4", 0 );   // System Trace Manager (STM) Configuration
    GEL_MapAddStr( 0x20200000, 0, 0x00400000, "R|W|AS4", 0 );   // RAC_B Data
    GEL_MapAddStr( 0x20600000, 0, 0x00100000, "R|W|AS4", 0 );   // TCP3d-B Data
    GEL_MapAddStr( 0x20800000, 0, 0x00100000, "R|W|AS4", 0 );   // TCP3d-A Data
    GEL_MapAddStr( 0x20900000, 0, 0x00002000, "R|W|AS4", 0 );   // TCP3e Data Write Port
    GEL_MapAddStr( 0x20902000, 0, 0x00002000, "R|W|AS4", 0 );   // TCP3e Data Read Port
    GEL_MapAddStr( 0x20B00000, 0, 0x00020000, "R|W|AS4", 0 );   // Boot ROM
    GEL_MapAddStr( 0x20BF0000, 0, 0x00000400, "R|W|AS4", 0 );   // SPI
    GEL_MapAddStr( 0x21000000, 0, 0x00000200, "R|W|AS4", 0 );   // DDR3 EMIF Configuration
    GEL_MapAddStr( 0x21400000, 0, 0x00000400, "R|W|AS4", 0 );   // Hyperlink Config
    GEL_MapAddStr( 0x21800000, 0, 0x00008000, "R|W|AS4", 0 );   // PCIe Config
    GEL_MapAddStr( 0x22A00000, 0, 0x00010000, "R|W|AS4", 0 );   // VCP2_A
    GEL_MapAddStr( 0x22B00000, 0, 0x00010000, "R|W|AS4", 0 );   // VCP2_B
    GEL_MapAddStr( 0x22C00000, 0, 0x00010000, "R|W|AS4", 0 );   // VCP2_C
    GEL_MapAddStr( 0x22D00000, 0, 0x00010000, "R|W|AS4", 0 );   // VCP2_D
    GEL_MapAddStr( 0x33200000, 0, 0x00400000, "R|W|AS4", 0 );   // RAC_A Data
    GEL_MapAddStr( 0x34000000, 0, 0x00200000, "R|W|AS4", 0 );   // Queue Manager Subsystem Data
    GEL_MapAddStr( 0x34C00000, 0, 0x00030000, "R|W|AS4", 0 );   // TAC Data
    GEL_MapAddStr( 0x40000000, 0, 0x10000000, "R|W|AS4", 0 );   // Hyperlink Data
    GEL_MapAddStr( 0x50000000, 0, 0x10000000, "R|W|AS4", 0 );   // SRIO Data
    GEL_MapAddStr( 0x60000000, 0, 0x10000000, "R|W|AS4", 0 );   // PCIe Data
    GEL_MapAddStr( 0x80000000, 0, 0x80000000, "R|W|AS4", 0 );   // DDR3 EMIF Data

    GEL_TextOut( "Setup_Memory_Map... Done.\n" );
}

/****************************************************************************
 *
 * NAME
 *      Core_Info
 *
 * PURPOSE:
 *      Display on the screen information about the current running DSP core
 *
 * USAGE
 *
 *      Called from program or GEL menu
 *
 * RETURN VALUE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Core_Info( )
{
    GEL_TextOut("DSP core #%d\n",,1,,,DNUM);
}


/****************************************************************************
 *
 * NAME
 *      Wait_Soft
 *
 * PURPOSE:
 *      Wait for a specified delay in number of empty loop.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Wait_Soft(nloop)
 *
 *      nloop - (i) number of empty loop to do for delay
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Wait_Soft( int nloop )
{
    int i;

    // 1 sec ~ 40000 loop on P4 3.4GHz
    for( i = 0 ; i < nloop ; i++ )
    {
    }
}


/****************************************************************************
 *
 * NAME
 *      RoundToHigherInt
 *
 * PURPOSE:
 *      This routine will round a float value to higher int.
 *      ex.: RoundToHigherInt(7.1)=8, RoundToHigherInt(7.7)=8,
 *           RoundToHigherInt(7.0)=7
 *
 * USAGE
 *      This routine can be called as:
 *
 *      RoundToHigherInt(fValue)
 *
 *      fValue - (i) float value to be converted.
 *
 * RETURN VALUE
 *      Converted int value.
 *
 * REFERENCE
 *
 ****************************************************************************/
RoundToHigherInt(fValue)
{
    int iResult,iTemp;
    double fTemp, fSTolP, fSTolN, fPar, fZero;

    fSTolP =  1.0e-7;
    fSTolN = -1.0e-7;
    fPar = fValue;
    fZero = 0.0;

    // Compute a truncated value for fValue
    iTemp = fPar;

    // Convert int value to double floating point
    fTemp = iTemp;

    // Compute difference between truncated int and value to be converted
    fTemp = fPar - fTemp;

    // If value to be converted is positive
    if (fPar >= fZero)
    {
        // Verify equality by allowing single precision least digit tolerance 1e-7
        // to catch (int + fSTolP) like exact int value
        if ((fTemp >= fZero) && (fTemp < fSTolP))
            // Do not adjust int because wright on it
            iResult = iTemp;
        else
            // adjust to upper int
            iResult = iTemp + 1;
    }
    else
    {
        fTemp = 1 - fTemp;
        // Negative converted value
        // Verify equality by allowing single precision least digit tolerance 1e-7
        // to catch (int + fSTolP) like exact int value
        if (((fTemp >= fZero) && (fTemp < fSTolP)))
            // adjust to lower int cause we missed it
            iResult = iTemp - 1;
        else
            // Do not adjust int because wright on it
            iResult = iTemp;
    }

    //GEL_TextOut("ceil value:%f, int:%d\n",,,,,fValue, iResult);
    return(iResult);
}


/****************************************************************************
 *
 * NAME
 *      TimeToField
 *
 * PURPOSE:
 *      This routine will convert a ddr timing value in sec to a field integer
 *      value for the ddr timing registers.
 *      Does not validate register field overflow!
 *
 * USAGE
 *      This routine can be called as:
 *
 *      TimeToField(fValue, freq, position)
 *
 *      fValue   - (i) float timing value in sec (to be converted).
 *
 *      freq     - (i) ddr frequency value in Hz.
 *
 *      position - (i) position of field within register.
 *
 * RETURN VALUE
 *      Converted int ddr field value at correct position.
 *
 * REFERENCE
 *
 ****************************************************************************/
TimeToField(fValue, freq, position)
{
    int iResult;

    double fTemp;

    // Convert to double float
    fTemp = fValue;

    iResult = RoundToHigherInt((fTemp * freq)-1);
    iResult = iResult << position;

    return(iResult);
}


/****************************************************************************
 *
 * NAME
 *      ClckToField
 *
 * PURPOSE:
 *      This routine will convert a ddr timing value in clock period unit to
 *      a field integer value for the ddr timing registers.
 *      Does not validate register field overflow!
 *
 * USAGE
 *      This routine can be called as:
 *
 *      ClckToField(value, position)
 *
 *      value    - (i) timing value in clock unit (to be converted).
 *
 *      position - (i) position of field within register.
 *
 * RETURN VALUE
 *      Converted int ddr field value at correct position.
 *
 * REFERENCE
 *
 ****************************************************************************/
ClckToField(value, position)
{
    int iResult;

    iResult = (value - 1) << position;

    return(iResult);
}


/*
	Set_Pll1() - This function executes the main PLL initialization 
	sequence needed to get the main PLL up after coming out of an initial power up 
	before it is locked or after it is already locked.
	
	index value determines multiplier, divier used and clock reference assumed. 
*/
Set_Pll1(int index)
{
	int i, TEMP;
	unsigned int BYPASS_val; 	// get value of the BYPASS field
	unsigned int BWADJ_val; 	// setup BWADJ to be 1/2 the value of PLLM
	unsigned int OD_val;			// setup OD to a fixed /2
	
	float CLKIN_val;
	unsigned int PLLM_val;
	unsigned int PLLD_val;
	unsigned int PLLDIV2_val; //example value for SYSCLK2 (from 6614 data manual) - Corepac Trace Clock
	unsigned int PLLDIV5_val; //example value for SYSCLK5 (from 6614 data manaul) - STM Clock
	unsigned int PLLDIV8_val; //example value for SYSCLK8 (from 6614 data manual) - Slow SYSCLK
	
	unsigned int debug_info_on;
	unsigned int delay;
		
	if(index == 1){ // 122.88 MHz -> 983.40 MHz
		CLKIN_val	= 122.88;	// setup CLKIN to 122.88 MHz
		PLLM_val 	= 16;			// setup PLLM (PLL multiplier) to x16
		PLLD_val		= 1;			// setup PLLD (reference divider) to /1
		OD_val		= 2;			// setup OD (output divider) to /2
	}

	if(index == 2){ //122.88MHz -> 1228.80 MHz
		CLKIN_val	= 122.88;	// setup CLKIN to 122.88 MHz
		PLLM_val 	= 20;			// setup PLLM (PLL multiplier) to x20
		PLLD_val		= 1;			// setup PLLD (reference divider) to /1
		OD_val		= 2;			// setup OD (output divider) to /2
	}
	
	PLLDIV2_val	= 3;			// setup PLL output divider 2 to /3
	PLLDIV5_val	= 5;			// setup PLL output divider 5 to /5
	PLLDIV8_val	= 64;			// setup PLL output divider 8 to /64
	
	BYPASS_val 		= PLL1_SECCTL & ~BYPASS_MASK; 	// get value of the BYPASS field
	BWADJ_val 		= (PLLM_val) >> 1; 	 			// setup BWADJ to be 1/2 the value of PLLM
	OD_val			= 2;									// setup OD to a fixed /2
	
	debug_info_on 	= 0;
	delay 			= 1000; // fix this!
	
	/*
		Unlock Boot Config Registers
	*/
	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;
    
    /* 1. Wait for Stabilization time (min 100 us)                                *
     * The below loop is good enough for the Gel file to get minimum of        *
     * 100 micro seconds, this should be appropriately modified for port       *
     * to a C function                                                         *
     * Minimum delay in GEL can be 1 milli seconds, so program to 1ms=1000us,  *
     * more than required, but should be Okay                                  */
    for(i = 0; i < delay; i++);

	/*
		Step 2: Check if SECCTL bypass is low or high indicating what state the Main PLL is currently in. if 
		the Main PLL is in bypass still (not yet setup) execute the following steps. 
	*/

	if(BYPASS_val != 0x00000000){ // PLL bypass enabled - Execute PLL setup for PLL fresh out of power on reset
		if(debug_info_on){
			GEL_TextOut("Detected PLL bypass enabled: SECCTL[BYPASS] = %x\n",,,,, BYPASS_val);
		}
		/*
			Step 2a: Set MAINPLLCTL1[ENSAT] = 1 - This enables proper biasing of PLL analog circuitry
		*/			
		MAINPLLCTL1 |= (1 << MAIN_ENSAT_OFFSET); 
		if(debug_info_on){	
			GEL_TextOut("(2a) MAINPLLCTL1 = %x\n",,,,, MAINPLLCTL1);
		}		
		
		/*	Step 2b: Set PLLCTL[PLLEN] = 0 This enables bypass in PLL controller MUX */		
		PLL1_PLLCTL &= ~(1 << PLLEN_OFFSET);		
		if(debug_info_on){	
			GEL_TextOut("(2b) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}

        /*	Step 2c: Set PLLCTL[PLLENSRC] = 0 - This enables PLLEN to control PLL controller MUX */	
		PLL1_PLLCTL &= ~(1 << PLLENSRC_OFFSET); //
		if(debug_info_on){	
			GEL_TextOut("(2c) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}	        
		
		/*	Step 2d: Wait 4 reference clock cycles (slowest of ALTCORE or SYSCLK) to make sure 
		that the PLL controller MUX switches properly to bypass. */
		if(debug_info_on){	
			GEL_TextOut("(2d) Delay...\n",,,,,);
		}		
		for(i = 0; i < delay; i++); // this delay is much more than required 		
		
		/* Step 2e: Set SECCTL[BYPASS] = 1 - enables bypass in PLL MUX */	
		PLL1_SECCTL |= (1 << BYPASS_OFFSET);		
		if(debug_info_on){	
			GEL_TextOut("(2e) SECCTL = %x\n",,,,, PLL1_SECCTL);
		}	
		
		/* Step 2f: Set PLLCTL[PLLPWRDN] = 1 - power down the PLL */		
		PLL1_PLLCTL |= (1 << PLLPWRDN_OFFSET);
		if(debug_info_on){	
			GEL_TextOut("(2f) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}	
		
		/*	Step 2g: Wait for at least 5us for the PLL to power down */
		if(debug_info_on){	
			GEL_TextOut("(2g) Delay...\n",,,,,);
		}	
		for(i = 0; i < delay; i++); // this delay is much more than required 

		/*	Step 2h: Set PLLCTL[PLLPWRDN] = 0 - Power the PLL back up */	
		PLL1_PLLCTL &= ~(1 << PLLPWRDN_OFFSET);
		if(debug_info_on){	
			GEL_TextOut("(2h) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}			
		
	}
	else{ // PLL bypass disabled - Execute PLL setup for PLL that has previously been locked
		/* Step 3: Enable Bypass in the PLL Controller */
        if(debug_info_on){	
			GEL_TextOut("Detected PLL bypass disabled: SECCTL[BYPASS] = %x\n",,,,, BYPASS_val);
		}       
        
        /* Step 3a: Set PLLCTL[PLLEN] = 0 - Bypass enabled in PLL controller mux */
        PLL1_PLLCTL &= ~(1 << PLLEN_OFFSET);
        if(debug_info_on){
            GEL_TextOut("(3a) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
        }
        
        /* Step 3b: Set PLLCTL[PLLENSRC] = 0 - Enable PLLEN to control PLL controller mux */
        PLL1_PLLCTL &= ~(1 << PLLENSRC_OFFSET);
        if(debug_info_on){
            GEL_TextOut("(3b) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
        }
        
        /*	Step 3c: Wait 4 reference clock cycles (slowest of ALTCORE or SYSCLK) to make sure 
		that the PLL controller MUX switches properly to bypass. */
		if(debug_info_on){	
			GEL_TextOut("(3c) Delay...\n",,,,,);
		}		
		for(i = 0; i < delay; i++); // this delay is much more than required 
	}
	
	/*
		Step 4: Programming PLLM[5:0] in the PLLM register of the PLL controller and
		programming PLLM[12:6] in the MAINPLLCTL0 register
	*/		
	PLL1_PLLM &= PLLM_MASK; 							// clear the PLLM[5:0] bit field
	PLL1_PLLM |= ~PLLM_MASK & (PLLM_val - 1); 	// set the PLLM[5:0] bit field to the 6 LSB of PLLM_val

	if(debug_info_on){
		GEL_TextOut("(4)PLLM[PLLM] = %x\n",,,,, PLL1_PLLM);
	}	
	
	MAINPLLCTL0 &= MAIN_PLLM_MASK;																	// clear the PLLM[12:6] bit field
	MAINPLLCTL0 |= ~MAIN_PLLM_MASK & (( (PLLM_val - 1) >> 6) << MAIN_PLLM_OFFSET); 	// set the PLLM[12:6] bit field to the 7 MSB of PLL_val
 
	if(debug_info_on){
		GEL_TextOut("MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}
 
	/*
		Step 5: Programming BWADJ[7:0] in the MAINPLLCTL0 register and BWADJ[11:8] in MAINPLLCTL1 register
	*/			
	MAINPLLCTL0 &= MAIN_BWADJ0_MASK; 															// clear the MAIN_BWADJ0 bit field
	MAINPLLCTL0 |= ~MAIN_BWADJ0_MASK & ((BWADJ_val - 1) << MAIN_BWADJ0_OFFSET);	// set the MAIN_BWADJ[7:0] bit field to the 8 LSB of BWADJ_val

	if(debug_info_on){
		GEL_TextOut("(5) MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}
	
	MAINPLLCTL1 &= MAIN_BWADJ1_MASK; 																	// clear the MAIN_BWADJ1 bit field
	MAINPLLCTL1 |= ~MAIN_BWADJ1_MASK & (( (BWADJ_val - 1) >> 8) << MAIN_BWADJ1_OFFSET);	// set the MAIN_BWADJ[11:8] bit field to the 4 MSB of BWADJ_val

	if(debug_info_on){
		GEL_TextOut("(5) MAINPLLCTL1 = %x\n",,,,, MAINPLLCTL1);
	}
	
	/*
		Step 6: Programming PLLD[5:0] in the MAINPLLCTL0 register
	*/			
	MAINPLLCTL0 &= MAIN_PLLD_MASK; 							// clear the PLLD bit field
	MAINPLLCTL0 |= ~MAIN_PLLD_MASK & (PLLD_val - 1);	// set the PLLD[5:0] bit field of PLLD to PLLD_val

	if(debug_info_on){
		GEL_TextOut("(6) MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}
	
	/*
		Step 7: Programming OD[3:0] in the SECCTL register
	*/			
	PLL1_SECCTL &= OUTPUT_DIVIDE_MASK; 														// clear the OD bit field
	PLL1_SECCTL |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;	// set the OD[3:0] bit field of PLLD to OD_val	

	if(debug_info_on){
		GEL_TextOut("(7) SECCTL = %x\n",,,,, PLL1_SECCTL);
	}
	
	/*
		Step 8: Following steps are needed to change the default output dividers
	*/			
	
	/*Step 8a: Check that the GOSTAT bit in PLLSTAT is cleared to show that no GO
	operation is currently in progress*/
	if(debug_info_on){	
		GEL_TextOut("(8a) Delay...\n",,,,,);
	}	
	while((PLL1_STAT) & 0x00000001);
   
	/*Step 8b: Program the RATIO field in PLLDIVn to the desired new divide-down rate.
	If RATIO field is changed, the PLL controller will flag the change in the
	corresponding bit of DCHANGE*/
	PLL1_DIV2 = (PLLDIV2_val-1) | 0x8000;  //Set PLLDIV2
	PLL1_DIV5 = (PLLDIV5_val-1) | 0x8000;  //Set PLLDIV5
	PLL1_DIV8 = (PLLDIV8_val-1) | 0x8000;  //Set PLLDIV8
	
	if(debug_info_on){
		GEL_TextOut("PLL1_DIV2 = %x\n",,,,, PLL1_DIV2);
		GEL_TextOut("PLL1_DIV5 = %x\n",,,,, PLL1_DIV5);
		GEL_TextOut("PLL1_DIV8 = %x\n",,,,, PLL1_DIV8);
	}
   
    /*Step 8c: Set the respective ALNn bits in ALNCTL to align any SYSCLKs after the GO operation */
    PLL1_ALNCTL |= ((1 << 1) | (1 << 4) | (1 << 7));
   
	/*Step 8d: Set GOSET bit in PLLCMD to initiate the GO operation to change the divide
	values and align the SYSCLKs as programmed */
	PLL1_CMD |= 0x00000001;
   
	/*Step 8e: Read the GOSTAT bit in PLLSTAT to make sure the bit returns to 0 to
	indicate that the GO operation has completed */
	if(debug_info_on){	
		GEL_TextOut("(8d/e) Delay...\n",,,,,);
	}	
	while((PLL1_STAT) & 0x00000001);
    
    /*
		Step 9: Set PLLCTL[PLLRST] = 1 - Assert PLL reset
	*/		
	PLL1_PLLCTL |= (1 << PLLRST_OFFSET);
   
	/*	Step 10: Wait for the at least 7us for the PLL reset properly (128 CLKIN1 cycles)	*/		
	if(debug_info_on){	
		GEL_TextOut("(9) Delay...\n",,,,,);
	}	
	for(i=0;i<delay;i++);
  
	/*
		Step 11: Set PLLCTL[PLLRST] = 0 - De-Assert PLL reset
	*/		
	PLL1_PLLCTL &= ~(1 << PLLRST_OFFSET);
	
	/* Step 12: Wait for PLL to lock (2000 CLKIN1 cycles) */
	if(debug_info_on){	
		GEL_TextOut("(11) Delay...\n",,,,,);
	}	
	for(i=0;i<delay;i++);
  
	/* Step 13: In SECCTL, write BYPASS = 0 (enable PLL mux to switch to PLL mode) */
	PLL1_SECCTL &= ~(1 << BYPASS_OFFSET);		
	if(debug_info_on){	
		GEL_TextOut("(12) SECCTL = %x\n",,,,, PLL1_SECCTL);
	}	
	
	/*Step 14: In PLLCTL, write PLLEN = 1 to enable PLL mode */
	PLL1_PLLCTL |= (1 << PLLEN_OFFSET);		
	if(debug_info_on){	
		GEL_TextOut("(13) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
	}

    /* Step 15: The PLL and PLL Controller are now initialized in PLL mode */
		
	/*	Lock Boot Config Registers	*/
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("PLL has been configured (CLKIN * PLLM / PLLD / PLLOD = PLLOUT):\n",,,,,);
	GEL_TextOut("PLL has been configured (%f MHz * %d / %d / 2 = %f MHz\n",,,,, CLKIN_val, PLLM_val, PLLD_val, (CLKIN_val * PLLM_val / PLLD_val / 2) );
	
}


/****************************************************************************
 *
 * NAME
 *      Set_Pll3
 *
 * PURPOSE:
 *      Setup PLL 3 frequency for DSP PASS clock.
 *      The Frequency is based on an external pass clk input ref of 122.88 MHz clock.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Pll3( int freqindx)
 *
 *      freqindx - (i) index of desired output frequency (1 = 1044 MHz)
 *
 * RETURN VALUE
 *      =0 Ok, >0 problem
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_Pll3(int freqindx)
{
    unsigned int papllclkd; 
    unsigned int papllclkf;
    unsigned int temp;
    int i, iResult = 0;

    // Define other values if needed
    if (freqindx==1)
    {
        papllclkf = 16;	// 122.8 * (16+1) / (0+1)*2 = 1044 MHz
        papllclkd = 0;
    }
    
    // !!! M.T. all delays and multipliers to be reviewed
    
    // Unlock Config
    	KICK0 = 0x83E70B13;
    	KICK1 = 0x95A4F1E0;
    
    // Only core0 can set PLL
    if (DNUM == 0)
    {
        // Print message info...
        GEL_TextOut( "PLL3 Setup... \n" );
        
        /* Usage Note 9: For optimal PLL operation, the ENSAT bit in the PLL control *
         * registers for the Main PLL, PA PLL, and PA PLL should be set to 1.      *
         * The PLL initialization sequence in the boot ROM sets this bit to 0 and    *
         * could lead to non-optimal PLL operation. Software can set the bit to the  *
         * optimal value of 1 after boot                                             *
         * PAPLLCTL1 Bit map                                                         *
         * |31...7   |6     |5 4       |3...0      |                                 *
         * |Reserved |ENSAT |Reserved  |BWADJ[11:8]|                                 */
        PAPLLCTL1 |= 0x00000040;

        /* Put the PLL in PLL Mode                                                   *
         * PAPLLCTL0 Bit map                                                         *
         * |31...24    |23     |22...19       |18...6   |5...0 |                     *
         * |BWADJ[7:0] |BYPASS |Reserved      |PLLM     |PLLD  |                     */
        PAPLLCTL0 |= 0x00800000; /* Set the Bit 23 */

        /* Wait for the PLL Reset time (min: 5 us)                                */
        //Delay_milli_seconds(1);

        /* Program the necessary multipliers/dividers and BW adjustments             */
        /* Set the divider values */
        PAPLLCTL0 &= ~(0x0000003F);
        PAPLLCTL0 |= (papllclkd & 0x0000003F);

        /* Set the Multipler values */
        PAPLLCTL0 &= ~(0x0007FFC0);
        PAPLLCTL0 |= ((papllclkf << 6) & 0x0007FFC0 );

        /* Set the BWADJ */
        temp = ((papllclkf + 1) >> 1) - 1;
        PAPLLCTL0 &= ~(0xFF000000); 
        PAPLLCTL0 |= ((temp << 24) & 0xFF000000);
        PAPLLCTL1 &= ~(0x0000000F);
        PAPLLCTL1 |= ((temp >> 8) & 0x0000000F);
        
        /* In PLL Controller, reset the PLLRST (bit 14) in PAPLLCTL1 register         */
        PAPLLCTL1 |= 0x00004000;

        /* Wait for the PLL Reset time (min: 5 us)                                */
        for(i = 0; i < 1000; i++);
        
        /* In PLL Controller, set PLLSEL (bit 13) in PAPLLCTL1 register         */
        PAPLLCTL1 |= 0x00002000;

        /*In PAPLLCTL1, write PLLRST = 0 to bring PLL out of reset */
        PAPLLCTL1 &= ~(0x00004000);

        /* Wait at least 500 * REFCLK cycles * PLLD (this is the PLL lock time) */
        for(i = 0; i < 1000; i++);

        /* Put the PLL in PLL Mode                                                   *
         * PAPLLCTL0 Bit map                                                         *
         * |31...24    |23     |22...19       |18...6   |5...0 |                     *
         * |BWADJ[7:0] |BYPASS |Reserved      |PLLM     |PLLD  |                     */
        PAPLLCTL0 &= ~(0x00800000); /* ReSet the Bit 23 */

        GEL_TextOut( "PA PLL Setup... Done.\n" );
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set PLL3.\n",,2,,,DNUM);
    }
    
    return(iResult);
}


/****************************************************************************
 *
 * NAME
 *      Set_Pll1_983_MHz
 *
 * PURPOSE:
 *      Setup PLL 1 DSP @ 983 MHz with External clock
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Pll1_983_MHz()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Pll1_983_MHz()
{
    Set_Pll1(1); //122.88 MHz -> 983.4 MHz
}


/****************************************************************************
 *
 * NAME
 *      Set_Pll3_1044_MHz
 *
 * PURPOSE:
 *      Setup PLL 3 pass clk @ 1044 MHz from External input ref clock
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Pll3_1044_MHz()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Pll3_1044_MHz( )
{
    Set_Pll3(1);
}

/****************************************************************************
 *
 * NAME
 *      Set_Pin_Board
 *
 * PURPOSE:
 *      Configure DSP IO pin (and timers pins) and board for normal operation
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Pin_Board()
 *
 * RETURN VALUE
 *      =1 SUCCESS, =0 FAIL
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Pin_Board( )
{
    int iResult=1,iData;

    // Only core0 can set GPIO
    if (DNUM == 0)
    {
        GEL_TextOut( "Set Board and DSP IO/Timers Pins... \n" );
    
    	// Unlock Boot Config
    	KICK0 = 0x83E70B13;
    	KICK1 = 0x95A4F1E0;
        	
        // Configure DSP GP IO related to board functions
        GPIO_BITEN=0;                           // Disable GPIO irq
        GPIO_OUT_DATA=GPIO_DEFAULT_OUT;         // Set pins correct out values
        GPIO_DIR=GPIO_DEFAULT_DIR;              // Configure io directions for EVM
        
        //Setup timer manager for external pin routing
        // Timer1 lo from external TIMI1, others from TIMI0 (Timer inputs))
        TINPSEL = 0x0000000C;
    
        // Timer1 lo to external TIMO1, Timer0 lo to external TIMO0 (Timer Outputs)
        TOUTPSEL = 0x00000040;
        
    	// Lock Boot Config
    	KICK0 = 0;
    	KICK1 = 0;

        // Checks if we got an error
        if (iResult)
            GEL_TextOut( "Set Board and DSP IO/Timers Pins... Done.\n" );
        else
            GEL_TextOut( "Set Board and DSP IO/Timers Pins... ERROR!\n",,2,, );
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set IO/Timers.\n",,2,,,DNUM);
    }
    return(iResult);
}

/****************************************************************************
 *
 * NAME
 *      linux_devstat_uart_init
 *
 * PURPOSE:
 *      	Setup the DEVSTAT register and UARTA power management register for the 
 *			Linux Kernal to use them when	it starts execution.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      linux_devstat_uart_init()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
linux_devstat_uart_init()
{

	unsigned int master_boot = (DEVSTAT & (1 << 14)) >> 14;
	unsigned int i = 0;
	
	GEL_TextOut("TCI6614 Master boot = %d\n",,2,,,master_boot);
	
	if(master_boot == 1){ //(BOOTMODE[14] = 1 - ARM master boot selected
		
		GEL_TextOut("ARM master boot selected\n",,2,,,);
		// Unlock Boot Config
		KICK0 = KICK0_UNLOCK;
		KICK1 = KICK1_UNLOCK;

		// Enable TX and RX of UARTA
		UARTA_PWREMU_MGMT = 0;
		for(i=0;i<1000;i++); 
		UARTA_PWREMU_MGMT = 0x6003;

		/* Update DEVSTAT 
			Sets BOOTMODE[13:11] = 0b111 indicating that a 122.88 MHz SYSCLK is present 
			and Main PLL has been programmed to 999.989 MHz operation - used by Linux kernal		
		*/		
		DEVSTAT |= 0x3800; 
		
		// Lock Boot Config
		KICK0 = KICK_LOCK;
		KICK1 = KICK_LOCK;
	}
	else{
		GEL_TextOut("DSP master boot selected\n",,2,,,);
	}
	
}

/****************************************************************************
 *
 * NAME
 *      Global_Default_Setup_Silent
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Global_Default_Setup_Silent()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Global_Default_Setup_Silent()
{
    float gel_ver = GEL_VERSION;
    // Set DSP cache to pre defined values...
    GEL_TextOut( "TCI6614LXE GEL file Ver is %f \n",,,,, (float) (gel_ver/1.0));

    Set_DSP_Cache();

    // Only core 0 can set these
    if (DNUM == 0)
    {
		// Setup main Pll DSP @ 983 MHz
		Set_Pll1_983_MHz();

		// Setup all Power Domains on
		Set_Psc_All_On( );

		// Setup Pll3 pass clk @ 1044 MHz
		Set_Pll3_1044_MHz();

		// Configure SGMII SERDES
		configSGMIISerdes();

		// Setup DSP IO Pins (and timers pins) and EVM board settings
		Set_Pin_Board( );

		GEL_TextOut( "Configuring CPSW ...\n");
		setCpSwConfig();   
		GEL_TextOut( "Configuring CPSW ...Done \n");    

		GEL_TextOut( "DDR begin\n");
		xmc_setup();
		ddr3_setup(0);
		GEL_TextOut( "DDR done\n");

		GEL_TextOut( "Initializing DEVSTAT and UART_A for Linux if required\n");
		linux_devstat_uart_init();

    }
}



///*********************************************************************
///
///	TCI6614 CPSW Setup Functions
///
///*********************************************************************

menuitem "TCI6614 CPSW Functions";


hotmenu configSGMIISerdes()
{

   GEL_TextOut( "configSGMIISerdes Setup... Begin\n" );


  /* Unlock Chip Level Registers */
  KICK0 = KICK0_UNLOCK;
  KICK1 = KICK1_UNLOCK;
   
  SGMII_SERDES_CONTROL_PORT1 = 0x0;
  SGMII_SERDES_CONTROL_PORT0 = 0x0;
  /* Multiply to be 8 with Quarter Rate in the Rx registers */
  SGMII_SERDES_CFGPLL = 0x00000041;
  
  
  /* Wait */
  Wait_Soft(100);
  

  //31:25    Reserved    0000000
  //23:24    LOOPBACK    00
  //   22    ENOC        1
  //21:18    EQ          0001
  //17:15    CDR         001 -- first order threshold of 17
  //14:12    LOS         000 -- tie off
  //11:10    ALIGN       01  -- Comma Aligned
  //09:07    TERM        100 -- tie off (100)
  //   06    INVPAIR     0
  //05:04    RATE        01  -- tie off (10)  //00 = Full Rate, 01 = Half Rate (*0.5), 10 = Quarter Rate (*0.25)
  //03:01    BUSWIDTH    000 -- tie off
  //   00    ENRX        1
  // 0000 0000 0100 0100 0000 0010 0001 0001 = 0x0044_0211 -- My estimated value
  // 0000 0000 0100 0100 0000 0100 0001 0001 = 0x0044_0411 -- New DV value
  // 0000 0000 0000 1000 0000 1000 0100 0001 = 0x0008_0841 -- Original DV value
  SGMII_SERDES_CFGRX0 = 0x00700621;
  SGMII_SERDES_CFGRX1 = 0x00700621;
  
  
  //31:22    Reserved    0
  //21:20    LOOPBACK    00
  //19:18    RDTCT       00  -- tie off
  //   17    ENIDL       0   -- tie off
  //   16    MYSNC       1   -- tie off
  //15:12    DEMPHASIS   ???? - 0001 Lets give some de-emphasis
  //11:08    SWING       ????
  //   07    CM          1   -- tie off
  //   06    INVPAIR     0
  //05:04    RATE        01  -- tie off
  //03:01    BUSWIDTH    000 -- tie off
  //   00    ENTX        1
  // 0000 0000 0011 0001 ???? ???? 1001 0001 = 0x0031_1E91 -- My estimated value
  // 0000 0000 0000 0001 0000 1111 0001 0001 = 0x0001_0F11 -- New DV value
  // 0000 0000 0100 0000 0001 1110 0100 0001 = 0x0040_1e41 -- Original DV value
  
  SGMII_SERDES_CFGTX0 = 0x000108A1;
  SGMII_SERDES_CFGTX1 = 0x000108A1;
  
  SGMII_SERDES_AUX_CFG_PORT0 = 0x00000041;
  SGMII_SERDES_AUX_CFG_PORT1 = 0x00000041;
  
  /* waitforclock() */
  Wait_Soft(1000);

  SGMII_SERDES_MR_ADV_PORT0 = 0x1;
  SGMII_SERDES_MR_ADV_PORT1 = 0x1;
  Wait_Soft(100);
  SGMII_SERDES_CONTROL_PORT1 = 0x1;
  SGMII_SERDES_CONTROL_PORT0 = 0x1;
  
  /*Configuring Sliver */
  SGMII_SLIVER_MAXLEN2 = 0x2520;
  SGMII_SLIVER_MAXLEN1 = 0x2520;
  
  SGMII_SLIVER_MACCONTROL2 = 0xA1;
  SGMII_SLIVER_MACCONTROL1 = 0xA1;
  
	
  /* Lock Chip Level Registers */
  KICK0 = KICK_LOCK;
  KICK1 = KICK_LOCK;
  
  GEL_TextOut("SGMII SERDES has been configured.\n");

}


/* Initialize switch configuration */
hotmenu setCpSwConfig()
{
  /* Enable Port 0 */
  CPSW3G_CONTROL_REG = 0x4;
  CPSW3G_STAT_PORT_REG = 0xF;

   /* Enable ALE. */
   CPSW3G_ALE_CONTROL_REG = 0x80000000;
  /* Enable ALE port state to Forward */
  CPSW3G_ALE_PORT_0_CTL_REG = 0x3;
  CPSW3G_ALE_PORT_1_CTL_REG = 0x3;
  CPSW3G_ALE_PORT_2_CTL_REG = 0x3;

}




///*********************************************************************
///
///	TCI6614 Debug Functions
///
///*********************************************************************

/* BB register field read macro */
#define BB_REG_FIELD_READ(reg_value, reg_high, reg_low) (unsigned int)(((*(unsigned int*)reg_value)&((0xFFFFFFFF>>((31-reg_high)+reg_low))<<reg_low))>>reg_low)

/* BB register field write macro */
#define BB_REG_FIELD_WRITE(reg_addr, reg_high, reg_low, reg_value) (*(unsigned int *)reg_addr) = ((*(unsigned int *)reg_addr)&(~((0xFFFFFFFF>>(31-reg_high))&(0xFFFFFFFF<<reg_low))))|((reg_value<<reg_low)&((0xFFFFFFFF>>(31-reg_high))&(0xFFFFFFFF<<reg_low))) 


/* Test inputs */

//L2 and MSMC test memory is not used by Application SW (look up the linker cmd file or MAP file)
#define MSMC_SRC_TEST_MEMADDR       (0x0C1FFFF0u)   //need 8 bytes for testing purposes
#define MSMC_DST_TEST_MEMADDR       (0x0C1FFFF8u)   //need 8 bytes for testing purposes
#define L2_SRC_TEST_MEMADDR         (0x108FFFF0u)   //need 8 bytes for testing purposes and need to be a global address
#define L2_DST_TEST_MEMADDR         (0x108FFFF8u)   //need 8 bytes for testing purposes and need to be a global address
#define DDR_SRC_TEST_MEMADDR        (0x800FFFF0u)   //need 8 bytes for testing purposes
#define DDR_DST_TEST_MEMADDR        (0x800FFFF8u)   //need 8 bytes for testing purposes


#define EDMA_TPCC0_CHAN_NUM      (15)   //INTC2_OUT7(DMA channel which can be used for testing)
#define EDMA_TPCC1_CHAN_NUM      (9)   //GPINT3(DMA channel which can be used for testing)
#define EDMA_TPCC2_CHAN_NUM      (9)   //GPINT3(DMA channel which can be used for testing)

//Use the last Param in the Param set
#define EDMA_TPCC0_PARAM_NUM      (127)   //Param set which can be used for testing
#define EDMA_TPCC1_PARAM_NUM      (511)   //Param set which can be used for testing
#define EDMA_TPCC2_PARAM_NUM      (511)   //Param set which can be used for testing

#define BB_TEST_WORD1             (0xABCDABCD)
#define BB_TEST_WORD2             (0xDEADDEAD)

/* EDMA3 TC Base Memory address */
#define EDMA0_TPTC0_BASE       (0x02760000u)
#define EDMA0_TPTC1_BASE       (0x02768000u)
#define EDMA1_TPTC0_BASE       (0x02770000u)
#define EDMA1_TPTC1_BASE       (0x02778000u)
#define EDMA1_TPTC2_BASE       (0x02780000u)
#define EDMA1_TPTC3_BASE       (0x02788000u)
#define EDMA2_TPTC0_BASE       (0x02790000u)
#define EDMA2_TPTC1_BASE       (0x02798000u)
#define EDMA2_TPTC2_BASE       (0x027A0000u)
#define EDMA2_TPTC3_BASE       (0x027A8000u)

/* EDMA TC register offsets */

#define EDMA_TPTC_TCSTAT       (0x00000100u)
#define EDMA_TPTC_INTSTAT      (0x00000104u)
#define EDMA_TPTC_INTEN        (0x00000108u)
#define EDMA_TPTC_INTCLR       (0x0000010Cu)

#define EDMA_TPTC_ERRSTAT      (0x00000120u)
#define EDMA_TPTC_ERREN        (0x00000124u)
#define EDMA_TPTC_ERRCLR       (0x00000128u)
#define EDMA_TPTC_ERRDET       (0x0000012Cu)

#define EDMA_TPTC_POPT         (0x00000200u)
#define EDMA_TPTC_PSRC         (0x00000204u)
#define EDMA_TPTC_PCNT         (0x00000208u)
#define EDMA_TPTC_PDST         (0x0000020Cu)
#define EDMA_TPTC_PBIDX        (0x00000210u)
#define EDMA_TPTC_PMPPRXY      (0x00000214u)

#define EDMA_TPTC_SAOPT        (0x00000240u)
#define EDMA_TPTC_SASRC        (0x00000244u)
#define EDMA_TPTC_SACNT        (0x00000248u)
#define EDMA_TPTC_SADST        (0x0000024Cu)
#define EDMA_TPTC_SABIDX       (0x00000250u)
#define EDMA_TPTC_SAMPPRXY     (0x00000254u)
#define EDMA_TPTC_SACNTRLD     (0x00000258u)
#define EDMA_TPTC_SASRCBREF    (0x0000025Cu)
#define EDMA_TPTC_SADSTBREF    (0x00000260u)

#define EDMA_TPTC_DFCNTRLD     (0x00000280u)
#define EDMA_TPTC_DFSRCBREF    (0x00000284u)
#define EDMA_TPTC_DFDSTBREF    (0x00000288u)

#define EDMA_TPTC_DFOPT0       (0x00000300u)
#define EDMA_TPTC_DFSRC0       (0x00000304u)
#define EDMA_TPTC_DFCNT0       (0x00000308u)
#define EDMA_TPTC_DFDST0       (0x0000030Cu)
#define EDMA_TPTC_DFBIDX0      (0x00000310u)
#define EDMA_TPTC_DFMPPRXY0    (0x00000314u)

#define EDMA_TPTC_DFOPT1       (0x00000340u)
#define EDMA_TPTC_DFSRC1       (0x00000344u)
#define EDMA_TPTC_DFCNT1       (0x00000348u)
#define EDMA_TPTC_DFDST1       (0x0000034Cu)
#define EDMA_TPTC_DFBIDX1      (0x00000350u)
#define EDMA_TPTC_DFMPPRXY1    (0x00000354u)

#define EDMA_TPTC_DFOPT2       (0x00000380u)
#define EDMA_TPTC_DFSRC2       (0x00000384u)
#define EDMA_TPTC_DFCNT2       (0x00000388u)
#define EDMA_TPTC_DFDST2       (0x0000038Cu)
#define EDMA_TPTC_DFBIDX2      (0x00000390u)
#define EDMA_TPTC_DFMPPRXY2    (0x00000394u)

#define EDMA_TPTC_DFOPT3       (0x000003C0u)
#define EDMA_TPTC_DFSRC3       (0x000003C4u)
#define EDMA_TPTC_DFCNT3       (0x000003C8u)
#define EDMA_TPTC_DFDST3       (0x000003CCu)
#define EDMA_TPTC_DFBIDX3      (0x000003D0u)
#define EDMA_TPTC_DFMPPRXY3    (0x000003D4u)


/* EDMA3 CC Base Memory address */
#define EDMA_TPCC0_BASE        (0x02700000u)
#define EDMA_TPCC1_BASE        (0x02720000u)
#define EDMA_TPCC2_BASE        (0x02740000u)

/* EDMA3 CC Registers offset */

#define EDMA_TPCC_DCHMAP0      (0x00000100u)
#define EDMA_TPCC_QCHMAP0      (0x00000200u)
#define EDMA_TPCC_DMAQNUM0     (0x00000240u)
#define EDMA_TPCC_QDMAQNUM     (0x00000260u)
#define EDMA_TPCC_QUETCMAP     (0x00000280u)
#define EDMA_TPCC_QUEPRI       (0x00000284u)
#define EDMA_TPCC_QSTAT0       (0x00000600u)
#define EDMA_TPCC_CCSTAT       (0x00000640u)


#define EDMA_TPCC_ECR          (0x00001008u)
#define EDMA_TPCC_ECRH         (0x0000100Cu)
#define EDMA_TPCC_ESR          (0x00001010u)
#define EDMA_TPCC_ESRH         (0x00001014u)

#define EDMA_TPCC_IER          (0x00001050u)
#define EDMA_TPCC_IERH         (0x00001054u)

#define EDMA_TPCC_IECR         (0x00001058u)
#define EDMA_TPCC_IECRH        (0x0000105Cu)
#define EDMA_TPCC_IESR         (0x00001060u)
#define EDMA_TPCC_IESRH        (0x00001064u)

#define EDMA_TPCC_IPR          (0x00001068u)
#define EDMA_TPCC_IPRH         (0x0000106Cu)
#define EDMA_TPCC_ICR          (0x00001070u)
#define EDMA_TPCC_ICRH         (0x00001074u)

#define EDMA_TPCC_PARAM_BASE   (0x00004000u)


//Macros used for checking the status of the slaves on the Main SCR

#define VCP2A_MEMREAD_ADDR     (0x22A00048u)
#define VCP2B_MEMREAD_ADDR     (0x22B00048u)
#define VCP2C_MEMREAD_ADDR     (0x22C00048u)
#define VCP2D_MEMREAD_ADDR     (0x22D00048u)

#define TCP3D_B_MEMREAD_ADDR   (0x20600000u)
#define TCP3D_A_MEMREAD_ADDR   (0x20800000u)

//#define TCP3E_MEMREAD_ADDR     (0x20902000u)

#define RAC_B_MEMREAD_ADDR     (0x20200000u)
#define RAC_A_MEMREAD_ADDR     (0x33200000u)

#define TAC_MEMREAD_ADDR       (0x34C00000u)

#define HYPERBRIDGE_MEMREAD_ADDR (0x40000000u)

#define QMSS_MEMREAD_ADDR      (0x34000000u)

#define SPI_MEMREAD_ADDR       (0x20BF0030u)

#define EMIF16_MEMREAD_ADDR    (0x70000000) //Todo: Need to check if it is possible to read this location

#define BOOTROM_MEMREAD_ADDR   (0x20B00000u)

#define COREPAC0_SRC_TEST_MEMADDR (0x108FFFF0u)
#define COREPAC0_DST_TEST_MEMADDR (0x108FFFF8u)

#define COREPAC1_SRC_TEST_MEMADDR (0x118FFFF0u)	
#define COREPAC1_DST_TEST_MEMADDR (0x118FFFF8u)

#define COREPAC2_SRC_TEST_MEMADDR (0x128FFFF0u)
#define COREPAC2_DST_TEST_MEMADDR (0x128FFFF8u)

#define COREPAC3_SRC_TEST_MEMADDR (0x138FFFF0u)
#define COREPAC3_DST_TEST_MEMADDR (0x138FFFF8u)


/* Genric Delay function */

BB_Delay(unsigned int delay_count)
{
	unsigned int i;
	
	for(i=0;i<delay_count;i++);
	
}



/* EDMA transfer generic function */

EDMA_generic_transfer_req (unsigned int cc_num, 
						   unsigned int tc_num, 
						   unsigned int param_num,
						   unsigned int chan_num,
						   unsigned int src_addr,
						   unsigned int dst_addr)
{
	unsigned int tpcc_base_addr;
	unsigned int result;
	
	unsigned int param_save0;
    unsigned int param_save1;
    unsigned int param_save2;
    unsigned int param_save3;
    unsigned int param_save4;
    unsigned int param_save5;
    unsigned int param_save6;
    unsigned int param_save7;

    unsigned int dchmap_save;
    unsigned int dchmap_addr;
    unsigned int esr_addr;
    unsigned int esr_mask;
    unsigned int dmaqnum_save;
    unsigned int dmaqnum_addr;
    unsigned int dmaqnum_mask;
    unsigned int dmaqnum_val;
    int errCnt;
	
	// Identify the TPCC base address
	if(cc_num == 0)
	{
		tpcc_base_addr = EDMA_TPCC0_BASE;
	}
	else if(cc_num == 1)
	{
		tpcc_base_addr = EDMA_TPCC1_BASE;
	}
	else if(cc_num == 2)
	{
		tpcc_base_addr = EDMA_TPCC2_BASE;
	}
	
	
	dchmap_addr = (tpcc_base_addr + EDMA_TPCC_DCHMAP0) + (4 * chan_num);
	
	dmaqnum_addr = (tpcc_base_addr + EDMA_TPCC_DMAQNUM0) + 4 * (chan_num >> 3);
    dmaqnum_mask = 15 << (4*(chan_num % 8));
    dmaqnum_val  = (tc_num) << (4*(chan_num % 8));
	
	// Save info which needs to be re-instated
	
    param_save0  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0),31,0);
	param_save1  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4),31,0);
	param_save2  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8),31,0);
	param_save3  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12),31,0);
	param_save4  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16),31,0);
	param_save5  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20),31,0);
	param_save6  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24),31,0);
	param_save7  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28),31,0);
	dchmap_save  = BB_REG_FIELD_READ(dchmap_addr,31,0); /* DCHMAPx */
	dmaqnum_save = BB_REG_FIELD_READ(dmaqnum_addr,31,0); /* DMAQNUMx */
	
	// Setup EDMA Param entry
	
	// OPT: STATIC, A-Sync
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0), 31, 0, 0x00000008);
	
	//SRC
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4), 31, 0, src_addr);
	
	//ACNT = 8 and BCNT = 1
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8), 31, 0, 0x00010008);
	
	//DST
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12), 31, 0, dst_addr);
	
	//BIDX
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16), 31, 0, 0x00000000);
	
	//LINK
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20), 31, 0, 0x00000000);
	
	//CIDX
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24), 31, 0, 0x00000000);

    //CCNT = 1
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28), 31, 0, 0x00000001);
	
	
	//Setup param to channel mapping
	BB_REG_FIELD_WRITE(dchmap_addr, 31, 0, (tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20)));
	
	BB_REG_FIELD_WRITE(dmaqnum_addr, 31, 0, ((dmaqnum_save & (~dmaqnum_mask)) | dmaqnum_val));
	
	
	//Trigger EDMA transfer
	
	if (chan_num < 32) 
	{
		esr_addr = (tpcc_base_addr + EDMA_TPCC_ESR);
		
		BB_REG_FIELD_WRITE(esr_addr, chan_num, chan_num, 0x1);
	} 
	else 
	{
		esr_addr = (tpcc_base_addr + EDMA_TPCC_ESRH);
		
		BB_REG_FIELD_WRITE(esr_addr, (chan_num-32), (chan_num-32), 0x1);
	}
	
	//Give some delay for transfer to complete
	BB_Delay(10000);
	
	//Re-instate the saved info
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0), 31, 0, param_save0);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4), 31, 0, param_save1);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8), 31, 0, param_save2);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12), 31, 0, param_save3);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16), 31, 0, param_save4);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20), 31, 0, param_save5);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24), 31, 0, param_save6);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28), 31, 0, param_save7);
	BB_REG_FIELD_WRITE(dchmap_addr, 31, 0, dchmap_save);
	BB_REG_FIELD_WRITE(dmaqnum_addr, 31, 0, dmaqnum_save);
	
}


bb_scr_bridges_scan()
{
	unsigned int bridge_err_flag = 0;
	unsigned int result1,result2;

	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 BRIDGE SCAN RESULTS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");
	
	//Write the test word at the source address
	BB_REG_FIELD_WRITE(MSMC_SRC_TEST_MEMADDR, 31, 0, BB_TEST_WORD1);
	BB_REG_FIELD_WRITE((MSMC_SRC_TEST_MEMADDR+4), 31, 0, BB_TEST_WORD2);
	
	//scanning bridges connecting SCR_3A to SCR_2A
	
	//Scan bridge_5 (use EDMA1 and TC0)
	
	EDMA_generic_transfer_req (1, 0, EDMA_TPCC1_PARAM_NUM, EDMA_TPCC1_CHAN_NUM, MSMC_SRC_TEST_MEMADDR, MSMC_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(MSMC_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((MSMC_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(BRIDGE5 STALLED): The bridge5 connecting SCR_3A with SCR_2A is stalled\n");
		GEL_TextOut(" Reason & Solution: 1) In Application SW, check the traffic scenario being used by the masters which inject\n");  
		GEL_TextOut("                       traffic through bridge5 from SCR_3A to SCR_2A\n");
		GEL_TextOut("                    2) The masters using bridge5 are: EDMA1_TC0_RD, EDMA1_TC0_WR, EDMA2_TC2_RD, EDMA2_TC2_WR and SRIO_CPPI\n");
		GEL_TextOut("                       The slaves using bridge5 are : HYPERBRIDGE_Slave, MSMC_SMS and MSMC_SES\n\n");
		
		bridge_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" Bridge5 scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(MSMC_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((MSMC_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan bridge_6 (use EDMA1 and TC1)
	
	EDMA_generic_transfer_req (1, 1, EDMA_TPCC1_PARAM_NUM, EDMA_TPCC1_CHAN_NUM, MSMC_SRC_TEST_MEMADDR, MSMC_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(MSMC_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((MSMC_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(BRIDGE6 STALLED): The bridge6 connecting SCR_3A with SCR_2A is stalled\n");
		GEL_TextOut(" Reason & Solution: 1) In Application SW, check the traffic scenario being used by the masters which inject\n");  
		GEL_TextOut("                       traffic through bridge6 from SCR_3A to SCR_2A\n");
		GEL_TextOut("                    2) The masters using bridge6 are: EDMA1_TC1_RD, EDMA1_TC1_WR, EDMA2_TC3_RD, EDMA2_TC3_WR and FFTC_A\n");
		GEL_TextOut("                       The slaves using bridge6 are : HYPERBRIDGE_Slave, MSMC_SMS and MSMC_SES\n\n");
		
		bridge_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" Bridge6 scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(MSMC_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((MSMC_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan bridge_7 (use EDMA1 and TC2)
	
	EDMA_generic_transfer_req (1, 2, EDMA_TPCC1_PARAM_NUM, EDMA_TPCC1_CHAN_NUM, MSMC_SRC_TEST_MEMADDR, MSMC_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(MSMC_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((MSMC_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(BRIDGE7 STALLED): The bridge7 connecting SCR_3A with SCR_2A is stalled\n");
		GEL_TextOut(" Reason & Solution: 1) In Application SW, check the traffic scenario being used by the masters which inject\n");  
		GEL_TextOut("                       traffic through bridge7 from SCR_3A to SCR_2A\n");
		GEL_TextOut("                    2) The masters using bridge7 are: EDMA1_TC2_RD, EDMA1_TC2_WR, BCP CDMA/DIO0 (SCR_3_I), AIF2 and RAC_B_BE0 (Br_67)\n");
		GEL_TextOut("                       The slaves using bridge7 are : HYPERBRIDGE_Slave, MSMC_SMS and MSMC_SES\n\n");
		
		bridge_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" Bridge7 scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(MSMC_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((MSMC_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan bridge_8 (use EDMA1 and TC3)
	
	EDMA_generic_transfer_req (1, 3, EDMA_TPCC1_PARAM_NUM, EDMA_TPCC1_CHAN_NUM, MSMC_SRC_TEST_MEMADDR, MSMC_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(MSMC_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((MSMC_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(BRIDGE8 STALLED): The bridge8 connecting SCR_3A with SCR_2A is stalled\n");
		GEL_TextOut(" Reason & Solution: 1) In Application SW, check the traffic scenario being used by the masters which inject\n");  
		GEL_TextOut("                       traffic through bridge8 from SCR_3A to SCR_2A\n");
		GEL_TextOut("                    2) The masters using bridge8 are: EDMA1_TC3_RD, EDMA1_TC3_WR, QM_CDMA, RAC_A_BE0(BR_50) and ARM-64(BR_77)\n");
		GEL_TextOut("                       The slaves using bridge8 are : HYPERBRIDGE_Slave, MSMC_SMS and MSMC_SES\n\n");
		
		bridge_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" Bridge8 scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(MSMC_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((MSMC_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan bridge_9 (use EDMA2 and TC0)
	
	EDMA_generic_transfer_req (2, 0, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, MSMC_SRC_TEST_MEMADDR, MSMC_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(MSMC_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((MSMC_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(BRIDGE9 STALLED): The bridge9 connecting SCR_3A with SCR_2A is stalled\n");
		GEL_TextOut(" Reason & Solution: 1) In Application SW, check the traffic scenario being used by the masters which inject\n");  
		GEL_TextOut("                       traffic through bridge9 from SCR_3A to SCR_2A\n");
		GEL_TextOut("                    2) The masters using bridge9 are: EDMA2_TC0_RD, EDMA2_TC0_WR, FFTC_B and TAC_FE\n");
		GEL_TextOut("                       The slaves using bridge9 are : HYPERBRIDGE_Slave, MSMC_SMS and MSMC_SES\n\n");
		
		bridge_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" Bridge9 scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(MSMC_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((MSMC_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan bridge_10 (use EDMA2 and TC1)
	
	EDMA_generic_transfer_req (2, 1, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, MSMC_SRC_TEST_MEMADDR, MSMC_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(MSMC_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((MSMC_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(BRIDGE10 STALLED): The bridge10 connecting SCR_3A with SCR_2A is stalled\n");
		GEL_TextOut(" Reason & Solution: 1) In Application SW, check the traffic scenario being used by the masters which inject\n");  
		GEL_TextOut("                       traffic through bridge10 from SCR_3A to SCR_2A\n");
		GEL_TextOut("                    2) The masters using bridge10 are: EDMA2_TC1_RD, EDMA2_TC1_WR, PA_Data_Master, SCR_3_F(PCIe_Master and SRIO_M) and SCR_3_D (DAP/QM-second/BCP_DIO1)\n"); 
		GEL_TextOut("                       The slaves using bridge10 are : HYPERBRIDGE_Slave, MSMC_SMS and MSMC_SES\n\n");
		
		bridge_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" Bridge10 scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(MSMC_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((MSMC_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan bridge_3 (use EDMA0 and TC1)
	
	//Write the test word at the source address
	BB_REG_FIELD_WRITE(L2_SRC_TEST_MEMADDR, 31, 0, BB_TEST_WORD1);
	BB_REG_FIELD_WRITE((L2_SRC_TEST_MEMADDR+4), 31, 0, BB_TEST_WORD2);
	
	EDMA_generic_transfer_req (0, 1, EDMA_TPCC0_PARAM_NUM, EDMA_TPCC0_CHAN_NUM, L2_SRC_TEST_MEMADDR, L2_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(L2_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((L2_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(BRIDGE3 STALLED): The bridge3 connecting SCR_2A with SCR_3A is stalled\n");
		GEL_TextOut(" Reason & Solution: 1) In Application SW, check the traffic scenario being used by the masters which inject\n");  
		GEL_TextOut("                       traffic through bridge3 from SCR_2A to SCR_3A\n");
		GEL_TextOut("                    2) The masters using bridge3 are: EDMA0_TC0_RD, EDMA0_TC0_WR, EDMA0_TC1_RD and EDMA0_TC1_WR\n"); 
		GEL_TextOut("                       The slaves using bridge3 are : GEM0_SDMA, GEM1_SDMA, GEM2_SDMA, GEM3_SDMA, SRIO_Data_Slave, PCIe Slave\n");
		GEL_TextOut("                                                      Br_11 (for boot_ROM, SPI and EMIF16), PCIe_Slave and Br_12(to SCR_3P_A)\n\n");
		
		bridge_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" Bridge3 scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(L2_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((L2_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Check for no errors found during the bridge scan
	if(bridge_err_flag == 0)
	{
		GEL_TextOut(" No Errors detected in the bridge scan\n\n");
	}
	else
	{
		bridge_err_flag == 0;
	}
	
	GEL_TextOut(" BRIDGES NOT TESTED: Bridge1 and Bridge4\n\n");
	
}


/* EDMA SCR slave scan function */

EDMA_scr_slave_scan (unsigned int cc_num, 
						   unsigned int tc_num, 
						   unsigned int param_num,
						   unsigned int chan_num,
						   unsigned int src_addr,
						   unsigned int dst_addr)
{
	unsigned int tpcc_base_addr, tptc_base_addr;
	unsigned int result, status;
	
	unsigned int param_save0;
    unsigned int param_save1;
    unsigned int param_save2;
    unsigned int param_save3;
    unsigned int param_save4;
    unsigned int param_save5;
    unsigned int param_save6;
    unsigned int param_save7;

    unsigned int dchmap_save;
    unsigned int dchmap_addr;
    unsigned int esr_addr;
    unsigned int esr_mask;
    unsigned int dmaqnum_save;
    unsigned int dmaqnum_addr;
    unsigned int dmaqnum_mask;
    unsigned int dmaqnum_val;
    
	unsigned int tc_erren_save;
	
	// Identify the TPCC base address
	if(cc_num == 0 && tc_num == 0)
	{
		tpcc_base_addr = EDMA_TPCC0_BASE;
		tptc_base_addr = EDMA0_TPTC0_BASE;
	}
	else if(cc_num == 0 && tc_num == 1)
	{
		tpcc_base_addr = EDMA_TPCC0_BASE;
		tptc_base_addr = EDMA0_TPTC1_BASE;
	}
	else if(cc_num == 1 && tc_num == 0)
	{
		tpcc_base_addr = EDMA_TPCC1_BASE;
		tptc_base_addr = EDMA1_TPTC0_BASE;
	}
	else if(cc_num == 1 && tc_num == 1)
	{
		tpcc_base_addr = EDMA_TPCC1_BASE;
		tptc_base_addr = EDMA1_TPTC1_BASE;
	}
	else if(cc_num == 1 && tc_num == 2)
	{
		tpcc_base_addr = EDMA_TPCC1_BASE;
		tptc_base_addr = EDMA1_TPTC2_BASE;
	}
	else if(cc_num == 1 && tc_num == 3)
	{
		tpcc_base_addr = EDMA_TPCC1_BASE;
		tptc_base_addr = EDMA1_TPTC3_BASE;
	}
	else if(cc_num == 2 && tc_num == 0)
	{
		tpcc_base_addr = EDMA_TPCC2_BASE;
		tptc_base_addr = EDMA2_TPTC0_BASE;
	}
	else if(cc_num == 2 && tc_num == 1)
	{
		tpcc_base_addr = EDMA_TPCC2_BASE;
		tptc_base_addr = EDMA2_TPTC1_BASE;
	}
	else if(cc_num == 2 && tc_num == 2)
	{
		tpcc_base_addr = EDMA_TPCC2_BASE;
		tptc_base_addr = EDMA2_TPTC2_BASE;
	}
	else if(cc_num == 2 && tc_num == 3)
	{
		tpcc_base_addr = EDMA_TPCC2_BASE;
		tptc_base_addr = EDMA2_TPTC3_BASE;
	}
	
	//Enable error capturing in TC
	
	tc_erren_save = BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_ERREN),31,0);
	
	//Enable BUS_ERR in TC
	BB_REG_FIELD_WRITE((tptc_base_addr + EDMA_TPTC_ERREN),0,0,0x1);
	
	
	dchmap_addr = (tpcc_base_addr + EDMA_TPCC_DCHMAP0) + (4 * chan_num);
	
	dmaqnum_addr = (tpcc_base_addr + EDMA_TPCC_DMAQNUM0) + 4 * (chan_num >> 3);
    dmaqnum_mask = 15 << (4*(chan_num % 8));
    dmaqnum_val  = (tc_num) << (4*(chan_num % 8));
	
	// Save info which needs to be re-instated
	
    param_save0  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0),31,0);
	param_save1  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4),31,0);
	param_save2  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8),31,0);
	param_save3  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12),31,0);
	param_save4  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16),31,0);
	param_save5  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20),31,0);
	param_save6  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24),31,0);
	param_save7  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28),31,0);
	dchmap_save  = BB_REG_FIELD_READ(dchmap_addr,31,0); /* DCHMAPx */
	dmaqnum_save = BB_REG_FIELD_READ(dmaqnum_addr,31,0); /* DMAQNUMx */
	
	// Setup EDMA Param entry
	
	// OPT: STATIC, A-Sync
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0), 31, 0, 0x00000008);
	
	//Configure TCC = chan_num
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0), 17, 12, chan_num);
	
	//SRC
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4), 31, 0, src_addr);
	
	//ACNT = 8 and BCNT = 1
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8), 31, 0, 0x00010008);
	
	//DST
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12), 31, 0, dst_addr);
	
	//BIDX
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16), 31, 0, 0x00000000);
	
	//LINK
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20), 31, 0, 0x00000000);
	
	//CIDX
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24), 31, 0, 0x00000000);

    //CCNT = 1
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28), 31, 0, 0x00000001);
	
	
	//Setup param to channel mapping
	BB_REG_FIELD_WRITE(dchmap_addr, 31, 0, (tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20)));
	
	BB_REG_FIELD_WRITE(dmaqnum_addr, 31, 0, ((dmaqnum_save & (~dmaqnum_mask)) | dmaqnum_val));
	
	
	//Trigger EDMA transfer
	
	if (chan_num < 32) 
	{
		esr_addr = (tpcc_base_addr + EDMA_TPCC_ESR);
		
		BB_REG_FIELD_WRITE(esr_addr, chan_num, chan_num, 0x1);
	} 
	else 
	{
		esr_addr = (tpcc_base_addr + EDMA_TPCC_ESRH);
		
		BB_REG_FIELD_WRITE(esr_addr, (chan_num-32), (chan_num-32), 0x1);
	}
	
	//Give delay for EDMA transfer to complete
	
	BB_Delay(10000);
	
	// Clear the slave_failed flag, this flag is stored in MSMC
	BB_REG_FIELD_WRITE(MSMC_SRC_TEST_MEMADDR,31,0,0x0);
	
	status = BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_ERRSTAT),0,0);
	
	if(status == 1)
	{
		//check tcc code from EERDET
		status = BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_ERRDET),13,8);
		
		if(status == chan_num)
		{
			// slave_failed flag is set, this flag is stored in MSMC
			BB_REG_FIELD_WRITE(MSMC_SRC_TEST_MEMADDR,31,0,0x1);
		}
	}
	
	//Re-instate the saved info
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0), 31, 0, param_save0);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4), 31, 0, param_save1);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8), 31, 0, param_save2);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12), 31, 0, param_save3);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16), 31, 0, param_save4);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20), 31, 0, param_save5);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24), 31, 0, param_save6);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28), 31, 0, param_save7);
	BB_REG_FIELD_WRITE(dchmap_addr, 31, 0, dchmap_save);
	BB_REG_FIELD_WRITE(dmaqnum_addr, 31, 0, dmaqnum_save);
	BB_REG_FIELD_WRITE((tptc_base_addr + EDMA_TPTC_ERREN), 31, 0, tc_erren_save);
	
}


bb_scr_slave_scan()
{
	unsigned int slave_fail_flag = 0;
	unsigned int slave_err_flag = 0;
	unsigned int slave_trans_status;
	unsigned int status;
	unsigned int result1, result2;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SLAVE SCAN RESULTS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	//Scan the VCP 2A slave
	
	EDMA_scr_slave_scan (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, VCP2A_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(VCP2A STALLED): The VCP_2A slave on SCR_3B from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The VCP_2A module might not be enabled in the Power-Sleep Controller\n");  
		GEL_TextOut("                    2) VCP_2A is not responding to reads from Masters on the SCR\n");
        GEL_TextOut("                    3) SCR_3B is stalled\n"); 
		GEL_TextOut("                    4) The following is the transaction status returned by VCP2A on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" VCP2A Slave scan Test PASSED\n");
	}
	
	//Scan the VCP 2B slave
	
	EDMA_scr_slave_scan (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, VCP2B_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(VCP2B STALLED): The VCP_2B slave on SCR_3B from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The VCP_2B module might not be enabled in the Power-Sleep Controller\n");  
		GEL_TextOut("                    2) VCP_2B is not responding to reads from Masters on the SCR\n");
		GEL_TextOut("                    3) SCR_3B is stalled\n");
		GEL_TextOut("                    4) The following is the transaction status returned by VCP2B on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" VCP2B Slave scan Test PASSED\n");
	}
	
	//Scan the VCP 2C slave
	
	EDMA_scr_slave_scan (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, VCP2C_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(VCP2C STALLED): The VCP_2C slave on SCR_3B from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The VCP_2C module might not be enabled in the Power-Sleep Controller\n");  
		GEL_TextOut("                    2) VCP_2C is not responding to reads from Masters on the SCR\n");
        GEL_TextOut("                    3) SCR_3B is stalled\n"); 
		GEL_TextOut("                    4) The following is the transaction status returned by VCP2C on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" VCP2C Slave scan Test PASSED\n");
	}

	//Scan the VCP 2D slave
	
	EDMA_scr_slave_scan (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, VCP2D_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(VCP2D STALLED): The VCP_2D slave on SCR_3B from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The VCP_2D module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) VCP_2D is not responding to reads from Masters on the SCR\n");
        GEL_TextOut("                    3) SCR_3B is stalled\n"); 
		GEL_TextOut("                    4) The following is the transaction status returned by VCP2D on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" VCP2D Slave scan Test PASSED\n");
	}
	
	//Scan the TCP3D_B slave
	
	EDMA_scr_slave_scan (2, 2, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, TCP3D_B_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(TCP3D_B STALLED): The TCP3D_B slave on SCR_3E from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The TCP3D_B module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) TCP3D_B is not responding to reads from Masters on the SCR \n");
        GEL_TextOut("                    3) SCR_3_E is stalled \n"); 
		GEL_TextOut("                    4) The following is the transaction status returned by TCP3D_B on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC2_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC2_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" TCP3D_B Slave scan Test PASSED\n");
	}
	
	//Scan the TCP3D_A slave
	
	EDMA_scr_slave_scan (2, 2, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, TCP3D_A_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(TCP3D_A STALLED): The TCP3D_A slave on SCR_3E from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The TCP3D_A module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) TCP3D_A is not responding to reads from Masters on the SCR\n"); 
        GEL_TextOut("                    3) SCR_3_E is stalled \n"); 
		GEL_TextOut("                    4) The following is the transaction status returned by TCP3D_A on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC2_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC2_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" TCP3D_A Slave scan Test PASSED\n");
	}
	
	//Scan the RAC_B slave
	
	EDMA_scr_slave_scan (1, 1, EDMA_TPCC1_PARAM_NUM, EDMA_TPCC1_CHAN_NUM, RAC_B_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(RAC_B STALLED): The RAC_B slave on SCR_3_G from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The RAC_B module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) RAC_B is not responding to reads from Masters on the SCR \n");
        GEL_TextOut("                    3) Bridge 68 and Bridge 70 are stalled \n");
        GEL_TextOut("                    4) SCR_3_G is stalled \n"); 
		GEL_TextOut("                    5) The following is the transaction status returned by RAC_B on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA1_TPTC1_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA1_TPTC1_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" RAC_B Slave scan Test PASSED\n");
	}
	
	//Scan the RAC_A slave
	
	EDMA_scr_slave_scan (1, 1, EDMA_TPCC1_PARAM_NUM, EDMA_TPCC1_CHAN_NUM, RAC_A_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(RAC_A STALLED): The RAC_A slave on SCR_3_G from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The RAC_A module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) RAC_A is not responding to reads from Masters on the SCR \n");
        GEL_TextOut("                    3) Bridge 42 and Bridge 69 are stalled \n");
        GEL_TextOut("                    4) SCR_3_G is stalled \n"); 
		GEL_TextOut("                    5) The following is the transaction status returned by RAC_A on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA1_TPTC1_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA1_TPTC1_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" RAC_A Slave scan Test PASSED\n");
	}
	
	//Scan the TAC slave
	
	EDMA_scr_slave_scan (1, 3, EDMA_TPCC1_PARAM_NUM, EDMA_TPCC1_CHAN_NUM, TAC_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(TAC STALLED): The TAC slave on Bridge 52 from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The TAC module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) TAC is not responding to reads from Masters on the SCR \n");
        GEL_TextOut("                    3) Bridge 52 is stalled \n"); 
		GEL_TextOut("                    4) The following is the transaction status returned by TAC on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA1_TPTC3_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA1_TPTC3_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" TAC Slave scan Test PASSED\n");
	}
	
	//Scan the SPI slave
	
	EDMA_scr_slave_scan (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, SPI_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(SPI STALLED): The SPI slave on SCR_6P_A via Bridge 11 from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The SPI module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) SPI is not responding to reads from Masters on the SCR\n");
        GEL_TextOut("                    3) Bridge 11 is stalled \n");
        GEL_TextOut("                    4) SCR_6P_A is stalled \n");  
		GEL_TextOut("                    5) The following is the transaction status returned by SPI on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" SPI Slave scan Test PASSED\n");
	}
	
	//Scan the BOOT_ROM slave
	
	EDMA_scr_slave_scan (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, BOOTROM_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(BOOT_ROM STALLED): The BOOT_ROM slave on SCR_6P_A via Bridge 11 from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The BOOT_ROM module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) BOOT_ROM is not responding to reads from Masters on the SCR\n");
        GEL_TextOut("                    3) Bridge 11 is stalled \n");
        GEL_TextOut("                    4) SCR_6P_A is stalled \n");  
		GEL_TextOut("                    5) The following is the transaction status returned by BOOT_ROM on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" BOOT_ROM Slave scan Test PASSED\n");
	}
	
	
	//Scan the EMIF16 slave
	
	EDMA_scr_slave_scan (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, EMIF16_MEMREAD_ADDR, MSMC_DST_TEST_MEMADDR);
	
	status = BB_REG_FIELD_READ(MSMC_SRC_TEST_MEMADDR,31,0);
	
	if(status == 1)
	{
		GEL_TextOut(" Problem(EMIF16 STALLED): The EMIF16 slave on SCR_6P_A via Bridge 11 from SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The EMIF16 module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) EMIF16 is not responding to reads from Masters on the SCR\n");
        GEL_TextOut("                    3) Bridge 11 is stalled \n");
        GEL_TextOut("                    4) SCR_6P_A is stalled \n");  
		GEL_TextOut("                    5) The following is the transaction status returned by EMIF16 on read:\n\n");
		
		//get the transaction status
		slave_trans_status = BB_REG_FIELD_READ((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRDET),3,0);
		
		if(slave_trans_status == 0x1)
		{
			GEL_TextOut("                    *****Read Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0x2)
		{
			GEL_TextOut("                    *****Read Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0x3)
		{
			GEL_TextOut("                    *****Read Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0x4)
		{
			GEL_TextOut("                    *****Read Data error *****\n\n");
		}
		else if(slave_trans_status == 0x7)
		{
			GEL_TextOut("                    *****Read Exclusive-operation failure *****\n\n");
		}
		else if(slave_trans_status == 0x9)
		{
			GEL_TextOut("                    *****Write Addressing error *****\n\n");
		}
		else if(slave_trans_status == 0xA)
		{
			GEL_TextOut("                    *****Write Privilege error *****\n\n");
		}
		else if(slave_trans_status == 0xB)
		{
			GEL_TextOut("                    *****Write Timeout error *****\n\n");
		}
		else if(slave_trans_status == 0xC)
		{
			GEL_TextOut("                    *****Write Data error *****\n\n");
		}
		else if(slave_trans_status == 0xF)
		{
			GEL_TextOut("                    *****Write Exclusive-operation failure *****\n\n");
		}
		
		//clear the err status
		BB_REG_FIELD_WRITE((EDMA2_TPTC3_BASE + EDMA_TPTC_ERRCLR), 0, 0, 0x1);
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" EMIF16 Slave scan Test PASSED\n");
	}
	
	//Scan the COREPAC0 slave
	
	//Write the test word at the source address
	BB_REG_FIELD_WRITE(COREPAC0_SRC_TEST_MEMADDR, 31, 0, BB_TEST_WORD1);
	BB_REG_FIELD_WRITE((COREPAC0_SRC_TEST_MEMADDR+4), 31, 0, BB_TEST_WORD2);
	
	EDMA_generic_transfer_req (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, COREPAC0_SRC_TEST_MEMADDR, COREPAC0_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(COREPAC0_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((COREPAC0_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(COREPAC0 STALLED): The COREPAC0 slave on SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The COREPAC0 module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) COREPAC0 is not responding to reads from Masters on the SCR\n\n");
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" COREPAC0 Slave scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(COREPAC0_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((COREPAC0_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan the COREPAC1 slave
	
	//Write the test word at the source address
	BB_REG_FIELD_WRITE(COREPAC1_SRC_TEST_MEMADDR, 31, 0, BB_TEST_WORD1);
	BB_REG_FIELD_WRITE((COREPAC1_SRC_TEST_MEMADDR+4), 31, 0, BB_TEST_WORD2);
	
	EDMA_generic_transfer_req (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, COREPAC1_SRC_TEST_MEMADDR, COREPAC1_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(COREPAC1_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((COREPAC1_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(COREPAC1 STALLED): The COREPAC1 slave on SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The COREPAC1 module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) COREPAC1 is not responding to reads from Masters on the SCR\n\n");
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" COREPAC1 Slave scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(COREPAC1_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((COREPAC1_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan the COREPAC2 slave
	
	//Write the test word at the source address
	BB_REG_FIELD_WRITE(COREPAC2_SRC_TEST_MEMADDR, 31, 0, BB_TEST_WORD1);
	BB_REG_FIELD_WRITE((COREPAC2_SRC_TEST_MEMADDR+4), 31, 0, BB_TEST_WORD2);
	
	EDMA_generic_transfer_req (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, COREPAC2_SRC_TEST_MEMADDR, COREPAC2_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(COREPAC2_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((COREPAC2_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(COREPAC2 STALLED): The COREPAC2 slave on SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The COREPAC2 module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) COREPAC2 is not responding to reads from Masters on the SCR\n\n");
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" COREPAC2 Slave scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(COREPAC2_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((COREPAC2_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	//Scan the COREPAC3 slave
	
	//Write the test word at the source address
	BB_REG_FIELD_WRITE(COREPAC3_SRC_TEST_MEMADDR, 31, 0, BB_TEST_WORD1);
	BB_REG_FIELD_WRITE((COREPAC3_SRC_TEST_MEMADDR+4), 31, 0, BB_TEST_WORD2);
	
	EDMA_generic_transfer_req (2, 3, EDMA_TPCC2_PARAM_NUM, EDMA_TPCC2_CHAN_NUM, COREPAC3_SRC_TEST_MEMADDR, COREPAC3_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(COREPAC3_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((COREPAC3_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(COREPAC3 STALLED): The COREPAC3 slave on SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The COREPAC3 module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) COREPAC3 is not responding to reads from Masters on the SCR\n\n");
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" COREPAC3 Slave scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(COREPAC3_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((COREPAC3_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan the MSMC_SMS slave
	
	//Write the test word at the source address
	BB_REG_FIELD_WRITE(MSMC_SRC_TEST_MEMADDR, 31, 0, BB_TEST_WORD1);
	BB_REG_FIELD_WRITE((MSMC_SRC_TEST_MEMADDR+4), 31, 0, BB_TEST_WORD2);
	
	EDMA_generic_transfer_req (0, 1, EDMA_TPCC0_PARAM_NUM, EDMA_TPCC0_CHAN_NUM, MSMC_SRC_TEST_MEMADDR, MSMC_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(MSMC_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((MSMC_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(MSMC_SMS STALLED): The MSMC SMS slave on SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The MSMC module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) MSMC SMS is not responding to reads from Masters on the SCR\n\n");
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" MSMC_SMS Slave scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(MSMC_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((MSMC_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	
	//Scan the MSMC_SES slave
	
	//Write the test word at the source address
	BB_REG_FIELD_WRITE(DDR_SRC_TEST_MEMADDR, 31, 0, BB_TEST_WORD1);
	BB_REG_FIELD_WRITE((DDR_SRC_TEST_MEMADDR+4), 31, 0, BB_TEST_WORD2);
	
	EDMA_generic_transfer_req (0, 1, EDMA_TPCC0_PARAM_NUM, EDMA_TPCC0_CHAN_NUM, DDR_SRC_TEST_MEMADDR, DDR_DST_TEST_MEMADDR);
	
	//Check for the status of the EDMA transfer
	result1 = BB_REG_FIELD_READ(DDR_DST_TEST_MEMADDR,31,0);
	result2 = BB_REG_FIELD_READ((DDR_DST_TEST_MEMADDR+4),31,0);
	
	if(result1 != BB_TEST_WORD1 || result2 != BB_TEST_WORD2)
	{
		//EDMA transfer unsuccessful
		
		GEL_TextOut(" Problem(MSMC_SES STALLED): The MSMC SES slave on SCR_3A is stalled.\n");
		GEL_TextOut(" Reason & Solution: 1) The MSMC module might not be enabled in the Power-Sleep Controller \n"); 
		GEL_TextOut("                    2) MSMC SES is not responding to reads from Masters on the SCR\n");
		GEL_TextOut("                    3) DDR might not be enabled\n\n");
		
		slave_err_flag = 1;
	}
	else
	{
		GEL_TextOut(" MSMC_SES Slave scan Test PASSED\n");
	}
	
	//Reset DST memory
	BB_REG_FIELD_WRITE(DDR_DST_TEST_MEMADDR, 31, 0, 0x00000000);
	BB_REG_FIELD_WRITE((DDR_DST_TEST_MEMADDR+4), 31, 0, 0x00000000);
	
	//Check for no errors found during the bridge scan
	if(slave_err_flag == 0)
	{
		GEL_TextOut(" No Errors detected in the SCR Slaves error scan\n\n");
	}
	else
	{
		slave_err_flag == 0;
	}
	
	GEL_TextOut(" SLAVES NOT TESTED: SRIO_Slave, PCIe_Slave, HYPERBRIDGE_Slave, QMSS_Slave\n\n");
	
}

#define BOOTCFG_DIEID0                                 (0x02620008u)
#define BOOTCFG_DIEID1                                 (0x0262000Cu)
#define BOOTCFG_DIEID2                                 (0x02620010u)
#define BOOTCFG_DIEID3                                 (0x02620014u)
#define BOOTCFG_JTAGID								   (0x02620018u)
#define BOOTCFG_DEVSTAT                                (0x02620020u)
#define BOOTCFG_MACID1                                 (0x02620110u)
#define BOOTCFG_MACID2                                 (0x02620114u)
#define BOOTCFG_BOOTCOMPLETE                           (0x0262013Cu)
#define BOOTCFG_BOOTPROGRESS                           (0x02620140u)
#define BOOTCFG_RESET_STAT                             (0x02620144u)
#define BOOTCFG_DEVCFG                                 (0x02620150u)
#define BOOTCFG_PWRSTATECTL                            (0x02620140u)
#define BOOTCFG_SRIO_SERDES_STS                        (0x02620154u)
#define BOOTCFG_SGMII_SERDES_STS                       (0x02620158u)
#define BOOTCFG_PCIE_SERDES_STS                        (0x0262015Cu)
#define BOOTCFG_HYPERBRIDGE_SERDES_STS                 (0x02620160u)
#define BOOTCFG_AIF2_B8_SERDES_STS                     (0x02620164u)
#define BOOTCFG_AIF2_B4_SERDES_STS                     (0x02620168u)

#define BOOTCFG_RSTMUX0                                (0x02620308u)
#define BOOTCFG_RSTMUX1                                (0x0262030Cu)
#define BOOTCFG_RSTMUX2                                (0x02620310u)
#define BOOTCFG_RSTMUX3                                (0x02620314u)

#define BOOTCFG_MAINPLLCTL0                            (0x02620328u)
#define BOOTCFG_MAINPLLCTL1                            (0x0262032Cu)

#define BOOTCFG_DDR3PLLCTL0                            (0x02620330u)
#define BOOTCFG_DDR3PLLCTL1                            (0x02620334u)

#define BOOTCFG_PAPLLCTL0                              (0x02620338u)
#define BOOTCFG_PAPLLCTL1                              (0x0262033Cu)

#define BOOTCFG_SGMII_SERDES_CFGPLL                    (0x02620340u)
#define BOOTCFG_SGMII_SERDES_CFGRX0                    (0x02620344u)
#define BOOTCFG_SGMII_SERDES_CFGTX0                    (0x02620348u)
#define BOOTCFG_SGMII_SERDES_CFGRX1                    (0x0262034Cu)
#define BOOTCFG_SGMII_SERDES_CFGTX1                    (0x02620350u)
#define BOOTCFG_SGMII_SERDES_RSVD                      (0x02620354u)

#define BOOTCFG_PCIE_SERDES_CFGPLL                     (0x02620358u)
#define PCIE_SERDES_CFG0                               (0x21800390u)
#define PCIE_SERDES_CFG1                               (0x21800390u)
#define BOOTCFG_PCIE_SERDES_RSVD                       (0x0262035Cu)

#define BOOTCFG_SRIO_SERDES_CFGPLL                     (0x02620360u)
#define BOOTCFG_SRIO_SERDES_CFGRX0                     (0x02620364u)
#define BOOTCFG_SRIO_SERDES_CFGTX0                     (0x02620368u)
#define BOOTCFG_SRIO_SERDES_CFGRX1                     (0x0262036Cu)
#define BOOTCFG_SRIO_SERDES_CFGTX1                     (0x02620370u)
#define BOOTCFG_SRIO_SERDES_CFGRX2                     (0x02620374u)
#define BOOTCFG_SRIO_SERDES_CFGTX2                     (0x02620378u)
#define BOOTCFG_SRIO_SERDES_CFGRX3                     (0x0262037Cu)
#define BOOTCFG_SRIO_SERDES_CFGTX3                     (0x02620380u)
#define BOOTCFG_SRIO_SERDES_RSVD                       (0x02620384u)


#define BOOTCFG_SECURE_CONTROL                         (0x0262039Cu)
#define BOOTCFG_OBSCLKCTL                              (0x026203ACu)
#define BOOTCFG_AIF2_SERDES_RSVD                       (0x026203B0u)

#define BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL              (0x026203B4u)
#define BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0              (0x026203B8u)
#define BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0              (0x026203BCu)
#define BOOTCFG_HYPERBRIDGE_SERDES_CFGRX1              (0x026203C0u)
#define BOOTCFG_HYPERBRIDGE_SERDES_CFGTX1              (0x026203C4u)
#define BOOTCFG_HYPERBRIDGE_SERDES_CFGRX2              (0x026203C8u)
#define BOOTCFG_HYPERBRIDGE_SERDES_CFGTX2              (0x026203CCu)
#define BOOTCFG_HYPERBRIDGE_SERDES_CFGRX3              (0x026203D0u)
#define BOOTCFG_HYPERBRIDGE_SERDES_CFGTX3              (0x026203D4u)
#define BOOTCFG_HYPERBRIDGE_SERDES_RSVD                (0x026203D8u)

#define BOOTCFG_DSP_BOOT_ADDR0                         (0x02620040u)
#define BOOTCFG_DSP_BOOT_ADDR1                         (0x02620044u)
#define BOOTCFG_DSP_BOOT_ADDR2                         (0x02620048u)
#define BOOTCFG_DSP_BOOT_ADDR3                         (0x0262004Cu)


#define BOOTCFG_CHIP_MISC_CTL                          (0x02620400u)


#define BOOTCFG_DDR3_CONFIG_REG_0                      (0x02620404u)
#define BOOTCFG_DDR3_CONFIG_REG_1                      (0x02620408u)
#define BOOTCFG_DDR3_CONFIG_REG_2                      (0x0262040Cu)
#define BOOTCFG_DDR3_CONFIG_REG_3                      (0x02620410u)
#define BOOTCFG_DDR3_CONFIG_REG_4                      (0x02620414u)
#define BOOTCFG_DDR3_CONFIG_REG_5                      (0x02620418u)
#define BOOTCFG_DDR3_CONFIG_REG_6                      (0x0262041Cu)
#define BOOTCFG_DDR3_CONFIG_REG_7                      (0x02620420u)
#define BOOTCFG_DDR3_CONFIG_REG_8                      (0x02620424u)
#define BOOTCFG_DDR3_CONFIG_REG_9                      (0x02620428u)
#define BOOTCFG_DDR3_CONFIG_REG_10                     (0x0262042Cu)
#define BOOTCFG_DDR3_CONFIG_REG_11                     (0x02620430u)
#define BOOTCFG_DDR3_CONFIG_REG_12                     (0x02620434u)
#define BOOTCFG_DDR3_CONFIG_REG_13                     (0x02620438u)
#define BOOTCFG_DDR3_CONFIG_REG_14                     (0x0262043Cu)
#define BOOTCFG_DDR3_CONFIG_REG_15                     (0x02620440u)
#define BOOTCFG_DDR3_CONFIG_REG_16                     (0x02620444u)
#define BOOTCFG_DDR3_CONFIG_REG_17                     (0x02620448u)
#define BOOTCFG_DDR3_CONFIG_REG_18                     (0x0262044Cu)
#define BOOTCFG_DDR3_CONFIG_REG_19                     (0x02620450u)
#define BOOTCFG_DDR3_CONFIG_REG_20                     (0x02620454u)
#define BOOTCFG_DDR3_CONFIG_REG_21                     (0x02620458u)
#define BOOTCFG_DDR3_CONFIG_REG_22                     (0x0262045Cu)
#define BOOTCFG_DDR3_CONFIG_REG_23                     (0x02620460u)
#define BOOTCFG_DDR3_CONFIG_REG_24                     (0x02620464u)


#define BOOT_PLLCONTROL_PLLM                                (0x02310110u)

TCI6614_boot_pll_config()
{
	unsigned int reg_field, reg_field1, reg_field2, plld, clkf, pllm;
	
	//Main PLL Configuration
	reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,13,11);
	
	if(reg_field1 == 0)
	{
		GEL_TextOut(" Input Clock Frequency = 50 MHz\n");
		
		pllm = BB_REG_FIELD_READ(BOOT_PLLCONTROL_PLLM,5,0);
		
		plld = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0);
		
		clkf = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12);
		
		pllm = (clkf << 6) | pllm;
		
		reg_field2 = (50*((pllm+1)/(plld+1)))/2;   //Core Clk freq
		
		GEL_TextOut(" Core Clock Frequency = %d MHz\n",,,,,reg_field2);
	}
	else if(reg_field1 == 1)
	{
		GEL_TextOut(" Input Clock Frequency = 66.67 MHz\n");
		
		pllm = BB_REG_FIELD_READ(BOOT_PLLCONTROL_PLLM,5,0);
		
		plld = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0);
		
		clkf = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12);
		
		pllm = (clkf << 6) | pllm;
		
		reg_field2 = (66.67*((pllm+1)/(plld+1)))/2;   //Core Clk freq
		
		GEL_TextOut(" Core Clock Frequency = %d MHz\n",,,,,reg_field2);
	}
	else if(reg_field1 == 2)
	{
		GEL_TextOut(" Input Clock Frequency = 80 MHz\n");
		
		pllm = BB_REG_FIELD_READ(BOOT_PLLCONTROL_PLLM,5,0);
		
		plld = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0);
		
		clkf = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12);
		
		pllm = (clkf << 6) | pllm;
		
		reg_field2 = (80*((pllm+1)/(plld+1)))/2;   //Core Clk freq
		
		GEL_TextOut(" Core Clock Frequency = %d MHz\n",,,,,reg_field2);
	}
	else if(reg_field1 == 3)
	{
		GEL_TextOut(" Input Clock Frequency = 100 MHz\n");
		
		pllm = BB_REG_FIELD_READ(BOOT_PLLCONTROL_PLLM,5,0);
		
		plld = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0);
		
		clkf = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12);
		
		pllm = (clkf << 6) | pllm;
		
		reg_field2 = (100*((pllm+1)/(plld+1)))/2;   //Core Clk freq
		
		GEL_TextOut(" Core Clock Frequency = %d MHz\n",,,,,reg_field2);
	}
	else if(reg_field1 == 4)
	{
		GEL_TextOut(" Input Clock Frequency = 156.25 MHz\n");
		
		pllm = BB_REG_FIELD_READ(BOOT_PLLCONTROL_PLLM,5,0);
		
		plld = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0);
		
		clkf = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12);
		
		pllm = (clkf << 6) | pllm;
		
		reg_field2 = (156.25*((pllm+1)/(plld+1)))/2;   //Core Clk freq
		
		GEL_TextOut(" Core Clock Frequency = %d MHz\n",,,,,reg_field2);
	}
	else if(reg_field1 == 5)
	{
		GEL_TextOut(" Input Clock Frequency = 250 MHz\n");
		
		pllm = BB_REG_FIELD_READ(BOOT_PLLCONTROL_PLLM,5,0);
		
		plld = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0);
		
		clkf = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12);
		
		pllm = (clkf << 6) | pllm;
		
		reg_field2 = (250*((pllm+1)/(plld+1)))/2;   //Core Clk freq
		
		GEL_TextOut(" Core Clock Frequency = %d MHz\n",,,,,reg_field2);
	}
	else if(reg_field1 == 6)
	{
		GEL_TextOut(" Input Clock Frequency = 312.5 MHz\n");
		
		pllm = BB_REG_FIELD_READ(BOOT_PLLCONTROL_PLLM,5,0);
		
		plld = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0);
		
		clkf = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12);
		
		pllm = (clkf << 6) | pllm;
		
		reg_field2 = (312.5*((pllm+1)/(plld+1)))/2;   //Core Clk freq
		
		GEL_TextOut(" Core Clock Frequency = %d MHz\n",,,,,reg_field2);
	}
	else if(reg_field1 == 7)
	{
		GEL_TextOut(" Input Clock Frequency = 122.88 MHz\n");
		
		pllm = BB_REG_FIELD_READ(BOOT_PLLCONTROL_PLLM,5,0);
		
		plld = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0);
		
		clkf = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12);
		
		pllm = (clkf << 6) | pllm;
		
		reg_field2 = (122.88*((pllm+1)/(plld+1)))/2;   //Core Clk freq
		
		GEL_TextOut(" Core Clock Frequency = %d MHz\n",,,,,reg_field2);
	}
}


TCI6614_device_status()
{
	unsigned int reg_field, reg_field1, reg_field2, clkr, clkf;
	
	GEL_TextOut(" ********************************** TCI6614 Device Status Register (DEVSTAT) ************************************\n\n");
	
	GEL_TextOut(" BOOTCFG_DEVSTAT ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,31,0));
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,14,14);
	
	if(reg_field == 1)
	{
		GEL_TextOut(" BOOT_MASTER ---> ARM initiates the boot sequence\n");
	}
	else
	{
		GEL_TextOut(" BOOT_MASTER ---> DSP CorePAC initiates the boot sequence\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,0,0);
	
	if(reg_field == 1)
	{
		GEL_TextOut(" LENDIAN[0] ---> Little Endian\n");
	}
	else
	{
		GEL_TextOut(" LENDIAN[0] ---> Big Endian\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,3,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" BOOTMODE[3:1] ---> Sleep or No Boot Mode\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" BOOTMODE[3:1] ---> SRIO Boot Mode\n");
		
		//Get Smart Reflex ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,5,4);
		
		GEL_TextOut(" SmartReflex ID[5:4] ---> %d\n",,,,,reg_field1);
		
		//SRIO Reference clock
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,7,6);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" SRIO Reference Clock = 156.25 MHz\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" SRIO Reference Clock = 250 MHz\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" SRIO Reference Clock = 312.5 MHz\n");
		}
		
		//SRIO Data Rate
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,9,8);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" SRIO Data Rate = 1.25 Gbps\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" SRIO Data Rate = 2.5 Gbps\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" SRIO Data Rate = 3.125 Gbps\n");
		}
		else if(reg_field1 == 3)
		{
			GEL_TextOut(" SRIO Data Rate = 5.0 Gbps\n");
		}
		
		//SRIO Lane Setup
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,10,10);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" LANE[10] --->Port Configured as 4 ports each 1 lane wide (4x1ports)\n");
		}
		else
		{
			GEL_TextOut(" LANE[10] --->Port Configured as 2 ports 2 lanes wide (2x2 ports)\n");
		}
		
		TCI6614_boot_pll_config();
		
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" BOOTMODE[3:1] ---> Ethernet (SGMII) (PA driven from core clk) Boot Mode\n");
		
		//Get Smart Reflex ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,5,4);
		
		GEL_TextOut(" SmartReflex ID[5:4] ---> %d\n",,,,,reg_field1);
		
		//Get Device ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,6,4);
		
		GEL_TextOut(" DEV ID[6:4] ---> %d\n",,,,,reg_field1);
		
		//External connection
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,8,7);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" EXT CON[8:7] ---> Mac to Mac connection, master with auto negotiation\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" EXT CON[8:7] ---> Mac to Mac connection, slave, and Mac to Phy\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" EXT CON[8:7] ---> Mac to Mac, forced link\n");
		}
		else if(reg_field1 == 3)
		{
			GEL_TextOut(" EXT CON[8:7] ---> Mac to fiber connection\n");
		}
		
		//SERDES Clk Multipler
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,10,9);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" SERDES_MULT[10:9] ---> x8 for input clock of 156.25 MHz\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" SERDES_MULT[10:9] ---> x5 for input clock of 250 MHz\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" SERDES_MULT[10:9] ---> x4 for input clock of 312.5 MHz\n");
		}
		else if(reg_field1 == 3)
		{
			GEL_TextOut(" SERDES_MULT[10:9] ---> Reserved\n");
		}
		
		TCI6614_boot_pll_config();
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" BOOTMODE[3:1] ---> Ethernet (SGMII) (PA driver from PA clk) Boot Mode\n");
		
		//Get Smart Reflex ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,5,4);
		
		GEL_TextOut(" SmartReflex ID[5:4] ---> %d\n",,,,,reg_field1);
		
		//Get Device ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,6,4);
		
		GEL_TextOut(" DEV ID[6:4] ---> %d\n",,,,,reg_field1);
		
		//External connection
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,8,7);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" EXT CON[8:7] ---> Mac to Mac connection, master with auto negotiation\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" EXT CON[8:7] ---> Mac to Mac connection, slave, and Mac to Phy\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" EXT CON[8:7] ---> Mac to Mac, forced link\n");
		}
		else if(reg_field1 == 3)
		{
			GEL_TextOut(" EXT CON[8:7] ---> Mac to fiber connection\n");
		}
		
		//SERDES Clk Multipler
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,10,9);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" SERDES_MULT[10:9] ---> x8 for input clock of 156.25 MHz\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" SERDES_MULT[10:9] ---> x5 for input clock of 250 MHz\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" SERDES_MULT[10:9] ---> x4 for input clock of 312.5 MHz\n");
		}
		else if(reg_field1 == 3)
		{
			GEL_TextOut(" SERDES_MULT[10:9] ---> Reserved\n");
		}
		
		//PA PLL Configuration
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,13,11);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" Input Clock Frequency = 50 MHz\n");
			
			clkr = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0);
			
			clkf = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12);
			
			reg_field2 = 2*50*((clkf+1)/((2*clkr)+1));   //Core Clk freq
			
			GEL_TextOut(" PA Clock Frequency = %d MHz\n",,,,,reg_field2);
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" Input Clock Frequency = 66.67 MHz\n");
			
			clkr = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0);
			
			clkf = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12);
			
			reg_field2 = 2*66.67*((clkf+1)/((2*clkr)+1));   //Core Clk freq
			
			GEL_TextOut(" PA Clock Frequency = %d MHz\n",,,,,reg_field2);
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" Input Clock Frequency = 80 MHz\n");
			
			clkr = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0);
			
			clkf = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12);
			
			reg_field2 = 2*80*((clkf+1)/((2*clkr)+1));   //Core Clk freq
			
			GEL_TextOut(" PA Clock Frequency = %d MHz\n",,,,,reg_field2);
		}
		else if(reg_field1 == 3)
		{
			GEL_TextOut(" Input Clock Frequency = 100 MHz\n");
			
			clkr = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0);
			
			clkf = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12);
			
			reg_field2 = 2*100*((clkf+1)/((2*clkr)+1));   //Core Clk freq
			
			GEL_TextOut(" PA Clock Frequency = %d MHz\n",,,,,reg_field2);
		}
		else if(reg_field1 == 4)
		{
			GEL_TextOut(" Input Clock Frequency = 156.25 MHz\n");
			
			clkr = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0);
			
			clkf = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12);
			
			reg_field2 = 2*156.25*((clkf+1)/((2*clkr)+1));   //Core Clk freq
			
			GEL_TextOut(" PA Clock Frequency = %d MHz\n",,,,,reg_field2);
		}
		else if(reg_field1 == 5)
		{
			GEL_TextOut(" Input Clock Frequency = 250 MHz\n");
			
			clkr = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0);
			
			clkf = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12);
			
			reg_field2 = 2*250*((clkf+1)/((2*clkr)+1));   //Core Clk freq
			
			GEL_TextOut(" PA Clock Frequency = %d MHz\n",,,,,reg_field2);
		}
		else if(reg_field1 == 6)
		{
			GEL_TextOut(" Input Clock Frequency = 312.5 MHz\n");
			
			clkr = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0);
			
			clkf = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12);
			
			reg_field2 = 2*312.5*((clkf+1)/((2*clkr)+1));   //Core Clk freq
			
			GEL_TextOut(" PA Clock Frequency = %d MHz\n",,,,,reg_field2);
		}
		else if(reg_field1 == 7)
		{
			GEL_TextOut(" Input Clock Frequency = 122.88 MHz\n");
			
			clkr = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0);
			
			clkf = BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12);
			
			reg_field2 = 2*122.88*((clkf+1)/((2*clkr)+1));   //Core Clk freq
			
			GEL_TextOut(" PA Clock Frequency = %d MHz\n",,,,,reg_field2);
		}
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" BOOTMODE[3:1] ---> PCIe Boot Mode\n");
		
		//Get Smart Reflex ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,5,4);
		
		GEL_TextOut(" SmartReflex ID[5:4] ---> %d\n",,,,,reg_field1);
		
		//Get BAR Config
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,9,6);
		
		GEL_TextOut(" BAR Config[9:6] ---> %x\n",,,,,(unsigned char)reg_field1);
		
		TCI6614_boot_pll_config();
	}
	
	else if(reg_field == 5)
	{
		GEL_TextOut(" BOOTMODE[3:1] ---> I2C Boot Mode\n");
		
		//Get Smart Reflex ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,5,4);
		
		GEL_TextOut(" SmartReflex ID[5:4] ---> %d\n",,,,,reg_field1);
		
		//I2C boot Mode
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,10,10);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" MODE[10] ---> Master Mode\n");
		}
		else
		{
			GEL_TextOut(" MODE[10] ---> Passive Mode\n");
		}
		
		//I2C Address
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,11,11);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" ADDRESS[11] ---> Boot From I2C EEPROM at I2C bus address 0x50\n");
		}
		else
		{
			GEL_TextOut(" ADDRESS[11] ---> Boot From I2C EEPROM at I2C bus address 0x51\n");
		}
		
		//I2C Speed
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,12,12);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" SPEED[12] ---> I2C data rate set to approximately 20 kHz\n");
		}
		else
		{
			GEL_TextOut(" SPEED[12] ---> I2C fast mode. Data rate set to approximately 400 kHz (will not exceed)\n");
		}
		
		//Parameter Idx
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,9,4);
		
		GEL_TextOut(" PARAMETER IDX[9:4] ---> %d\n",,,,,reg_field1);
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" BOOTMODE[3:1] ---> SPI Boot Mode\n");
		
		//Get Smart Reflex ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,5,4);
		
		GEL_TextOut(" SmartReflex ID[5:4] ---> %d\n",,,,,reg_field1);
		
		//Get Parameter Table Idx
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,7,6);
		
		GEL_TextOut(" Param Table Idx[7:6] ---> %d\n",,,,,reg_field1);
		
		//Get chip select
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,9,8);
		
		GEL_TextOut(" Chip Select[9:8] ---> %d\n",,,,,reg_field1);
		
		//Address Width
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,10,10);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" ADDR_WIDTH[10] ---> 16 bit address values are used\n");
		}
		else
		{
			GEL_TextOut(" ADDR_WIDTH[10] ---> 24 bit address values are used\n");
		}
		
		//4,5 pin mode
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,11,11);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" 4,5 PIN MODE[11] ---> 4 pin mode used\n");
		}
		else
		{
			GEL_TextOut(" 4,5 PIN MODE[11] ---> 5 pin mode used\n");
		}
		
		//Mode
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,13,12);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" MODE[13:12] ---> Data is output on the rising edge of SPICLK. Input data is\n"); 
			GEL_TextOut("                  latched on the falling edge.\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" MODE[13:12] ---> Data is output one half-cycle before the first rising edge of SPICLK and on\n"); 
			GEL_TextOut("                  subsequent falling edges. Input data is latched on the rising edge of SPICLK.\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" MODE[13:12] ---> Data is output on the falling edge of SPICLK. Input data is \n"); 
			GEL_TextOut("                  latched on the rising edge.\n");
		}
		else if(reg_field1 == 3)
		{
			GEL_TextOut(" MODE[13:12] ---> Data is output one half-cycle before the first falling edge of SPICLK and on\n"); 
			GEL_TextOut("                  subsequent rising edges. Input data is latched on the falling edge of SPICLK.\n");
		}
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" BOOTMODE[3:1] ---> Hyperlink Boot Mode\n");
		
		//Get Smart Reflex ID
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,5,4);
		
		GEL_TextOut(" SmartReflex ID[5:4] ---> %d\n",,,,,reg_field1);
		
		//Reference Clock
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,7,6);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" REF CLOCK[7:6] ---> 156.25 MHz\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" REF CLOCK[7:6] ---> 250 MHz\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" REF CLOCK[7:6] ---> 312.5 MHz\n");
		}
		else
		{
			GEL_TextOut(" REF CLOCK[7:6] ---> Reserved\n");
		}
		
		//Data Rate
		reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,9,8);
		
		if(reg_field1 == 0)
		{
			GEL_TextOut(" DATA RATE[9:8] ---> 1.25 Gbaud\n");
		}
		else if(reg_field1 == 1)
		{
			GEL_TextOut(" DATA RATE[9:8] ---> 3.125 Gbaud\n");
		}
		else if(reg_field1 == 2)
		{
			GEL_TextOut(" DATA RATE[9:8] ---> 6.25 Gbaud\n");
		}
		else if(reg_field1 == 3)
		{
			GEL_TextOut(" DATA RATE[9:8] ---> 12.5 Gbaud\n");
		}
		
		TCI6614_boot_pll_config();
	}
	
	reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,17,17);
		
	if(reg_field1 == 0)
	{
		GEL_TextOut(" PCIESSEN[17] ---> Initial state of the power domain and the clock domain for PCIE subsystem is Disabled\n");
	}
	else
	{
		GEL_TextOut(" PCIESSEN[17] ---> Initial state of the power domain and the clock domain for PCIE subsystem is Enabled\n");
	}
	
	reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,16,15);
	
	if(reg_field1 == 0)
	{
		GEL_TextOut(" PCIESSMODE[16:15] ---> PCIE in End-point mode\n");
	}
	else if(reg_field1 == 1)
	{
		GEL_TextOut(" PCIESSMODE[16:15] ---> PCIE in Legacy End-point mode (no support for MSI)\n");
	}
	else if(reg_field1 == 2)
	{
		GEL_TextOut(" PCIESSMODE[16:15] ---> PCIE in Root complex mode\n");
	}
	else
	{
		GEL_TextOut(" PCIESSMODE[16:15] ---> Reserved\n");
	}
	
	reg_field1 = BB_REG_FIELD_READ(BOOTCFG_DEVSTAT,18,18);
		
	if(reg_field1 == 0)
	{
		GEL_TextOut(" PASSCLKSEL[18] ---> SYSCLK / ALTCORECLK (controlled by CORECLKSEL pin) is used as the input to PA_SS PLL\n");
	}
	else
	{
		GEL_TextOut(" PASSCLKSEL[18] --->  PA_SS_CLK is used as the input to PA_SS PLL\n");
	}

}


TCI6614_getDIEID()
{
	unsigned int reg_field;
	
	GEL_TextOut(" ********************************** TCI6614 DIEID Register (DIEID) ************************************\n\n");
	
	GEL_TextOut(" DIEID0 ---> %x\n",,,,,*(unsigned int*)BOOTCFG_DIEID0);
	GEL_TextOut(" DIEID1 ---> %x\n",,,,,*(unsigned int*)BOOTCFG_DIEID1);
	GEL_TextOut(" DIEID2 ---> %x\n",,,,,*(unsigned int*)BOOTCFG_DIEID2);
	GEL_TextOut(" DIEID3 ---> %x\n",,,,,*(unsigned int*)BOOTCFG_DIEID3);
	
}


TCI6614_getMACID()
{
	unsigned int reg_field;
	
	GEL_TextOut(" ********************************** TCI6614 MACID Register (MACID) ************************************\n\n");
	
	GEL_TextOut(" MACID[31:0] ---> %x\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_MACID1,31,0));
	
	GEL_TextOut(" MACID[32:47] ---> %x\n",,,,,(unsigned short)BB_REG_FIELD_READ(BOOTCFG_MACID2,15,0));
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_MACID2,16,16);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" BCAST[16](Broadcast Reception) ---> Broadcast\n");
	}
	else
	{
		GEL_TextOut(" BCAST[16](Broadcast Reception) ---> Disabled\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_MACID2,17,17);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" BCAST[17](MAC Flow Control) ---> Off\n");
	}
	else
	{
		GEL_TextOut(" BCAST[17](MAC Flow Control) ---> On\n");
	}
	
	GEL_TextOut(" CHECKSUM[24:31] ---> %x\n\n",,,,,(unsigned char)BB_REG_FIELD_READ(BOOTCFG_MACID2,31,24));
}


TCI6614_boot_Status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 BOOT STATUS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	//Get Boot Progress
	GEL_TextOut(" BOOTPROGRESS[31:0] ---> %x\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_BOOTPROGRESS,31,0));
	
	GEL_TextOut(" BOOTCFG_BOOTCOMPLETE ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_BOOTCOMPLETE,31,0));
	
	//Read Boot Complete
	reg_field = BB_REG_FIELD_READ(BOOTCFG_BOOTCOMPLETE,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Core 0 ---> Boot in process. Not Complete\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Core 0 ---> Boot process Completed\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_BOOTCOMPLETE,1,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Core 1 ---> Boot in process. Not Complete\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Core 1 ---> Boot process Completed\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_BOOTCOMPLETE,2,2);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Core 2 ---> Boot in process. Not Complete\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Core 2 ---> Boot process Completed\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_BOOTCOMPLETE,3,3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Core 3 ---> Boot in process. Not Complete\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Core 3 ---> Boot process Completed\n");
	}
}


TCI6614_reset_status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 RESET STATUS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	GEL_TextOut(" BOOTCFG_RESET_STAT ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_RESET_STAT,31,0));
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_RESET_STAT,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Global Reset ---> Device has not received a global reset\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Global Reset ---> Device received a global reset\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_RESET_STAT,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Core 0 Reset ---> Core 0 has not received a local reset\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Core 0 Reset ---> Core 0 received a local reset\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_RESET_STAT,1,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Core 1 Reset ---> Core 1 has not received a local reset\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Core 1 Reset ---> Core 1 received a local reset\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_RESET_STAT,2,2);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Core 2 Reset ---> Core 2 has not received a local reset\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Core 2 Reset ---> Core 2 received a local reset\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_RESET_STAT,3,3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCI6614 Core 3 Reset ---> Core 3 has not received a local reset\n");
	}
	else
	{
		GEL_TextOut(" TCI6614 Core 3 Reset ---> Core 3 received a local reset\n");
	}
}

#define PLLCONTROL_FUSE_ERR                             (0x023100E0u)


TCI6614_efuse_status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 EFUSE AUTOLOAD STATUS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_FUSE_ERR ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_FUSE_ERR,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_FUSE_ERR,31,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Efuse Autoload ##PASS## \n");
	}
	else if (reg_field != 0)
	{
		GEL_TextOut(" Efuse Autoload **FAIL** With Value %x\n",,,,,reg_field);
	}
}


TCI6614_srio_serdes_status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SRIO SERDES STATUS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	GEL_TextOut(" BOOTCFG_SRIO_SERDES_STS ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,31,0));

	//SERDES PLL LOCK Status
	reg_field = BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SRIO SERDES PLL LOCK ---> PLL is **NOT** Locked\n\n");
	}
	else
	{
		GEL_TextOut(" SRIO SERDES PLL LOCK ---> PLL ##IS## Locked\n\n");
	}
	
	GEL_TextOut(" SRIO LANE 0 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,1,1));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,2,2));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,3,3));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,4,4));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,5,5));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,6,6));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,7,7));
	
	
	GEL_TextOut(" SRIO LANE 1 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,8,8));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,9,9));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,10,10));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,11,11));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,12,12));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,13,13));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,14,14));
	
	
	GEL_TextOut(" SRIO LANE 2 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,15,15));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,16,16));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,17,17));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,18,18));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,19,19));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,20,20));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,21,21));
	
	
	GEL_TextOut(" SRIO LANE 3 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,22,22));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,23,23));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,24,24));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,25,25));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,26,26));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,27,27));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_STS,28,29));
}


TCI6614_hyperbridge_serdes_status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES STATUS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	GEL_TextOut(" BOOTCFG_HYPERBRIDGE_SERDES_STS ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,31,0));

	//SERDES PLL LOCK Status
	reg_field = BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" HYPERBRIDGE SERDES PLL LOCK ---> PLL is **NOT** Locked\n\n");
	}
	else
	{
		GEL_TextOut(" HYPERBRIDGE SERDES PLL LOCK ---> PLL ##IS## Locked\n\n");
	}
	
	GEL_TextOut(" HYPERBRIDGE LANE 0 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,1,1));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,2,2));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,3,3));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,4,4));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,5,5));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,6,6));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,7,7));
	
	
	GEL_TextOut(" HYPERBRIDGE LANE 1 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,8,8));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,9,9));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,10,10));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,11,11));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,12,12));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,13,13));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,14,14));
	
	
	GEL_TextOut(" HYPERBRIDGE LANE 2 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,15,15));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,16,16));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,17,17));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,18,18));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,19,19));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,20,20));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,21,21));
	
	
	GEL_TextOut(" HYPERBRIDGE LANE 3 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,22,22));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,23,23));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,24,24));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,25,25));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,26,26));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,27,27));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_STS,28,29));
}


TCI6614_aif2_serdes_status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 AIF2 SERDES STATUS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	GEL_TextOut(" BOOTCFG_AIF2_B8_SERDES_STS ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,31,0));

	//SERDES PLL LOCK Status
	reg_field = BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" AIF2 B8 SERDES PLL LOCK ---> PLL is **NOT** Locked\n\n");
	}
	else
	{
		GEL_TextOut(" AIF2 B8 SERDES PLL LOCK ---> PLL ##IS## Locked\n\n");
	}
	
	GEL_TextOut(" AIF2 B8 LANE 0 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,1,1));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,2,2));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,3,3));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,4,4));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,5,5));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,6,6));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,7,7));
	
	
	GEL_TextOut(" AIF2 B8 LANE 1 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,8,8));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,9,9));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,10,10));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,11,11));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,12,12));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,13,13));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,14,14));
	
	
	GEL_TextOut(" AIF2 B8 LANE 2 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,15,15));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,16,16));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,17,17));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,18,18));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,19,19));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,20,20));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,21,21));
	
	
	GEL_TextOut(" AIF2 B8 LANE 3 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,22,22));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,23,23));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,24,24));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,25,25));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,26,26));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,27,27));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B8_SERDES_STS,28,29));
	
	
	//SERDES PLL LOCK Status
	
	GEL_TextOut(" BOOTCFG_AIF2_B4_SERDES_STS ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,31,0));
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" AIF2 B4 SERDES PLL LOCK ---> PLL is **NOT** Locked\n\n");
	}
	else
	{
		GEL_TextOut(" AIF2 B4 SERDES PLL LOCK ---> PLL ##IS## Locked\n\n");
	}
	
	GEL_TextOut(" AIF2 B4 LANE 0 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,1,1));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,2,2));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,3,3));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,4,4));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,5,5));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,6,6));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,7,7));
	
	
	GEL_TextOut(" AIF2 B4 LANE 1 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,8,8));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,9,9));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,10,10));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,11,11));
	
	GEL_TextOut(" EQ Under: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,12,12));
	
	GEL_TextOut(" EQ Over: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,13,13));
	
	GEL_TextOut(" Tx Test Fail: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_AIF2_B4_SERDES_STS,14,14));
}


TCI6614_sgmii_serdes_status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SGMII SERDES STATUS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	GEL_TextOut(" BOOTCFG_SGMII_SERDES_STS ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,31,0));

	//SERDES PLL LOCK Status
	reg_field = BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SGMII SERDES PLL LOCK ---> PLL is **NOT** Locked\n\n");
	}
	else
	{
		GEL_TextOut(" SGMII SERDES PLL LOCK ---> PLL ##IS## Locked\n\n");
	}
	
	GEL_TextOut(" SGMII 0 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,1,1));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,2,2));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,3,3));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,4,4));
	
	GEL_TextOut(" Tx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,5,5));
	
	GEL_TextOut(" RDTCTIP: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,6,6));
	
	
	GEL_TextOut(" SGMII 1 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,7,7));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,8,8));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,9,9));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,10,10));
	
	GEL_TextOut(" Tx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,11,11));
	
	GEL_TextOut(" RDTCTIP: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_STS,12,12));
}


TCI6614_pcie_serdes_status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 PCIE SERDES STATUS ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	GEL_TextOut(" BOOTCFG_PCIE_SERDES_STS ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,31,0));

	//SERDES PLL LOCK Status
	reg_field = BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PCIE SERDES PLL LOCK ---> PLL is **NOT** Locked\n\n");
	}
	else
	{
		GEL_TextOut(" PCIE SERDES PLL LOCK ---> PLL ##IS## Locked\n\n");
	}
	
	GEL_TextOut(" PCIE 0 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,1,1));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,2,2));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,3,3));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,4,4));
	
	GEL_TextOut(" Tx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,5,5));
	
	GEL_TextOut(" RDTCTIP: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,6,6));
	
	
	GEL_TextOut(" PCIE 1 SERDES STATUS: \n\n");
	
	GEL_TextOut(" Rx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,7,7));
	
	GEL_TextOut(" Sync: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,8,8));
	
	GEL_TextOut(" Losdtct: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,9,9));
	
	GEL_TextOut(" OCIP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,10,10));
	
	GEL_TextOut(" Tx Test Fail: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,11,11));
	
	GEL_TextOut(" RDTCTIP: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_STS,12,12));
}


TCI6614_pcie_serdes_pll_config()
{
	unsigned int reg_field;
	
	//CFGPLL
	
	GEL_TextOut(" ********************************** TCI6614 PCIE SERDES PLL CONFIGURATION ******************************\n\n");
	
	GEL_TextOut(" BOOTCFG_PCIE_SERDES_CFGPLL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,31,0));
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PCIE SERDES ENPLL ---> PLL is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" PCIE SERDES ENPLL ---> PLL is ##ENABLED##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,7,1);
	
	if(reg_field == 0x10)
	{
		GEL_TextOut(" MPY[7:1] => 4x PLL Multiply factor\n");
	}
	else if(reg_field == 0x14)
	{
		GEL_TextOut(" MPY[7:1] => 5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x18)
	{
		GEL_TextOut(" MPY[7:1] => 6x PLL Multiply factor\n");
	}
	else if(reg_field == 0x20)
	{
		GEL_TextOut(" MPY[7:1] => 8x PLL Multiply factor\n");
	}
	else if(reg_field == 0x21)
	{
		GEL_TextOut(" MPY[7:1] => 8.25x PLL Multiply factor\n");
	}
	else if(reg_field == 0x28)
	{
		GEL_TextOut(" MPY[7:1] => 10x PLL Multiply factor\n");
	}
	else if(reg_field == 0x30)
	{
		GEL_TextOut(" MPY[7:1] => 12x PLL Multiply factor\n");
	}
	else if(reg_field == 0x32)
	{
		GEL_TextOut(" MPY[7:1] => 12.5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x3C)
	{
		GEL_TextOut(" MPY[7:1] => 15x PLL Multiply factor\n");
	}
	else if(reg_field == 0x40)
	{
		GEL_TextOut(" MPY[7:1] => 16x PLL Multiply factor\n");
	}
	else if(reg_field == 0x42)
	{
		GEL_TextOut(" MPY[7:1] => 16.5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x50)
	{
		GEL_TextOut(" MPY[7:1] => 20x PLL Multiply factor\n");
	}
	else if(reg_field == 0x58)
	{
		GEL_TextOut(" MPY[7:1] => 22x PLL Multiply factor\n");
	}
	else if(reg_field == 0x64)
	{
		GEL_TextOut(" MPY[7:1] => 25x PLL Multiply factor\n");
	}
	else
	{
		GEL_TextOut(" MPY[7:1] => Reserved\n");
	}
	
	GEL_TextOut(" ENDIVCLK: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,8,8));
	
	GEL_TextOut(" VRANGE: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,9,9));
	
	GEL_TextOut(" SLEEPPLL: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,10,10));
	
	GEL_TextOut(" LOOP BANDWIDTH: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,12,11));
	
	GEL_TextOut(" CLKBYP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,14,13));
	
	GEL_TextOut(" STD: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PCIE_SERDES_CFGPLL,15,15));
}


TCI6614_pcie_serdes_lane_config0()
{
	GEL_TextOut(" ********************************** TCI6614 PCIE SERDES LANE0 CONFIGURATION ******************************\n\n");
	
	GEL_TextOut(" PCIE_SERDES_CFG0 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PCIE_SERDES_CFG0,31,0));
	
	GEL_TextOut(" RX_INVPAIR: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,0,0));
	
	GEL_TextOut(" RX_ALIGN: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,2,1));
	
	GEL_TextOut(" RX_LOS: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,5,3));
	
	GEL_TextOut(" RX_CDR: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,8,6));
	
	GEL_TextOut(" RX_EQ: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,12,9));
	
	GEL_TextOut(" RX_ENOC: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,13,13));
	
	GEL_TextOut(" RX_LOOPBACK: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,15,14));
	
	GEL_TextOut(" TX_INVPAIR: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,16,16));
	
	GEL_TextOut(" TX_CM: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,17,17));
	
	GEL_TextOut(" TX_MSYNC: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,18,18));
	
	GEL_TextOut(" TX_LOOPBACK: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG0,20,19));
}


TCI6614_pcie_serdes_lane_config1()
{
	GEL_TextOut(" ********************************** TCI6614 PCIE SERDES LANE1 CONFIGURATION ******************************\n\n");
	
	GEL_TextOut(" PCIE_SERDES_CFG1 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PCIE_SERDES_CFG1,31,0));
	
	GEL_TextOut(" RX_INVPAIR: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,0,0));
	
	GEL_TextOut(" RX_ALIGN: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,2,1));
	
	GEL_TextOut(" RX_LOS: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,5,3));
	
	GEL_TextOut(" RX_CDR: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,8,6));
	
	GEL_TextOut(" RX_EQ: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,12,9));
	
	GEL_TextOut(" RX_ENOC: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,13,13));
	
	GEL_TextOut(" RX_LOOPBACK: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,15,14));
	
	GEL_TextOut(" TX_INVPAIR: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,16,16));
	
	GEL_TextOut(" TX_CM: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,17,17));
	
	GEL_TextOut(" TX_MSYNC: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,18,18));
	
	GEL_TextOut(" TX_LOOPBACK: %d\n",,,,,BB_REG_FIELD_READ(PCIE_SERDES_CFG1,20,19));
}


TCI6614_sgmii_serdes_pll_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	//CFGPLL
	
	GEL_TextOut(" ********************************** TCI6614 SGMII SERDES%d PLL CONFIGURATION ******************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_SGMII_SERDES_CFGPLL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,31,0));
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SGMII SERDES ENPLL ---> PLL is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" SGMII SERDES ENPLL ---> PLL is ##ENABLED##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,7,1);
	
	if(reg_field == 0x10)
	{
		GEL_TextOut(" MPY[7:1] => 4x PLL Multiply factor\n");
	}
	else if(reg_field == 0x14)
	{
		GEL_TextOut(" MPY[7:1] => 5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x18)
	{
		GEL_TextOut(" MPY[7:1] => 6x PLL Multiply factor\n");
	}
	else if(reg_field == 0x20)
	{
		GEL_TextOut(" MPY[7:1] => 8x PLL Multiply factor\n");
	}
	else if(reg_field == 0x21)
	{
		GEL_TextOut(" MPY[7:1] => 8.25x PLL Multiply factor\n");
	}
	else if(reg_field == 0x28)
	{
		GEL_TextOut(" MPY[7:1] => 10x PLL Multiply factor\n");
	}
	else if(reg_field == 0x30)
	{
		GEL_TextOut(" MPY[7:1] => 12x PLL Multiply factor\n");
	}
	else if(reg_field == 0x32)
	{
		GEL_TextOut(" MPY[7:1] => 12.5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x3C)
	{
		GEL_TextOut(" MPY[7:1] => 15x PLL Multiply factor\n");
	}
	else if(reg_field == 0x40)
	{
		GEL_TextOut(" MPY[7:1] => 16x PLL Multiply factor\n");
	}
	else if(reg_field == 0x42)
	{
		GEL_TextOut(" MPY[7:1] => 16.5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x50)
	{
		GEL_TextOut(" MPY[7:1] => 20x PLL Multiply factor\n");
	}
	else if(reg_field == 0x58)
	{
		GEL_TextOut(" MPY[7:1] => 22x PLL Multiply factor\n");
	}
	else if(reg_field == 0x64)
	{
		GEL_TextOut(" MPY[7:1] => 25x PLL Multiply factor\n");
	}
	else
	{
		GEL_TextOut(" MPY[7:1] => Reserved\n");
	}
	
	GEL_TextOut(" ENDIVCLK: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,8,8));
	
	GEL_TextOut(" VRANGE: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,9,9));
	
	GEL_TextOut(" SLEEPPLL: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,10,10));
	
	GEL_TextOut(" LOOP BANDWIDTH: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,12,11));
	
	GEL_TextOut(" CLKBYP: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,14,13));
	
	GEL_TextOut(" STD: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SGMII_SERDES_CFGPLL,15,15));
}
	
	
TCI6614_sgmii_serdes_rx_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	//CFGRX
	
	GEL_TextOut(" ********************************** TCI6614 SGMII SERDES%d RX CONFIGURATION ******************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_SGMII_SERDES_CFGRX%d ---> %x \n\n",,,,,serdes_no,(unsigned int)BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),31,0));
	
	reg_field = BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SGMII SERDES ENRX ---> Receiver is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" SGMII SERDES ENRX ---> Receiver is ##ENABLED##\n");
	}
	
	GEL_TextOut(" BUSWIDTH : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),3,1));
	
	GEL_TextOut(" RATE : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),5,4));
	
	GEL_TextOut(" INVPAIR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),6,6));
	
	GEL_TextOut(" TERM : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),9,7));
	
	GEL_TextOut(" ALIGN : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),11,10));
	
	GEL_TextOut(" LOS : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),14,12));
	
	GEL_TextOut(" CDR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),17,15));
	
	GEL_TextOut(" EQ : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),21,18));
	
	GEL_TextOut(" ENOC : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),22,22));
	
	GEL_TextOut(" LOOPBACK : %d\n\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGRX0+(serdes_no*8)),24,23));
}
	
	
	
TCI6614_sgmii_serdes_tx_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	//CFGTX
	
	GEL_TextOut(" ********************************** TCI6614 SGMII SERDES%d TX CONFIGURATION ******************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_SGMII_SERDES_CFGTX%d ---> %x \n\n",,,,,serdes_no,(unsigned int)BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),31,0));
	
	reg_field = BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SGMII SERDES ENTX ---> Transmitter is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" SGMII SERDES ENTX ---> Transmitter is ##ENABLED##\n");
	}
	
	GEL_TextOut(" BUSWIDTH : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),3,1));
	
	GEL_TextOut(" RATE : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),5,4));
	
	GEL_TextOut(" INVPAIR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),6,6));
	
	GEL_TextOut(" CM : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),7,7));
	
	GEL_TextOut(" SWING : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),11,8));
	
	GEL_TextOut(" DEEMPHASIS : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),15,12));
	
	GEL_TextOut(" MSYNC : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),16,16));
	
	GEL_TextOut(" ENIDL : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),17,17));
	
	GEL_TextOut(" RDTCT : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),19,18));
	
	GEL_TextOut(" LOOPBACK : %d\n\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SGMII_SERDES_CFGTX0+(serdes_no*8)),21,20));

}



TCI6614_srio_serdes_pll_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	GEL_TextOut(" ********************************** TCI6614 SRIO SERDES %d PLL CONFIGURATION *******************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_SRIO_SERDES_CFGPLL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_CFGPLL,31,0));
	
	//CFGPLL
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_CFGPLL,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SRIO SERDES ENPLL ---> PLL is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" SRIO SERDES ENPLL ---> PLL is ##ENABLED##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_CFGPLL,8,1);
	
	if(reg_field == 0x10)
	{
		GEL_TextOut(" MPY[8:1] => 4x PLL Multiply factor\n");
	}
	else if(reg_field == 0x14)
	{
		GEL_TextOut(" MPY[8:1] => 5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x18)
	{
		GEL_TextOut(" MPY[8:1] => 6x PLL Multiply factor\n");
	}
	else if(reg_field == 0x20)
	{
		GEL_TextOut(" MPY[8:1] => 8x PLL Multiply factor\n");
	}
	else if(reg_field == 0x21)
	{
		GEL_TextOut(" MPY[8:1] => 8.25x PLL Multiply factor\n");
	}
	else if(reg_field == 0x28)
	{
		GEL_TextOut(" MPY[8:1] => 10x PLL Multiply factor\n");
	}
	else if(reg_field == 0x30)
	{
		GEL_TextOut(" MPY[8:1] => 12x PLL Multiply factor\n");
	}
	else if(reg_field == 0x32)
	{
		GEL_TextOut(" MPY[8:1] => 12.5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x3C)
	{
		GEL_TextOut(" MPY[8:1] => 15x PLL Multiply factor\n");
	}
	else if(reg_field == 0x40)
	{
		GEL_TextOut(" MPY[8:1] => 16x PLL Multiply factor\n");
	}
	else if(reg_field == 0x42)
	{
		GEL_TextOut(" MPY[8:1] => 16.5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x50)
	{
		GEL_TextOut(" MPY[8:1] => 20x PLL Multiply factor\n");
	}
	else if(reg_field == 0x58)
	{
		GEL_TextOut(" MPY[8:1] => 22x PLL Multiply factor\n");
	}
	else if(reg_field == 0x64)
	{
		GEL_TextOut(" MPY[8:1] => 25x PLL Multiply factor\n");
	}
	else
	{
		GEL_TextOut(" MPY[8:1] => Reserved\n");
	}
	
	GEL_TextOut(" VRANGE: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_CFGPLL,9,9));
	
	GEL_TextOut(" SLEEPPLL: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_CFGPLL,10,10));
	
	GEL_TextOut(" LOOP BANDWIDTH: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_CFGPLL,12,11));
	
	GEL_TextOut(" CLKBYP: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_SRIO_SERDES_CFGPLL,14,13));
}
	
	
TCI6614_srio_serdes_rx_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	GEL_TextOut(" ********************************** TCI6614 SRIO SERDES %d RX CONFIGURATION *******************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_SRIO_SERDES_CFGRX%d ---> %x \n\n",,,,,serdes_no,(unsigned int)BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),31,0));
	
	//CFGRX
	
	reg_field = BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SRIO SERDES ENRX ---> Receiver is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" SRIO SERDES ENRX ---> Receiver is ##ENABLED##\n");
	}
	
	GEL_TextOut(" BUSWIDTH : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),3,1));
	
	GEL_TextOut(" RATE : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),5,4));
	
	GEL_TextOut(" INVPAIR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),6,6));
	
	GEL_TextOut(" TERM : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),9,7));
	
	GEL_TextOut(" ALIGN : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),11,10));
	
	GEL_TextOut(" LOS : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),14,12));
	
	GEL_TextOut(" CDR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),17,15));
	
	GEL_TextOut(" EQ : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),20,18));
	
	GEL_TextOut(" EQHLD : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),21,21));
	
	GEL_TextOut(" ENOC : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),22,22));
	
	GEL_TextOut(" LOOPBACK : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),24,23));
	
	GEL_TextOut(" TEST PATTERN : %d\n\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGRX0+(serdes_no*8)),27,25));
}
	
	
TCI6614_srio_serdes_tx_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	GEL_TextOut(" ********************************** TCI6614 SRIO SERDES %d TX CONFIGURATION *******************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_SRIO_SERDES_CFGTX%d ---> %x \n\n",,,,,serdes_no,(unsigned int)BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),31,0));
	
	//CFGTX
	
	reg_field = BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SRIO SERDES ENTX ---> Transmitter is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" SRIO SERDES ENTX ---> Transmitter is ##ENABLED##\n");
	}
	
	GEL_TextOut(" BUSWIDTH : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),3,1));
	
	GEL_TextOut(" RATE : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),5,4));
	
	GEL_TextOut(" INVPAIR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),6,6));
	
	GEL_TextOut(" SWING : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),10,7));
	
	GEL_TextOut(" TWPRE : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),13,11));
	
	GEL_TextOut(" TWPST1 : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),18,14));
	
	GEL_TextOut(" FIRUPT : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),19,19));
	
	GEL_TextOut(" MSYNC : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),20,20));
	
	GEL_TextOut(" LOOPBACK : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),22,21));
	
	GEL_TextOut(" TEST PATTERN : %d\n\n",,,,,BB_REG_FIELD_READ((BOOTCFG_SRIO_SERDES_CFGTX0+(serdes_no*8)),25,23));

}


TCI6614_hyperbridge_serdes_pll_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES%d PLL CONFIGURATION ************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL,31,0));
	
	//CFGPLL
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" HYPERBRIDGE SERDES ENPLL ---> PLL is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" HYPERBRIDGE SERDES ENPLL ---> PLL is ##ENABLED##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL,8,1);
	
	if(reg_field == 0x10)
	{
		GEL_TextOut(" MPY[8:1] => 4x PLL Multiply factor\n");
	}
	else if(reg_field == 0x14)
	{
		GEL_TextOut(" MPY[8:1] => 5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x18)
	{
		GEL_TextOut(" MPY[8:1] => 6x PLL Multiply factor\n");
	}
	else if(reg_field == 0x20)
	{
		GEL_TextOut(" MPY[8:1] => 8x PLL Multiply factor\n");
	}
	else if(reg_field == 0x21)
	{
		GEL_TextOut(" MPY[8:1] => 8.25x PLL Multiply factor\n");
	}
	else if(reg_field == 0x28)
	{
		GEL_TextOut(" MPY[8:1] => 10x PLL Multiply factor\n");
	}
	else if(reg_field == 0x30)
	{
		GEL_TextOut(" MPY[8:1] => 12x PLL Multiply factor\n");
	}
	else if(reg_field == 0x32)
	{
		GEL_TextOut(" MPY[8:1] => 12.5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x3C)
	{
		GEL_TextOut(" MPY[8:1] => 15x PLL Multiply factor\n");
	}
	else if(reg_field == 0x40)
	{
		GEL_TextOut(" MPY[8:1] => 16x PLL Multiply factor\n");
	}
	else if(reg_field == 0x42)
	{
		GEL_TextOut(" MPY[8:1] => 16.5x PLL Multiply factor\n");
	}
	else if(reg_field == 0x50)
	{
		GEL_TextOut(" MPY[8:1] => 20x PLL Multiply factor\n");
	}
	else if(reg_field == 0x58)
	{
		GEL_TextOut(" MPY[8:1] => 22x PLL Multiply factor\n");
	}
	else if(reg_field == 0x64)
	{
		GEL_TextOut(" MPY[8:1] => 25x PLL Multiply factor\n");
	}
	else
	{
		GEL_TextOut(" MPY[8:1] => Reserved\n");
	}
	
	GEL_TextOut(" VRANGE: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL,9,9));
	
	GEL_TextOut(" SLEEPPLL: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL,10,10));
	
	GEL_TextOut(" LOOP BANDWIDTH: %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL,12,11));
	
	GEL_TextOut(" CLKBYP: %d\n\n",,,,,BB_REG_FIELD_READ(BOOTCFG_HYPERBRIDGE_SERDES_CFGPLL,14,13));
}
	
	
TCI6614_hyperbridge_serdes_rx_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES%d RX CONFIGURATION ************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_HYPERBRIDGE_SERDES_CFGRX%d ---> %x \n\n",,,,,serdes_no,(unsigned int)BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),31,0));
	
	//CFGRX
	
	reg_field = BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" HYPERBRIDGE SERDES ENRX ---> Receiver is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" HYPERBRIDGE SERDES ENRX ---> Receiver is ##ENABLED##\n");
	}
	
	GEL_TextOut(" BUSWIDTH : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),3,1));
	
	GEL_TextOut(" RATE : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),5,4));
	
	GEL_TextOut(" INVPAIR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),6,6));
	
	GEL_TextOut(" TERM : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),9,7));
	
	GEL_TextOut(" ALIGN : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),11,10));
	
	GEL_TextOut(" LOS : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),14,12));
	
	GEL_TextOut(" CDR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),17,15));
	
	GEL_TextOut(" EQ : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),20,18));
	
	GEL_TextOut(" EQHLD : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),21,21));
	
	GEL_TextOut(" ENOC : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),22,22));
	
	GEL_TextOut(" LOOPBACK : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),24,23));
	
	GEL_TextOut(" TEST PATTERN : %d\n\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGRX0+(serdes_no*8)),27,25));
}
	
	
TCI6614_hyperbridge_serdes_tx_config(unsigned int serdes_no)
{
	unsigned int reg_field;
	
	GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES%d TX CONFIGURATION ************************\n\n",,,,,serdes_no);
	
	GEL_TextOut(" BOOTCFG_HYPERBRIDGE_SERDES_CFGTX%d ---> %x \n\n",,,,,serdes_no,(unsigned int)BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),31,0));
	
	//CFGTX
	
	reg_field = BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" HYPERBRIDGE SERDES ENTX ---> Transmitter is **DISABLED**\n");
	}
	else
	{
		GEL_TextOut(" HYPERBRIDGE SERDES ENTX ---> Transmitter is ##ENABLED##\n");
	}
	
	GEL_TextOut(" BUSWIDTH : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),3,1));
	
	GEL_TextOut(" RATE : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),5,4));
	
	GEL_TextOut(" INVPAIR : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),6,6));
	
	GEL_TextOut(" SWING : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),10,7));
	
	GEL_TextOut(" TWPRE : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),13,11));
	
	GEL_TextOut(" TWPST1 : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),18,14));
	
	GEL_TextOut(" FIRUPT : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),19,19));
	
	GEL_TextOut(" MSYNC : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),20,20));
	
	GEL_TextOut(" LOOPBACK : %d\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),22,21));
	
	GEL_TextOut(" TEST PATTERN : %d\n\n",,,,,BB_REG_FIELD_READ((BOOTCFG_HYPERBRIDGE_SERDES_CFGTX0+(serdes_no*8)),25,23));

}

TCI6614_mainpll_config()
{
	unsigned int reg_field, reg_field1;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 MAIN PLL CONFIGURATION ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");
	
	GEL_TextOut(" BOOTCFG_MAINPLLCTL0 ---> %x \n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,31,0));
	GEL_TextOut(" BOOTCFG_MAINPLLCTL1 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL1,31,0));
	
	GEL_TextOut(" PLLD : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,5,0));

	GEL_TextOut(" PLLM[12:6] : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,18,12));

	GEL_TextOut(" BYPASS : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,23,23));
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,31,24);
	
	GEL_TextOut(" BWADJ[7:0] : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL0,31,24));
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL1,3,0);
	GEL_TextOut(" BWADJ[11:8] : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_MAINPLLCTL1,3,0));
}


TCI6614_ddrpll_config()
{
	unsigned int reg_field, reg_field1;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 DDR PLL CONFIGURATION ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");
	
	GEL_TextOut(" BOOTCFG_DDR3PLLCTL0 ---> %x \n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_DDR3PLLCTL0,31,0));	
	GEL_TextOut(" BOOTCFG_DDR3PLLCTL1 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_DDR3PLLCTL1,31,0));

	GEL_TextOut(" PLLD : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_DDR3PLLCTL0,5,0));
	
	GEL_TextOut(" PLLM : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_DDR3PLLCTL0,18,12));
	
	GEL_TextOut(" BYPASS : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_DDR3PLLCTL0,23,23));
}


TCI6614_papll_config()
{
	unsigned int reg_field, reg_field1;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 PA PLL CONFIGURATION ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");
	
	GEL_TextOut(" BOOTCFG_PAPLLCTL0 ---> %x \n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,31,0));
	GEL_TextOut(" BOOTCFG_PAPLLCTL1 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL1,31,0));
	
	GEL_TextOut(" PLLD : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,5,0));
	
	GEL_TextOut(" PLLM : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,18,12));
	
	GEL_TextOut(" BYPASS : %d\n",,,,,BB_REG_FIELD_READ(BOOTCFG_PAPLLCTL0,23,23));
}

TCI6614_bootstrap_configuration()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 BOOTSTRAP CONFIGURATION ******************************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_device_status();
	
	//TCI6614 Device Configuration
	
	reg_field = BB_REG_FIELD_READ(BOOTCFG_DEVCFG,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SYSCLKOUTEN[0] ---> No Clock Output\n\n");
	}
	else
	{
		GEL_TextOut(" SYSCLKOUTEN[0] ---> Clock output Enabled (default)\n\n");
	}
	
	TCI6614_getDIEID();
	
	TCI6614_getMACID();
}


#define DDR3EMIF_MIDR                              (0x21000000)
#define DDR3EMIF_DMCSTAT                           (0x21000004)
#define DDR3EMIF_SDCFG                             (0x21000008)
#define DDR3EMIF_SDRFC                             (0x21000010)
#define DDR3EMIF_SDTIM1                            (0x21000018)
#define DDR3EMIF_SDTIM2                            (0x21000020)
#define DDR3EMIF_SDTIM3                            (0x21000028)
#define DDR3EMIF_PMCTL                             (0x21000038)
#define DDR3EMIF_LAT_CONFIG                        (0x21000054)
#define DDR3EMIF_IRQSTATUS_RAW_SYS                 (0x210000A4)
#define DDR3EMIF_IRQ_STATUS_SYS                    (0x210000AC)
#define DDR3EMIF_IRQENABLE_SET_SYS                 (0x210000B4)
#define DDR3EMIF_IRQENABLE_CLR_SYS                 (0x210000BC)
#define DDR3EMIF_ZQCONFIG                          (0x210000C8)
#define DDR3EMIF_RDWR_LVL_RMP_WIN                  (0x210000D4)
#define DDR3EMIF_RDWR_LVL_RMP_CTRL                 (0x210000D8)
#define DDR3EMIF_RDWR_LVL_CTRL                     (0x210000DC)
#define DDR3EMIF_DDR_PHY_CTRL_1                    (0x210000E4)
#define DDR3EMIF_READ_IDLE_CTRL                    (0x21000098)
#define DDR3EMIF_PRICOSMAP                         (0x21000100)
#define DDR3EMIF_MIDCOSMAP1                        (0x21000104)
#define DDR3EMIF_MIDCOSMAP2                        (0x21000108)
#define DDR3EMIF_ECCCTL                            (0x21000110)
#define DDR3EMIF_ECCADDR1                          (0x21000114)
#define DDR3EMIF_ECCADDR2                          (0x21000118)
#define DDR3EMIF_RWTHRESH                          (0x21000120)


SDRAM_Configuration_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** SDRAM Configuration Register (SDCFG) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_SDCFG ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_SDCFG,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,2,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PAGESIZE[2:0] ---> 256-word page requiring 8 column address bits\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PAGESIZE[2:0] ---> 512-word page requiring 8 column address bits\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PAGESIZE[2:0] ---> 1024-word page requiring 8 column address bits\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PAGESIZE[2:0] ---> 22048-word page requiring 8 column address bits\n");
	}
	else
	{
		GEL_TextOut(" PAGESIZE[2:0] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,3,3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" EBANK[3] ---> Use DCE0# for all SDRAM accesses\n");
	}
	else
	{
		GEL_TextOut(" EBANK[3] ---> Use DEC0# and DCE1# for SDRAM accesses\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,6,4);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" IBANK[6:4] ---> One bank SDRAM devices\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" IBANK[6:4] ---> Two bank SDRAM devices\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" IBANK[6:4] ---> Four bank SDRAM devices\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" IBANK[6:4] ---> Eight bank SDRAM devices\n");
	}
	else
	{
		GEL_TextOut(" IBANK[6:4] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,9,7);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ROWSIZE[9:7] ---> 9 row bits\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" ROWSIZE[9:7] ---> 10 row bits\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" ROWSIZE[9:7] ---> 11 row bits\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" ROWSIZE[9:7] ---> 12 row bits\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" ROWSIZE[9:7] ---> 13 row bits\n");
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" ROWSIZE[9:7] ---> 14 row bits\n");
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" ROWSIZE[9:7] ---> 15 row bits\n");
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" ROWSIZE[9:7] ---> 16 row bits\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,13,10);
	
	if(reg_field == 2)
	{
		GEL_TextOut(" CL[13:10] ---> CAS latency of 5\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" CL[13:10] ---> CAS latency of 6\n");
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" CL[13:10] ---> CAS latency of 7\n");
	}
	else if(reg_field == 8)
	{
		GEL_TextOut(" CL[13:10] ---> CAS latency of 8\n");
	}
	else if(reg_field == 10)
	{
		GEL_TextOut(" CL[13:10] ---> CAS latency of 9\n");
	}
	else if(reg_field == 12)
	{
		GEL_TextOut(" CL[13:10] ---> CAS latency of 10\n");
	}
	else if(reg_field == 14)
	{
		GEL_TextOut(" CL[13:10] ---> CAS latency of 11\n");
	}
	else
	{
		GEL_TextOut(" CL[13:10] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,15,14);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" NM[15:14] ---> 64-bit bus width\n");
	}
	else if(reg_field == 0)
	{
		GEL_TextOut(" NM[15:14] ---> 32-bit bus width\n");
	}
	else if(reg_field == 0)
	{
		GEL_TextOut(" NM[15:14] ---> 16-bit bus width\n");
	}
	else
	{
		GEL_TextOut(" NM[15:14] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,17,16);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" CWL[17:16] ---> CAS write latency of 5\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" CWL[17:16] ---> CAS write latency of 6\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" CWL[17:16] ---> CAS write latency of 7\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" CWL[17:16] ---> CAS write latency of 8\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,19,18);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SDRAM_DRIVE[19:18] ---> RZQ/6\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" SDRAM_DRIVE[19:18] ---> RZQ/7\n");
	}
	else
	{
		GEL_TextOut(" SDRAM_DRIVE[19:18] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,20,20);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" DDR_DISABLE_DLL[20] ---> Normal Operation\n");
	}
	else
	{
		GEL_TextOut(" DDR_DISABLE_DLL[20] ---> Disables DLL inside SDRAM\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,22,21);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" DYN_ODT[22:21] ---> Turn off dynamic ODT\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" DYN_ODT[22:21] ---> RZQ/4\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" DYN_ODT[22:21] ---> RZQ/2\n");
	}
	else
	{
		GEL_TextOut(" DYN_ODT[22:21] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDCFG,26,24);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" DDR_TERM[26:24] ---> Disables termination\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" DDR_TERM[26:24] ---> RZQ/4\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" DDR_TERM[26:24] ---> RZQ/2\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" DDR_TERM[26:24] ---> RZQ/6\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" DDR_TERM[26:24] ---> RZQ/12\n");
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" DDR_TERM[26:24] ---> RZQ/8\n");
	}
	else
	{
		GEL_TextOut(" DDR_TERM[26:24] ---> Reserved\n");
	}
	
	GEL_TextOut(" IBANK_POS[28:27] ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_SDCFG,28,27));
	
	GEL_TextOut(" SDRAM_TYPE[31:29] ---> DDR%d\n\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_SDCFG,31,29));
}

SDRAM_Refresh_Control_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** SDRAM Refresh Control Register (SDRFC) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_SDRFC ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_SDRFC,31,0));
	
	GEL_TextOut(" REFRESH_RATE[15:0] ---> %d (REFRESH_RATE = Refresh period * DDR3 clock frequency.)\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_SDRFC,15,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDRFC,26,24);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PASR[26:24](Partial Array self-refresh) ---> Full-array\n");
	}
	else if((reg_field == 1) || (reg_field == 5))
	{
		GEL_TextOut(" PASR[26:24](Partial Array self-refresh) ---> 1/2 array\n");
	}
	else if((reg_field == 2) || (reg_field == 6))
	{
		GEL_TextOut(" PASR[26:24](Partial Array self-refresh) ---> 1/4 array\n");
	}
	else if((reg_field == 3) || (reg_field == 7))
	{
		GEL_TextOut(" PASR[26:24](Partial Array self-refresh) ---> 1/8 array\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" PASR[26:24](Partial Array self-refresh) ---> 3/4 array\n");
	}
	else
	{
		GEL_TextOut(" PASR[26:24](Partial Array self-refresh) ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDRFC,28,28);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ASR[28] ---> Manual self-refresh\n");
	}
	else
	{
		GEL_TextOut(" ASR[28] ---> Auto self-refresh enable\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDRFC,29,29);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SRT[29] ---> Normal operating temperature range. This must be set to zero ASR bit is set to 1\n");
	}
	else
	{
		GEL_TextOut(" SRT[29] ---> NExtended operating temperature range when ASR bit is set to zero\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_SDRFC,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" INITREF_DIS[29] ---> Normal operation\n\n");
	}
	else
	{
		GEL_TextOut(" INITREF_DIS[29] ---> Disables SDRAM initialization and refreshes, but carries out SDRAM write/read transactions\n\n");
	}
}

Power_Management_Control_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Power Management Control Register (PMCTL) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_PMCTL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_PMCTL,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PMCTL,3,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Immediately enter clock-stop\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 16 clocks\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 32 clocks\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 64 clocks\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 128 clocks\n");
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 256 clocks\n");
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 512 clocks\n");
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 1024 clocks\n");
	}
	else if(reg_field == 8)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 2048 clocks\n");
	}
	else if(reg_field == 9)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 4096 clocks\n");
	}
	else if(reg_field == 10)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 8192 clocks\n");
	}
	else if(reg_field == 11)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 16384 clocks\n");
	}
	else if(reg_field == 12)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 32768 clocks\n");
	}
	else if(reg_field == 13)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 65536 clocks\n");
	}
	else if(reg_field == 14)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 131072 clocks\n");
	}
	else if(reg_field == 15)
	{
		GEL_TextOut(" CS_TIM(Power management timer for clock stop mode) ---> Enter clock-stop after 262144 clocks\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PMCTL,7,4);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Immediately enter self-refresh\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 16 clocks\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 32 clocks\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 64 clocks\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 128 clocks\n");
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 256 clocks\n");
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 512 clocks\n");
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 1024 clocks\n");
	}
	else if(reg_field == 8)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 2048 clocks\n");
	}
	else if(reg_field == 9)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 4096 clocks\n");
	}
	else if(reg_field == 10)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 8192 clocks\n");
	}
	else if(reg_field == 11)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 16384 clocks\n");
	}
	else if(reg_field == 12)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 32768 clocks\n");
	}
	else if(reg_field == 13)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 65536 clocks\n");
	}
	else if(reg_field == 14)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 131072 clocks\n");
	}
	else if(reg_field == 15)
	{
		GEL_TextOut(" SR_TIM(Power management timer for self-refresh) ---> Enter self-refresh after 262144 clocks\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PMCTL,10,8);
	
	if(reg_field == 1)
	{
		GEL_TextOut(" LP_MODE[10:8] ---> Clock-stop mode\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" LP_MODE[10:8] ---> Self-refresh mode\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" LP_MODE[10:8] ---> Power-down mode\n");
	}
	else
	{
		GEL_TextOut(" LP_MODE[10:8] ---> disable automatic power management\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PMCTL,15,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Immediately enter power-down\n\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 16 clocks\n\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 32 clocks\n\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 64 clocks\n\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 128 clocks\n\n");
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 256 clocks\n\n");
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 512 clocks\n\n");
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 1024 clocks\n\n");
	}
	else if(reg_field == 8)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 2048 clocks\n\n");
	}
	else if(reg_field == 9)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 4096 clocks\n\n");
	}
	else if(reg_field == 10)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 8192 clocks\n\n");
	}
	else if(reg_field == 11)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 16384 clocks\n\n");
	}
	else if(reg_field == 12)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 32768 clocks\n\n");
	}
	else if(reg_field == 13)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 65536 clocks\n\n");
	}
	else if(reg_field == 14)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 131072 clocks\n\n");
	}
	else if(reg_field == 15)
	{
		GEL_TextOut(" PD_TIM(Power Management timer for power-down) ---> Enter power-down after 262144 clocks\n\n");
	}
}

Latency_Configuration_Register()
{
	GEL_TextOut(" *************************** Latency Configuration Register (LAT_CONFIG) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_LAT_CONFIG ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_LAT_CONFIG,31,0));
	
	GEL_TextOut(" PR_OLD_COUNT[7:0] ---> %d (Num of clk cycles = PR_OLD_COUNT x 16 clks)\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_LAT_CONFIG,7,0));
	
	GEL_TextOut(" COS_COUNT_2[15:8] ---> %d (Num of clk cycles = COS_COUNT_2 x 16 clks)\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_LAT_CONFIG,15,8));
	
	GEL_TextOut(" COS_COUNT_1[23:16] ---> %d (Num of clk cycles = COS_COUNT_1 x 16 clks)\n\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_LAT_CONFIG,23,16));
}


SDRAM_Output_Impedance_Calibration_Configuration_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** SDRAM Output Impedance Calibration Configuration Register (ZQCFG) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_ZQCONFIG ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_ZQCONFIG,31,0));
	
	GEL_TextOut(" ZQ_REFINTERVAL[15:0] ---> %d (Number of refresh periods between ZQCS commands)\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_ZQCONFIG,15,0));
	
	GEL_TextOut(" ZQ_ZQCL_MULT[17:16] ---> %d (Number of ZQCS intervals that make up a ZACL interval(-1))\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_ZQCONFIG,17,16));
	
	GEL_TextOut(" ZQ_ZQINIT_MULT[19:18] ---> %d (Number of ZQCL intervals that make up a ZQINIT interval(-1))\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_ZQCONFIG,19,18));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_ZQCONFIG,28,28);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ZQ_SFEXITEN[28] ---> Disable ZQCL on Self-refresh, Active power-down and precharge power-down exit enable\n");
	}
	else
	{
		GEL_TextOut(" ZQ_SFEXITEN[28] ---> Enable ZQCL on Self-refresh, Active power-down and precharge power-down exit enable\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_ZQCONFIG,29,29);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ZQ_DUALCALEN[29] ---> Dual ZQ calibration disable\n");
	}
	else
	{
		GEL_TextOut(" ZQ_DUALCALEN[29] ---> Both chip selects have a separate calibration resistor per device\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_ZQCONFIG,30,30);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ZQ_CS0EN[30] ---> Disable ZQ calibration for CS0\n");
	}
	else
	{
		GEL_TextOut(" ZQ_CS0EN[30] ---> Enable ZQ calibration for CS0\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_ZQCONFIG,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ZQ_CS1EN[31] ---> Disable ZQ calibration for CS1\n\n");
	}
	else
	{
		GEL_TextOut(" ZQ_CS1EN[31] ---> Enable ZQ calibration for CS1\n\n");
	}
}


Read_Write_Leveling_Ramp_Window_Register()
{
	GEL_TextOut(" *************************** Read-Write Leveling Ramp Window Register (RDWR_LVL_RMP_WIN) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_RDWR_LVL_RMP_WIN ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_RMP_WIN,31,0));
	
	GEL_TextOut(" Incremental leveling ramp window in number of refresh periods(RDWRLVLINC_RMP_WIN) ---> %d\n\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_RMP_WIN,12,0));
}

Read_Write_Leveling_Ramp_Control_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Read-Write Leveling Ramp Control Register (RDWR_LVL_RMP_CTRL) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_RDWR_LVL_RMP_CTRL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_RMP_CTRL,31,0));
	
	GEL_TextOut(" Number of RDWRLVLINC_RMP_PRE intervals between incremental write leveling(WRLVLINC_RMP_INT) ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_RMP_CTRL,7,0));
	
	GEL_TextOut(" Number of RDWRLVLINC_RMP_PRE intervals between incremental read DQS gate training(RDLVLGATEINC_RMP_INT) ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_RMP_CTRL,15,8));
	
	GEL_TextOut(" Number of RDWRLVLINC_RMP_PRE intervals between incremental read data eye training(RDLVLINC_RMP_INT) ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_RMP_CTRL,23,16));
	
	GEL_TextOut(" Incremental leveling pre-scalar in number of refresh periods during ramp window(RDWRLVLINC_RMP_PRE) ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_RMP_CTRL,30,24));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_RMP_CTRL,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" RDWR_LVL_EN[31] ---> Disable leveling\n\n");
	}
	else
	{
		GEL_TextOut(" RDWR_LVL_EN[31] ---> Enable leveling\n\n");
	}
}

Read_Write_Leveling_Control_Register()
{

	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Read-Write Leveling Control Register (RDWR_LVL_CTRL) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_RDWR_LVL_CTRL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_CTRL,31,0));
	
	GEL_TextOut(" Number of RDWRLVLINC_PRE intervals between incremental write leveling(WRLVLINC_INT) ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_CTRL,7,0));
	
	GEL_TextOut(" Number of RDWRLVLINC_PRE intervals between incremental read DQS gate training(RDLVLGATEINC_INT) ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_CTRL,15,8));
	
	GEL_TextOut(" Number of RDWRLVLINC_PRE intervals between incremental read data eye training(RDLVLINC_INT) ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_CTRL,23,16));
	
	GEL_TextOut(" Incremental leveling pre-scalar in number of refresh periods during ramp window(RDWRLVLINC_PRE) ---> %d\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_CTRL,30,24));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_RDWR_LVL_CTRL,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" RDWR_LVL_EN[31] ---> Disable leveling\n\n");
	}
	else
	{
		GEL_TextOut(" RDWR_LVL_EN[31] ---> Enable leveling\n\n");
	}
}

DDR_PHY_Control_1_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** DDR PHY Control 1 Register (DDR_PHY_CTRL_1) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_DDR_PHY_CTRL_1 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_DDR_PHY_CTRL_1,31,0));
	
	GEL_TextOut(" READ_LATENCY[4:0] ---> %d (Max val possible = CAS latency + 7; Min val possible = CAS Latency + 1)\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_DDR_PHY_CTRL_1,4,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_DDR_PHY_CTRL_1,20,20);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" EN_DYN_PWRDN[20] ---> IO Receiver for DQ, DQS powered up during a read\n\n");
	}
	else
	{
		GEL_TextOut(" EN_DYN_PWRDN[20] ---> IO Receiver for DQ, DQS always powered up\n\n");
	}
}

Read_Idle_Control_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Read Idle Control Register (READ_IDLE_CTRL) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_READ_IDLE_CTRL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_READ_IDLE_CTRL,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_READ_IDLE_CTRL,8,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" READ_IDLE_INTERVAL[8:0] ---> disables read idle function\n");
	}
	else
	{
		GEL_TextOut(" READ_IDLE_INTERVAL[8:0] ---> %d ((READ_IDLE_INTERVAL  1) * 64 DDR3 clock cycles)\n",,,,,reg_field);
	}
	
	GEL_TextOut(" READ_IDLE_LEN[19:16] ---> %d (minimum length of read idle window)\n\n",,,,,BB_REG_FIELD_READ(DDR3EMIF_READ_IDLE_CTRL,19,16));
}


Priority_to_Class_Of_Service_Mapping_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Priority to Class-Of-Service Mapping Register (PRICOSMAP) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_PRICOSMAP ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_0_COS[1:0] ---> Map to Class-of-service 1\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PRI_0_COS[1:0] ---> Map to Class-of-service 2\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PRI_0_COS[1:0] ---> Map to Class-of-service 3\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PRI_0_COS[1:0] ---> Map to Class-of-service 3\n");
	} 
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,3,2);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_1_COS[3:2] ---> Map to Class-of-service 1\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PRI_1_COS[3:2] ---> Map to Class-of-service 2\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PRI_1_COS[3:2] ---> Map to Class-of-service 3\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PRI_1_COS[3:2] ---> Map to Class-of-service 3\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,5,4);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_2_COS[5:4] ---> Map to Class-of-service 1\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PRI_2_COS[5:4] ---> Map to Class-of-service 2\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PRI_2_COS[5:4] ---> Map to Class-of-service 3\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PRI_2_COS[5:4] ---> Map to Class-of-service 3\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,7,6);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_3_COS[7:6] ---> Map to Class-of-service 1\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PRI_3_COS[7:6] ---> Map to Class-of-service 2\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PRI_3_COS[7:6] ---> Map to Class-of-service 3\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PRI_3_COS[7:6] ---> Map to Class-of-service 3\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,9,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_4_COS[9:8] ---> Map to Class-of-service 1\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PRI_4_COS[9:8] ---> Map to Class-of-service 2\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PRI_4_COS[9:8] ---> Map to Class-of-service 3\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PRI_4_COS[9:8] ---> Map to Class-of-service 3\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,11,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_5_COS[11:10] ---> Map to Class-of-service 1\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PRI_5_COS[11:10] ---> Map to Class-of-service 2\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PRI_5_COS[11:10] ---> Map to Class-of-service 3\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PRI_5_COS[11:10] ---> Map to Class-of-service 3\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,13,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_6_COS[13:12] ---> Map to Class-of-service 1\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PRI_6_COS[13:12] ---> Map to Class-of-service 2\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PRI_6_COS[13:12] ---> Map to Class-of-service 3\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PRI_6_COS[13:12] ---> Map to Class-of-service 3\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,15,14);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_7_COS[15:14] ---> Map to Class-of-service 1\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" PRI_7_COS[15:14] ---> Map to Class-of-service 2\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" PRI_7_COS[15:14] ---> Map to Class-of-service 3\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" PRI_7_COS[15:14] ---> Map to Class-of-service 3\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_PRICOSMAP,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PRI_COS_MAP_EN[31] ---> Disable Priority to Class-of-service mapping\n\n");
	}
	else
	{
		GEL_TextOut(" PRI_COS_MAP_EN[31] ---> Enable Priority to Class-of-service mapping\n\n");
	}
}


Master_ID_to_Class_Of_Service_1_Mapping_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Master ID to Class-Of-Service 1 Mapping Register (MIDCOS1MAP) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_MIDCOSMAP1 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP1,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP1,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSK_3_COS_1[1:0] ---> Disable masking\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" MSK_3_COS_1[1:0] ---> Mask master ID bit 0\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" MSK_3_COS_1[1:0] ---> Mask master ID bits 1-0\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" MSK_3_COS_1[1:0] ---> Mask master ID bits 2-0\n");
	}
	
	GEL_TextOut(" Master ID value 3 for Class-of-service 1(MSTID_3_COS_1) ---> %x\n",,,,,(unsigned char)BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP1,9,2));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP1,11,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSK_2_COS_1[11:10] ---> Disable masking\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" MSK_2_COS_1[11:10] ---> Mask master ID bit 0\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" MSK_2_COS_1[11:10] ---> Mask master ID bits 1-0\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" MSK_2_COS_1[11:10] ---> Mask master ID bits 2-0\n");
	}
	
	GEL_TextOut(" Master ID value 2 for Class-of-service 1(MSTID_2_COS_1) ---> %x\n",,,,,(unsigned char)BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP1,19,12));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP1,21,20);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSK_1_COS_1[21:20] ---> Disable masking\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" MSK_1_COS_1[21:20] ---> Mask master ID bit 0\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" MSK_1_COS_1[21:20] ---> Mask master ID bits 1-0\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" MSK_1_COS_1[21:20] ---> Mask master ID bits 2-0\n");
	}
	
	GEL_TextOut(" Master ID value 1 for Class-of-service 1(MSTID_1_COS_1) ---> %x\n",,,,,(unsigned char)BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP1,29,22));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP1,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSTID_COS_1_MAP_EN[31] ---> Disable Master ID to Class-of-service 1 mapping\n\n");
	}
	else
	{
		GEL_TextOut(" MSTID_COS_1_MAP_EN[31] ---> Enable Master ID to Class-of-service 1 mapping\n\n");
	}
}

Master_ID_to_Class_Of_Service_2_Mapping_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Master ID to Class-Of-Service 2 Mapping Register (MIDCOS2MAP) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_MIDCOSMAP2 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP2,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP2,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSK_3_COS_2[1:0] ---> Disable masking\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" MSK_3_COS_2[1:0] ---> Mask master ID bit 0\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" MSK_3_COS_2[1:0] ---> Mask master ID bits 1-0\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" MSK_3_COS_2[1:0] ---> Mask master ID bits 2-0\n");
	}
	
	GEL_TextOut(" Master ID value 3 for Class-of-service 2(MSTID_3_COS_2) ---> %x\n",,,,,(unsigned char)BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP2,9,2));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP2,11,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSK_2_COS_2[11:10] ---> Disable masking\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" MSK_2_COS_2[11:10] ---> Mask master ID bit 0\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" MSK_2_COS_2[11:10] ---> Mask master ID bits 1-0\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" MSK_2_COS_2[11:10] ---> Mask master ID bits 2-0\n");
	}
	
	GEL_TextOut(" Master ID value 2 for Class-of-service 2(MSTID_2_COS_2) ---> %x\n",,,,,(unsigned char)BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP2,19,12));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP2,21,20);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSK_1_COS_2[21:20] ---> Disable masking\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" MSK_1_COS_2[21:20] ---> Mask master ID bit 0\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" MSK_1_COS_2[21:20] ---> Mask master ID bits 1-0\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" MSK_1_COS_2[21:20] ---> Mask master ID bits 2-0\n");
	}
	
	GEL_TextOut(" Master ID value 1 for Class-of-service 2(MSTID_1_COS_2) ---> %x\n",,,,,(unsigned char)BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP2,29,22));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_MIDCOSMAP2,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSTID_COS_2_MAP_EN[31] ---> Disable Master ID to Class-of-service 2 mapping\n\n");
	}
	else
	{
		GEL_TextOut(" MSTID_COS_2_MAP_EN[31] ---> Enable Master ID to Class-of-service 2 mapping\n\n");
	}
}

ECC_Control_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** ECC Control Register (ECCCTL) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_ECCCTL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_ECCCTL,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_ECCCTL,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ECC_ADDR_RNG_1_EN[0] ---> Disable ECC Address Range 1\n");
	}
	else
	{
		GEL_TextOut(" ECC_ADDR_RNG_1_EN[0] ---> Enable ECC Address Range 1\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_ECCCTL,1,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ECC_ADDR_RNG_2_EN[1] ---> Disable ECC Address Range 2\n");
	}
	else
	{
		GEL_TextOut(" ECC_ADDR_RNG_2_EN[1] ---> Enable ECC Address Range 2\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_ECCCTL,30,30);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ECC_ADDR_RNG_PROT[30] ---> Disable ECC calculation within address ranges defined in ECC Address Range 1 and 2 registers and enable\n");
        GEL_TextOut("                           calculation for accesses outside of these address ranges\n");
	}
	else
	{
		GEL_TextOut(" ECC_ADDR_RNG_PROT[30] ---> Enable ECC calculation within address ranges defined in ECC Address Range 1 and 2 registers and disable\n");
        GEL_TextOut("                           calculation for accesses outside of these address ranges\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_ECCCTL,31,31);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ECC_EN[31] ---> Disable ECC\n\n");
	}
	else
	{
		GEL_TextOut(" ECC_EN[31] ---> Enable ECC\n\n");
	}
}

ECC_Address_Range_1_Register()
{
	GEL_TextOut(" *************************** ECC Address Range 1 Register (ECCADDR1) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_ECCADDR1 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_ECCADDR1,31,0));
	
	GEL_TextOut(" ECC_STRT_ADDR_1[15:0] ---> %x\n",,,,,(unsigned short)BB_REG_FIELD_READ(DDR3EMIF_ECCADDR1,15,0));
	
	GEL_TextOut(" ECC_END_ADDR_1[31:16] ---> %x\n\n",,,,,(unsigned short)BB_REG_FIELD_READ(DDR3EMIF_ECCADDR1,31,16));
}

ECC_Address_Range_2_Register()
{
	GEL_TextOut(" *************************** ECC Address Range 2 Register (ECCADDR2) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_ECCADDR2 ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_ECCADDR2,31,0));
	
	GEL_TextOut(" ECC_STRT_ADDR_2[15:0] ---> %x\n",,,,,(unsigned short)BB_REG_FIELD_READ(DDR3EMIF_ECCADDR2,15,0));
	
	GEL_TextOut(" ECC_END_ADDR_2[31:16] ---> %x\n\n",,,,,(unsigned short)BB_REG_FIELD_READ(DDR3EMIF_ECCADDR2,31,16));
}

Read_Write_Execution_Threshold_Register()
{
	GEL_TextOut(" *************************** Read Write Execution Threshold Register (RWTHRESH) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_RWTHRESH ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_RWTHRESH,31,0));
	
	GEL_TextOut(" Number of SDRAM read bursts after which the arbitration will switch to executing write commands(RD_THRSH) ---> %d\n",,,,,(unsigned short)BB_REG_FIELD_READ(DDR3EMIF_RWTHRESH,4,0));
	
	GEL_TextOut(" Number of SDRAM write bursts after which the arbitration will switch to executing read commands(WR_THRSH) ---> %d\n\n",,,,,(unsigned short)BB_REG_FIELD_READ(DDR3EMIF_RWTHRESH,12,8));
}

DDR3_Memory_Controller_Status_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** DDR3 Memory Controller Status Register (DMCSTAT) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_DMCSTAT ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_DMCSTAT,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_DMCSTAT,2,2);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" IFRDY[2] ---> Interface logic is not ready; either powered down, not ready, or not locked\n");
	}
	else
	{
		GEL_TextOut(" IFRDY[2] ---> Interface logic is powered up, locked and ready for operation\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_DMCSTAT,4,4);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" WRLVLTO[4] ---> Reset value\n");
	}
	else
	{
		GEL_TextOut(" WRLVLTO[4] ---> Write Leveling has timed out\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_DMCSTAT,5,5);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" RDLVLTO[5] ---> Reset value\n");
	}
	else
	{
		GEL_TextOut(" RDLVLTO[5] ---> Read data eye training has timed out\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_DMCSTAT,6,6);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" RDLVGATETO[6] ---> Reset value\n\n");
	}
	else
	{
		GEL_TextOut(" RDLVGATETO[6] ---> Indicates read DQS gate training has timed out\n\n");
	}
}

Interrupt_Status_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Interrupt Status Register (IRQSTATUS_SYS) ****************************\n\n");
	
	GEL_TextOut(" DDR3EMIF_IRQ_STATUS_SYS ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(DDR3EMIF_IRQ_STATUS_SYS,31,0));
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_IRQ_STATUS_SYS,3,3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" WR_ECC_ERR_SYS[3] ---> write ECC error interrupt not pending\n");
	}
	else
	{
		GEL_TextOut(" WR_ECC_ERR_SYS[3] ---> write ECC error interrupt pending\n");
	}
	
	reg_field = BB_REG_FIELD_READ(DDR3EMIF_IRQ_STATUS_SYS,4,4);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" RD_ECC_ERR_SYS[4] ---> Read ECC error interrupt not pending\n\n");
	}
	else
	{
		GEL_TextOut(" RD_ECC_ERR_SYS[4] ---> Read ECC error interrupt pending\n\n");
	}
}


// TCI6614 PSC configuration

#define PSC_PID                                    (0x02350000u)
#define PSC_VCNTLID                                (0x02350014u)
#define BB_PSC_PTCMD                                  (0x02350120u)
#define BB_PSC_PTSTAT                                 (0x02350128u)
#define PSC_PDSTAT0                                (0x02350200u)
#define PSC_PDSTAT1                                (0x02350204u)
#define PSC_PDSTAT2                                (0x02350208u)
#define PSC_PDSTAT3                                (0x0235020Cu)
#define PSC_PDSTAT4                                (0x02350210u)
#define PSC_PDSTAT5                                (0x02350214u)
#define PSC_PDSTAT6                                (0x02350218u)
#define PSC_PDSTAT7                                (0x0235021Cu)
#define PSC_PDSTAT8                                (0x02350220u)
#define PSC_PDSTAT9                                (0x02350224u)
#define PSC_PDSTAT10                               (0x02350228u)
#define PSC_PDSTAT11                               (0x0235022Cu)
#define PSC_PDSTAT12                               (0x02350230u)
#define PSC_PDSTAT13                               (0x02350234u)
#define PSC_PDSTAT14                               (0x02350238u)
#define PSC_PDSTAT15                               (0x0235023Cu)
#define PSC_PDSTAT16                               (0x02350240u)
#define PSC_PDSTAT17                               (0x02350244u)
#define PSC_PDSTAT18                               (0x02350248u)

#define PSC_PDCTL0                                 (0x02350300u)
#define PSC_PDCTL1                                 (0x02350304u)
#define PSC_PDCTL2                                 (0x02350308u)
#define PSC_PDCTL3                                 (0x0235030Cu)
#define PSC_PDCTL4                                 (0x02350310u)
#define PSC_PDCTL5                                 (0x02350314u)
#define PSC_PDCTL6                                 (0x02350318u)
#define PSC_PDCTL7                                 (0x0235031Cu)
#define PSC_PDCTL8                                 (0x02350320u)
#define PSC_PDCTL9                                 (0x02350324u)
#define PSC_PDCTL10                                (0x02350328u)
#define PSC_PDCTL11                                (0x0235032Cu)
#define PSC_PDCTL12                                (0x02350330u)
#define PSC_PDCTL13                                (0x02350334u)
#define PSC_PDCTL14                                (0x02350338u)
#define PSC_PDCTL15                                (0x0235033Cu)
#define PSC_PDCTL16                                (0x02350340u)
#define PSC_PDCTL17                                (0x02350344u)
#define PSC_PDCTL18                                (0x02350348u)

#define PSC_MDSTAT0                                (0x02350800u)
#define PSC_MDSTAT1                                (0x02350804u)
#define PSC_MDSTAT2                                (0x02350808u)
#define PSC_MDSTAT3                                (0x0235080Cu)
#define PSC_MDSTAT4                                (0x02350810u)
#define PSC_MDSTAT5                                (0x02350814u)
#define PSC_MDSTAT6                                (0x02350818u)
#define PSC_MDSTAT7                                (0x0235081Cu)
#define PSC_MDSTAT8                                (0x02350820u)
#define PSC_MDSTAT9                                (0x02350824u)
#define PSC_MDSTAT10                               (0x02350828u)
#define PSC_MDSTAT11                               (0x0235082Cu)
#define PSC_MDSTAT12                               (0x02350830u)
#define PSC_MDSTAT13                               (0x02350834u)
#define PSC_MDSTAT14                               (0x02350838u)
#define PSC_MDSTAT15                               (0x0235083Cu)
#define PSC_MDSTAT16                               (0x02350840u)
#define PSC_MDSTAT17                               (0x02350844u)
#define PSC_MDSTAT18                               (0x02350848u)
#define PSC_MDSTAT19                               (0x0235084Cu)
#define PSC_MDSTAT20                               (0x02350850u)
#define PSC_MDSTAT21                               (0x02350854u)
#define PSC_MDSTAT22                               (0x02350858u)
#define PSC_MDSTAT23                               (0x0235085Cu)
#define PSC_MDSTAT24                               (0x02350860u)
#define PSC_MDSTAT25                               (0x02350864u)
#define PSC_MDSTAT26                               (0x02350868u)
#define PSC_MDSTAT27                               (0x0235086Cu)
#define PSC_MDSTAT28                               (0x02350870u)
#define PSC_MDSTAT29                               (0x02350874u)
#define PSC_MDSTAT30                               (0x02350878u)

#define PSC_MDCTL0                                 (0x02350A00u)
#define PSC_MDCTL1                                 (0x02350A04u)
#define PSC_MDCTL2                                 (0x02350A08u)
#define PSC_MDCTL3                                 (0x02350A0Cu)
#define PSC_MDCTL4                                 (0x02350A10u)
#define PSC_MDCTL5                                 (0x02350A14u)
#define PSC_MDCTL6                                 (0x02350A18u)
#define PSC_MDCTL7                                 (0x02350A1Cu)
#define PSC_MDCTL8                                 (0x02350A20u)
#define PSC_MDCTL9                                 (0x02350A24u)
#define PSC_MDCTL10                                (0x02350A28u)
#define PSC_MDCTL11                                (0x02350A2Cu)
#define PSC_MDCTL12                                (0x02350A30u)
#define PSC_MDCTL13                                (0x02350A34u)
#define PSC_MDCTL14                                (0x02350A38u)
#define PSC_MDCTL15                                (0x02350A4Cu)
#define PSC_MDCTL16                                (0x02350A40u)
#define PSC_MDCTL17                                (0x02350A44u)
#define PSC_MDCTL18                                (0x02350A48u)
#define PSC_MDCTL19                                (0x02350A4Cu)
#define PSC_MDCTL20                                (0x02350A50u)
#define PSC_MDCTL21                                (0x02350A54u)
#define PSC_MDCTL22                                (0x02350A58u)
#define PSC_MDCTL23                                (0x02350A5Cu)
#define PSC_MDCTL24                                (0x02350A60u)
#define PSC_MDCTL25                                (0x02350A64u)
#define PSC_MDCTL26                                (0x02350A68u)
#define PSC_MDCTL27                                (0x02350A6Cu)
#define PSC_MDCTL28                                (0x02350A70u)
#define PSC_MDCTL29                                (0x02350A74u)
#define PSC_MDCTL30                                (0x02350A78u)

TCI6614_psc_voltage_control_identification()
{
unsigned int reg_field, reg_field_1, reg_field_2, reg_field_3;
	
	GEL_TextOut(" *************************** Voltage Control Identification Register (VCNTLID) ****************************\n\n");
	
	GEL_TextOut(" PSC_VCNTLID ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PSC_VCNTLID,31,0));
	
	reg_field = BB_REG_FIELD_READ(PSC_VCNTLID,21,16);
	
	GEL_TextOut(" SmartReflex Class-0 VCNTL selection coming from EFUSE(VCNTL) ---> %d\n",,,,,reg_field);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.7 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.706 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.713 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.719 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.726 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.732 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.738 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.745 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 8)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.751 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 9)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.758 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 10)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.764 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 11)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.77 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 12)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.777 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 13)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.783 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 14)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.79 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 15)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.796 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 16)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.802 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 17)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.809 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 18)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.815 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 19)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.822 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 20)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.828 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 21)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.834 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 22)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.841 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 23)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.847 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 24)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.854 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 25)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.86 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 26)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.866 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 27)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.873 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 28)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.879 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 29)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.886 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 30)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.892 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 31)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.898 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 32)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.905 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 33)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.911 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 34)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.918 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 35)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.924 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 36)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.93 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 37)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.937 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 38)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.943 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 39)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.95 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 40)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.956 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 41)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.962 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 42)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.969 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 43)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.975 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 44)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.982 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 45)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.988 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 46)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 0.994 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 47)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.001 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 48)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.007 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 49)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.014 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 50)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.02 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 51)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.026 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 52)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.033 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 53)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.039 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 54)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.046 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 55)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.052 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 56)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.058 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 57)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.065 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 58)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.071 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 59)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.078 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 60)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.084 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 61)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.09 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 62)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.097 Volts\n\n",,,,,reg_field);
	}
	else if(reg_field == 63)
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: 1.103 Volts\n\n",,,,,reg_field);
	}
	else
	{
		GEL_TextOut(" Vdd corresponding to VCNTL#%d: Reserved\n\n",,,,,reg_field);
	}
}


Ap_Set_PSC_State(unsigned int power_domain_num,unsigned int clock_domain_num,unsigned int switch_input)
{
    //Wait for any previous transitions to complete
	while((BB_REG_FIELD_READ(BB_PSC_PTSTAT,power_domain_num,power_domain_num)));
	
	//Write Switch input into the corresponding PDCTL register
	BB_REG_FIELD_WRITE((PSC_MDCTL0+(clock_domain_num*4)),4,0,switch_input);
	
	//Write PTCMD to start the transistion
	BB_REG_FIELD_WRITE(BB_PSC_PTCMD,power_domain_num,power_domain_num,0x1);
	
	//wait for the transistion to complete
	while((BB_REG_FIELD_READ(BB_PSC_PTSTAT,power_domain_num,power_domain_num)));
}

TCI6614_enable_all_power_clock_domains()
{
	unsigned int power_domain_num;
	
	GEL_TextOut( "Power on all PSC power and clock domains... \n");
	
	for(power_domain_num = 0; power_domain_num <= 17; power_domain_num++)
	{
		//Wait for any previous transitions to complete
		while((BB_REG_FIELD_READ(BB_PSC_PTSTAT,power_domain_num,power_domain_num)));
		
		//Write Switch input into the corresponding PDCTL register
		BB_REG_FIELD_WRITE((PSC_PDCTL0+(power_domain_num*4)),0,0,0x1);
		
		//Write PTCMD to start the transistion
		BB_REG_FIELD_WRITE(BB_PSC_PTCMD,power_domain_num,power_domain_num,0x1);
		
		//wait for the transistion to complete
		while((BB_REG_FIELD_READ(BB_PSC_PTSTAT,power_domain_num,power_domain_num)));
	}
	
	GEL_TextOut(" All power domains of TCI6614 are enabled Successfully\n\n");
    
	Ap_Set_PSC_State(PD0, LPSC_SMARTRFLX, PSC_ENABLE);
	Ap_Set_PSC_State(PD0, LPSC_DDR3, PSC_ENABLE);
	Ap_Set_PSC_State(PD0, LPSC_VUSR, PSC_ENABLE);
	Ap_Set_PSC_State(PD0, LPSC_VCP2A, PSC_ENABLE);
	Ap_Set_PSC_State(PD1, LPSC_DEBUG, PSC_ENABLE);
	Ap_Set_PSC_State(PD1, LPSC_TETB, PSC_ENABLE);
	Ap_Set_PSC_State(PD2, LPSC_PA, PSC_ENABLE);
	Ap_Set_PSC_State(PD2, LPSC_SGMII, PSC_ENABLE);
	Ap_Set_PSC_State(PD2, LPSC_SA, PSC_ENABLE);
	Ap_Set_PSC_State(PD3, LPSC_PCIE, PSC_ENABLE);
	Ap_Set_PSC_State(PD4, LPSC_SRIO, PSC_ENABLE);
	Ap_Set_PSC_State(PD5, LPSC_BCP, PSC_ENABLE);
	Ap_Set_PSC_State(PD6, LPSC_ARM, PSC_ENABLE);
	Ap_Set_PSC_State(PD7, LPSC_MSMCRAM, PSC_ENABLE);
	Ap_Set_PSC_State(PD8, LPSC_RACA_RACB, PSC_ENABLE);
	Ap_Set_PSC_State(PD8, LPSC_TAC, PSC_ENABLE);
	Ap_Set_PSC_State(PD9, LPSC_FFTCA_FFTCB, PSC_ENABLE);
	Ap_Set_PSC_State(PD10, LPSC_AIF2, PSC_ENABLE);
	Ap_Set_PSC_State(PD11, LPSC_TCP3DA, PSC_ENABLE);
	Ap_Set_PSC_State(PD12, LPSC_VCP2B, PSC_ENABLE);
	Ap_Set_PSC_State(PD12, LPSC_VCP2C, PSC_ENABLE);
	Ap_Set_PSC_State(PD12, LPSC_VCP2D, PSC_ENABLE);
	Ap_Set_PSC_State(PD13, LPSC_C0_TIM0, PSC_ENABLE);
	Ap_Set_PSC_State(PD14, LPSC_C1_TIM1, PSC_ENABLE);
	Ap_Set_PSC_State(PD14, LPSC_C1_RSA, PSC_ENABLE);
	Ap_Set_PSC_State(PD15, LPSC_C2_TIM2, PSC_ENABLE);
	Ap_Set_PSC_State(PD15, LPSC_C2_RSA, PSC_ENABLE);
	Ap_Set_PSC_State(PD16, LPSC_C3_TIM3, PSC_ENABLE);
	Ap_Set_PSC_State(PD17, LPSC_TCP3dB, PSC_ENABLE);

	GEL_TextOut( "All clock domains of TCI6614 are enabled Successfully\n\n" );
}

TCI6614_psc_pwrdomain_status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 PSC PWR DOMAINS STATUS **************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT0,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Most peripheral logic (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" Most peripheral logic (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT1,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Per-core TETB and System TETB (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" Per-core TETB and System TETB (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT2,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Packet Coprocessor (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" Packet Coprocessor (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT3,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PCIe (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" PCIe (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT4,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SRIO (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" SRIO (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT5,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" BCP (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" BCP (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT6,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" ARM MONZA (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" ARM MONZA (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT7,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MSMC RAM (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" MSMC RAM (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT8,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" RAC_A, RAC_B and TAC (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" RAC_A, RAC_B and TAC (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT9,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" FFTC_A and FFTC_B (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" FFTC_A and FFTC_B (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT10,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" AIF2 (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" AIF2 (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT11,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCP3d_A (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" TCP3d_A (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT12,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" VCP2_A, VCP2_B, VCP2_C and VCP2_D (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" VCP2_A, VCP2_B, VCP2_C and VCP2_D (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT13,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" C66x Core 0, L1/L2 RAMs (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" C66x Core 0, L1/L2 RAMs (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT14,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" C66x Core 1, L1/L2 RAMs (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" C66x Core 1, L1/L2 RAMs (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT15,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" C66x Core 2, L1/L2 RAMs (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" C66x Core 2, L1/L2 RAMs (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT16,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" C66x Core 3, L1/L2 RAMs (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" C66x Core 3, L1/L2 RAMs (pwr domain) is in ##0N## state\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_PDSTAT17,1,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" TCP3d_B (pwr domain) is in **OFF** state\n");
	}
	else
	{
		GEL_TextOut(" TCP3d_B (pwr domain) is in ##0N## state\n");
	}
}

TCI6614_psc_clockdomain_status(unsigned int clkdomain_no)
{
	unsigned int reg_field;
	
	reg_field = BB_REG_FIELD_READ((PSC_MDSTAT0+(clkdomain_no*4)),5,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" STATE[5:0] ---> **SwRstDisable** state\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" STATE[5:0] ---> ##Enable## state\n");
	} 
	else
	{
		GEL_TextOut(" STATE[5:0] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ((PSC_MDSTAT0+(clkdomain_no*4)),10,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRST[10] ---> Module reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[10] ---> Module reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ((PSC_MDSTAT0+(clkdomain_no*4)),11,11);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ((PSC_MDSTAT0+(clkdomain_no*4)),12,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is **OFF**\n\n");
	}
	else
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is ##ON##\n\n");
	}

}




TCI6614_Psc_Clockdomain_Status()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 PSC CLOCK DOMAINS STATUS **************************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");
	
	GEL_TextOut(" SHARED LPSC for all peripherals Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(0);
	
	GEL_TextOut(" SmartReflex Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(1);
	
	GEL_TextOut(" DDR3 EMIF Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(2);
	
	GEL_TextOut(" Hyperbridge (VUSR) Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(3);
	
	GEL_TextOut(" VCP2_A Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(4);
	
	GEL_TextOut(" Debug Subsystem and Tracers Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(5);
	
	GEL_TextOut(" Per-core TETB and System TETB Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(6);
	
	GEL_TextOut(" Packet Accelerator Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(7);
	
	GEL_TextOut(" Ethernet SGMIIs Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(8);
	
	GEL_TextOut(" Security Accelerator Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(9);
	
	GEL_TextOut(" PCIe Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(10);
	
	GEL_TextOut(" SRIO Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(11);
	
	GEL_TextOut(" BCP Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(12);
	
	GEL_TextOut(" ARM (Monza) Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(13);
	
	GEL_TextOut(" MSMC RAM Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(14);
	
	GEL_TextOut(" RAC_A and RAC_B Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(15);
	
	GEL_TextOut(" TAC Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(16);
	
	GEL_TextOut(" FFTC_A and FFTC_B Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(17);
	
	GEL_TextOut(" AIF2 Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(18);
	
	GEL_TextOut(" TCP3d_A Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(19);
	
	GEL_TextOut(" VCP2_B Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(20);
	
	GEL_TextOut(" VCP2_C Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(21);
	
	GEL_TextOut(" VCP2_D Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(22);
	
	GEL_TextOut(" C66x Core 0 and Timer 0 Clock domain Status: \n\n");
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT23,5,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" STATE[5:0] ---> **SwRstDisable** state\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" STATE[5:0] ---> ##Enable## state\n");
	} 
	else
	{
		GEL_TextOut(" STATE[5:0] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT23,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRST[8] ---> Local reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[8] ---> Local reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT23,9,9);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT23,10,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRST[10] ---> Module reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[10] ---> Module reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT23,11,11);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT23,12,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is **OFF**\n\n");
	}
	else
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is ##ON##\n\n");
	}
	
	GEL_TextOut(" C66x Core 1 and Timer 1 Clock domain Status: \n\n");
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT24,5,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" STATE[5:0] ---> **SwRstDisable** state\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" STATE[5:0] ---> ##Enable## state\n");
	} 
	else
	{
		GEL_TextOut(" STATE[5:0] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT24,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRST[8] ---> Local reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[8] ---> Local reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT24,9,9);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT24,10,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRST[10] ---> Module reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[10] ---> Module reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT24,11,11);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT24,12,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is **OFF**\n\n");
	}
	else
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is ##ON##\n\n");
	}
	
	GEL_TextOut(" C66x Core 1 RSAs Clock domain Status: \n\n");
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT25,5,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" STATE[5:0] ---> **SwRstDisable** state\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" STATE[5:0] ---> ##Enable## state\n");
	} 
	else
	{
		GEL_TextOut(" STATE[5:0] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT25,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRST[8] ---> Local reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[8] ---> Local reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT25,9,9);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT25,10,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRST[10] ---> Module reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[10] ---> Module reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT25,11,11);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT25,12,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is **OFF**\n\n");
	}
	else
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is ##ON##\n\n");
	}
	
	GEL_TextOut(" C66x Core 2 and Timer 2 Clock domain Status: \n\n");
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT26,5,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" STATE[5:0] ---> **SwRstDisable** state\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" STATE[5:0] ---> ##Enable## state\n");
	} 
	else
	{
		GEL_TextOut(" STATE[5:0] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT26,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRST[8] ---> Local reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[8] ---> Local reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT26,9,9);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT26,10,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRST[10] ---> Module reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[10] ---> Module reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT26,11,11);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT26,12,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is **OFF**\n\n");
	}
	else
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is ##ON##\n\n");
	}
	
	GEL_TextOut(" C66x Core 2 RSAs Clock domain Status: \n\n");
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT27,5,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" STATE[5:0] ---> **SwRstDisable** state\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" STATE[5:0] ---> ##Enable## state\n");
	} 
	else
	{
		GEL_TextOut(" STATE[5:0] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT27,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRST[8] ---> Local reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[8] ---> Local reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT27,9,9);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT27,10,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRST[10] ---> Module reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[10] ---> Module reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT27,11,11);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT27,12,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is **OFF**\n\n");
	}
	else
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is ##ON##\n\n");
	}
	
	GEL_TextOut(" C66x Core 3 and Timer 3 Clock domain Status: \n\n");
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT28,5,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" STATE[5:0] ---> **SwRstDisable** state\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" STATE[5:0] ---> ##Enable## state\n");
	} 
	else
	{
		GEL_TextOut(" STATE[5:0] ---> Reserved\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT28,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRST[8] ---> Local reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[8] ---> Local reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT28,9,9);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" LRSTDONE[11] ---> Local reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT28,10,10);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRST[10] ---> Module reset is **asserted**\n");
	}
	else
	{
		GEL_TextOut(" MRST[10] ---> Module reset is ##de-asserted##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT28,11,11);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is **not done**\n");
	}
	else
	{
		GEL_TextOut(" MRSTDONE[11] ---> Module reset is ##done##\n");
	}
	
	reg_field = BB_REG_FIELD_READ(PSC_MDSTAT28,12,12);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is **OFF**\n\n");
	}
	else
	{
		GEL_TextOut(" MCKOUT[12] ---> Module clock is ##ON##\n\n");
	}
	
	GEL_TextOut(" TCP3d_B Clock domain Status: \n\n");
	
	TCI6614_psc_clockdomain_status(29);
}

//PLL Controller

#define PLLCONTROL_RSTYPE                          (0x023100E4u)
#define PLLCONTROL_RSCTRL                          (0x023100E8u)
#define PLLCONTROL_RSCFG                           (0x023100ECu)
#define PLLCONTROL_RSISO                           (0x023100F0u)
#define PLLCONTROL_PLLCTL                          (0x02310100u)
#define PLLCONTROL_SECCTL                          (0x02310108u)
#define PLLCONTROL_PLLM                            (0x02310110u)
#define PLLCONTROL_PREDIV                          (0x02310114u)
#define PLLCONTROL_PLLDIV1                         (0x02310118u)
#define PLLCONTROL_PLLDIV2                         (0x0231011Cu)
#define PLLCONTROL_PLLDIV3                         (0x02310120u)
#define PLLCONTROL_POSTDIV                         (0x02310128u)
#define PLLCONTROL_PLLCMD                          (0x02310138u)
#define PLLCONTROL_PLLSTAT                         (0x0231013Cu)
#define PLLCONTROL_ALNCTL                          (0x02310140u)
#define PLLCONTROL_DCHANGE                         (0x02310144u)
#define PLLCONTROL_CKEN                            (0x02310148u)
#define PLLCONTROL_CKSTAT                          (0x0231014Cu)
#define PLLCONTROL_SYSTAT                          (0x02310150u)
#define PLLCONTROL_PLLDIV4                         (0x02310160u)
#define PLLCONTROL_PLLDIV5                         (0x02310164u)
#define PLLCONTROL_PLLDIV6                         (0x02310168u)
#define PLLCONTROL_PLLDIV7                         (0x0231016Cu)
#define PLLCONTROL_PLLDIV8                         (0x02310170u)
#define PLLCONTROL_PLLDIV9                         (0x02310174u)
#define PLLCONTROL_PLLDIV10                        (0x02310178u)
#define PLLCONTROL_PLLDIV11                        (0x0231017Cu)
#define PLLCONTROL_PLLDIV12                        (0x02310180u)
#define PLLCONTROL_PLLDIV13                        (0x02310184u)
#define PLLCONTROL_PLLDIV14                        (0x02310188u)
#define PLLCONTROL_PLLDIV15                        (0x0231018Cu)
#define PLLCONTROL_PLLDIV16                        (0x02310190u)


PLL_Control_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** PLL Control Register (PLLCTL) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_PLLCTL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_PLLCTL,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_PLLCTL,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PLLEN[0] ---> Bypass mode. Dividers PREDIV and PLL are **bypassed** \n");
	}
	else
	{
		GEL_TextOut(" PLLEN[0] ---> PLL mode. Dividers PREDIV and PLL are ##not bypassed## \n");
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_PLLCTL,1,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PLLPWRDN[1] ---> PLL is ##operational## \n");
	}
	else
	{
		GEL_TextOut(" PLLPWRDN[1] ---> PLL is placed in a **power-down state**; i.e., all analog circuitry in the PLL is turned off \n");
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_PLLCTL,3,3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PLLRST[3] ---> PLL reset is ##released## \n");
	}
	else
	{
		GEL_TextOut(" PLLRST[3] ---> PLL reset is **asserted** \n");
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_PLLCTL,5,5);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PLLENSRC[5] ---> PLLEN bit is ##enabled## \n\n");
	}
	else
	{
		GEL_TextOut(" PLLENSRC[5] ---> PLLEN bit is **disabled** \n\n");
	}
}


PLL_Multiplier_Control_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** PLL Multiplier Control Register (PLLM) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_PLLM ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_PLLM,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_PLLM,5,0);
	
	GEL_TextOut(" PLLM[5:0] ---> %d multiplier rate\n\n",,,,,(reg_field));
}


PLL_Pre_Divider_Registers()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** PLL Pre-Divider Registers (PREDIV) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_PREDIV ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_PREDIV,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_PREDIV,4,0);
	
	GEL_TextOut(" RATIO[4:0] ---> /%d. Divide frequency by %d\n",,,,,(reg_field+1),(reg_field+1));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_PREDIV,15,15);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PREDEN[15] ---> Pre-divider is **disabled**. No clock output \n\n");
	}
	else
	{
		GEL_TextOut(" PREDEN[15] ---> Pre-divider is ##enabled## \n\n");
	}
}


PLL_Controller_Divider_Register()
{
	unsigned int reg_field,i;
	
	for(i=1;i<=3;i++)
	{
		GEL_TextOut(" *************************** PLL Controller Divider Register (PLLDIV%d) ****************************\n\n",,,,,i);
		
		reg_field = BB_REG_FIELD_READ((PLLCONTROL_PLLDIV1+((i-1)*4)),7,0);
		
		GEL_TextOut(" RATIO[4:0] ---> /%d. Divide frequency by %d\n",,,,,(reg_field+1),(reg_field+1));
		
		reg_field = BB_REG_FIELD_READ((PLLCONTROL_PLLDIV1+((i-1)*4)),15,15);
		
		if(reg_field == 0)
		{
			GEL_TextOut(" D%dEN[15] ---> Divider%d is **disabled**. No clock output \n",,,,,i,i);
		}
		else
		{
			GEL_TextOut(" D%dEN[15] ---> Divider%d is ##enabled## \n",,,,,i,i);
		}
	}
	
	for(i=4;i<=16;i++)
	{
		GEL_TextOut(" *************************** PLL Controller Divider Register (PLLDIV%d) ****************************\n\n",,,,,i);
		
		reg_field = BB_REG_FIELD_READ((PLLCONTROL_PLLDIV4+((i-1)*4)),7,0);
		
		GEL_TextOut(" RATIO[4:0] ---> /%d. Divide frequency by %d\n",,,,,(reg_field+1),(reg_field+1));
		
		reg_field = BB_REG_FIELD_READ((PLLCONTROL_PLLDIV4+((i-1)*4)),15,15);
		
		if(i != 16)
		{
			if(reg_field == 0)
			{
				GEL_TextOut(" D%dEN[15] ---> Divider%d is **disabled**. No clock output \n",,,,,i,i);
			}
			else
			{
				GEL_TextOut(" D%dEN[15] ---> Divider%d is ##enabled## \n",,,,,i,i);
			}
		}
		else
		{
			if(reg_field == 0)
			{
				GEL_TextOut(" D%dEN[15] ---> Divider%d is **disabled**. No clock output \n\n",,,,,i,i);
			}
			else
			{
				GEL_TextOut(" D%dEN[15] ---> Divider%d is ##enabled## \n\n",,,,,i,i);
			}
		}
	}
}


Clock_Enable_Control_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Clock Enable Control Register (CKEN) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_CKEN ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_CKEN,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_CKEN,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" AUXEN[0] ---> **Disable** AUXCLK \n\n");
	}
	else
	{
		GEL_TextOut(" AUXEN[0] ---> ##Enable## AUXCLK \n\n");
	}
}

Clock_Status_Register()
{
	unsigned int reg_field;
	
	GEL_TextOut(" *************************** Clock Status Register (CKSTAT) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_CKSTAT ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_CKSTAT,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_CKSTAT,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" AUXON[0] ---> AUXCLK is **gated** \n\n");
	}
	else
	{
		GEL_TextOut(" AUXON[0] ---> AUXCLK is ##on## \n\n");
	}
}


SYSCLK_Status_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** SYSCLK Status Register (SYSTAT) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_SYSTAT ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_SYSTAT,31,0));
	
	for(i=0;i<=11;i++)
	{
		reg_field = BB_REG_FIELD_READ(PLLCONTROL_SYSTAT,i,i);
		
		if(i != 11)
		{
			if(reg_field == 0)
			{
				GEL_TextOut(" SYS[%d]ON ---> SYSCLK%d is **gated** \n",,,,,(i+1),(i+1));
			}
			else
			{
				GEL_TextOut(" SYS[%d]ON ---> SYSCLK%d is ##on## \n",,,,,(i+1),(i+1));
			}
		}
		else
		{
			if(reg_field == 0)
			{
				GEL_TextOut(" SYS[%d]ON ---> SYSCLK%d is **gated** \n\n",,,,,(i+1),(i+1));
			}
			else
			{
				GEL_TextOut(" SYS[%d]ON ---> SYSCLK%d is ##on## \n\n",,,,,(i+1),(i+1));
			}
		}
	}
}


Reset_Type_Status_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Reset Type Status Register (RSTYPE) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_RSTYPE ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_RSTYPE,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSTYPE,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" POR[0] ---> Power-on reset ##was not## the last reset to occur \n");
	}
	else
	{
		GEL_TextOut(" POR[0] ---> Power-on reset **was** the last reset to occur \n");
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSTYPE,1,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" RESET(bar)[1] ---> RESET(bar)initiated Reset ##was not## the last reset to occur \n");
	}
	else
	{
		GEL_TextOut(" RESET(bar)[1] ---> RESET(bar)initiated Reset **was** the last reset to occur \n");
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSTYPE,2,2);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PLLCTLRST[2] ---> PLLCTL initiated Reset ##was not## the last reset to occur \n");
	}
	else
	{
		GEL_TextOut(" PLLCTLRST[2] ---> PLLCTL initiated Reset **was** the last reset to occur \n");
	}
	
	for(i=0;i<=3;i++)
	{
	
		reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSTYPE,(8+i),(8+i));
		
		if(reg_field == 0)
		{
			GEL_TextOut(" WDRST[%d] ---> Core%d watchdog Timer initiated Reset ##was not## the last reset to occur\n",,,,,(i+1),i);
		}
		else
		{
			GEL_TextOut(" WDRST[%d] ---> Core%d watchdog Timer initiated Reset **was** the last reset to occur\n \n",,,,,(i+1),i);
		}
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSTYPE,28,28);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" EMURST[0] ---> Emulation initiated Reset ##was not## the last reset to occur\n\n");
	}
	else
	{
		GEL_TextOut(" EMURST[0] ---> Emulation initiated Reset **was** the last reset to occur\n\n");
	}
}


Reset_Control_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Reset Control Register (RSTCTRL) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_RSCTRL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_RSCTRL,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSCTRL,16,16);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" SWRST[16] ---> Software reset is **asserted** \n\n");
	}
	else
	{
		GEL_TextOut(" SWRST[16] ---> Software reset is ##not asserted## \n\n");
	}
}


Reset_Configuration_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Reset Configuration Register (RSTCFG) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_RSCFG ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_RSCFG,31,0));
	
	for(i=0;i<=3;i++)
	{
		reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSCFG,i,i);
		
		if(reg_field == 0)
		{
			GEL_TextOut(" WDTYPE[%d](Core%d Watchdog Timer initiates a reset of type) ---> Hard Reset (default) \n",,,,,(i+1),i);
		}
		else
		{
			GEL_TextOut(" WDTYPE[%d](Core%d Watchdog Timer initiates a reset of type) ---> Soft Reset \n",,,,,(i+1),i);
		}
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSCFG,12,12);
		
	if(reg_field == 0)
	{
		GEL_TextOut(" RESET(bar)TYPE[12] (RESET(bar)initiated Reset) ---> Hard Reset (default) \n");
	}
	else
	{
		GEL_TextOut(" RESET(bar)TYPE[12] (RESET(bar)initiated Reset) ---> Soft Reset \n");
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSCFG,13,13);
		
	if(reg_field == 0)
	{
		GEL_TextOut(" PLLCTLRSTTYPE[13] ( PLL controller initiated Reset) ---> Hard Reset (default) \n\n");
	}
	else
	{
		GEL_TextOut(" PLLCTLRSTTYPE[13] (PLL controller initiated Reset) ---> Soft Reset \n\n");
	}
}


Reset_Isolation_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Reset Isolation Register (RSISO) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_RSISO ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_RSISO,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSISO,3,3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MOD_ISO[3] ---> AIF2 **Not** reset isolated \n");
	}
	else
	{
		GEL_TextOut(" MOD_ISO[3] ---> AIF2 ##is## reset isolated \n");
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSISO,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MOD_ISO[8] ---> Smart-Reflex(SR) **Not** reset isolated \n");
	}
	else
	{
		GEL_TextOut(" MOD_ISO[8] ---> Smart-Reflex(SR) ##is## reset isolated \n");
	}
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_RSISO,9,9);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" MOD_ISO[9] ---> SRIO **Not** reset isolated \n\n");
	}
	else
	{
		GEL_TextOut(" MOD_ISO[9] ---> SRIO ##is## reset isolated \n\n");
	}
}

PLL_Post_Divider_Control_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** PLL Post-Divider Control Register (POSTDIV) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_POSTDIV ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_POSTDIV,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_POSTDIV,4,0);
	
	GEL_TextOut(" RATIO[4:0] ---> /%d. Divide frequency by %d\n",,,,,(reg_field+1),(reg_field+1));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_POSTDIV,15,15);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" PREDEN[15] ---> Post-divider is **disabled**. No clock output \n\n");
	}
	else
	{
		GEL_TextOut(" PREDEN[15] ---> Post-divider is ##enabled## \n\n");
	}
}


PLL_Secondary_Control_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** PLL Secondary Control Register (SECCTL) ****************************\n\n");
	
	GEL_TextOut(" PLLCONTROL_SECCTL ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(PLLCONTROL_SECCTL,31,0));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_SECCTL,22,19);
	
	GEL_TextOut(" OUTPUT_DIVIDE[22:19] ---> /%d. Divide frequency by %d\n",,,,,(reg_field+1),(reg_field+1));
	
	reg_field = BB_REG_FIELD_READ(PLLCONTROL_SECCTL,23,23);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" BYPASS[23] ---> Main PLL Bypass ##disabled## \n\n");
	}
	else
	{
		GEL_TextOut(" BYPASS[23] ---> Main PLL Bypass **enabled** \n\n");
	}
}

//Cache Registers

#define CACHE_L1PCFG                               (0x01840020u)
#define CACHE_L1PCC                                (0x01840024u)
#define CACHE_L1PMPFAR                             (0x0184A400u)
#define CACHE_L1PMPFSR                             (0x0184A404u)

#define CACHE_L1DCFG                               (0x01840040u)
#define CACHE_L1DCC                                (0x01840044u)
#define CACHE_L1DMPFAR                             (0x0184AC00u)
#define CACHE_L1DMPFSR                             (0x0184AC04u)

#define CACHE_L2CFG                                (0x01840000u)
#define CACHE_L2MPFAR                              (0x0184A000u)
#define CACHE_L2MPFSR                              (0x0184A004u)
#define CACHE_MAR0                                 (0x01848000u)
#define CACHE_MAR1                                 (0x01848004u)



L1P_Configuration_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L1P Configuration Register (L1PCFG) ****************************\n\n",,,,,DNUM);
	
	GEL_TextOut(" CACHE_L1PCFG ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(CACHE_L1PCFG,31,0));
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PCFG,2,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" L1PMODE[2:0] ---> L1P cache disabled\n\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" L1PMODE[2:0] ---> 4K\n\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" L1PMODE[2:0] ---> 8K\n\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" L1PMODE[2:0] ---> 16K\n\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" L1PMODE[2:0] ---> 32K\n\n");
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" L1PMODE[2:0] ---> Maximal cache\n\n");
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" L1PMODE[2:0] ---> Maximal cache\n\n");
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" L1PMODE[2:0] ---> Maximal cache\n\n");
	}
}


L1P_Cache_Control_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L1P Cache Control Register (L1PCC) ****************************\n\n",,,,,DNUM);
	
	GEL_TextOut(" CACHE_L1PCC ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(CACHE_L1PCC,31,0));
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PCC,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" OPER[0] ---> Freeze mode **disabled** \n");
	}
	else
	{
		GEL_TextOut(" OPER[0] ---> Freeze mode ##enabled## \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PCC,16,16);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" POPER[16](Previous value) ---> Freeze mode **disabled** \n\n");
	}
	else
	{
		GEL_TextOut(" POPER[16](Previous value) ---> Freeze mode ##enabled## \n\n");
	}
}


L1P_Memory_Protection_Fault_Address_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L1P Memory Protection Fault Address Register (L1PMPFAR) ****************************\n\n",,,,,DNUM);
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PMPFAR,31,0);
	
	GEL_TextOut(" FAULT ADDRESS[31:0] ---> %x\n\n",,,,,(unsigned int)reg_field);
}


L1P_Memory_Protection_Fault_Set_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L1P Memory Protection Fault Set Register (L1PMPFSR) ****************************\n\n",,,,,DNUM);
	
	GEL_TextOut(" CACHE_L1PMPFSR ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(CACHE_L1PMPFSR,31,0));
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PMPFSR,1,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" User write access type (UW) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" User write access type (UW) ---> Indicates a User write request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PMPFSR,2,2);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" User read access type (UR) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" User read access type (UR) ---> Indicates a User read request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PMPFSR,4,4);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Supervisor write access type (UW) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" Supervisor write access type (UW) ---> Indicates a Supervisor write request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PMPFSR,5,5);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Supervisor read access type (UR) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" Supervisor read access type (UR) ---> Indicates a Supervisor read request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PMPFSR,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LOCAL ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" LOCAL ---> Access was a 'LOCAL' access.\n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1PMPFSR,15,9);
	
	GEL_TextOut(" FID[15:9] ---> %x\n\n",,,,,(unsigned char)reg_field);
}


L1D_Configuration_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L1D Configuration Register (L1DCFG) ****************************\n\n",,,,,DNUM);
	
	GEL_TextOut(" CACHE_L1DCFG ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(CACHE_L1DCFG,31,0));
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DCFG,2,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" L1DMODE[2:0] ---> L1D cache disabled\n\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" L1DMODE[2:0] ---> 4K\n\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" L1DMODE[2:0] ---> 8K\n\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" L1DMODE[2:0] ---> 16K\n\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" L1DMODE[2:0] ---> 32K\n\n");
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" L1DMODE[2:0] ---> Maximal cache\n\n");
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" L1DMODE[2:0] ---> Maximal cache\n\n");
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" L1DMODE[2:0] ---> Maximal cache\n\n");
	}
}


L1D_Cache_Control_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L1D Cache Control Register (L1DCC) ****************************\n\n",,,,,DNUM);
	
	GEL_TextOut(" CACHE_L1DCC ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(CACHE_L1DCC,31,0));
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DCC,0,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" OPER[0] ---> Freeze mode **disabled** \n");
	}
	else
	{
		GEL_TextOut(" OPER[0] ---> Freeze mode ##enabled## \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DCC,16,16);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" POPER[16](Previous value) ---> Freeze mode **disabled** \n\n");
	}
	else
	{
		GEL_TextOut(" POPER[16](Previous value) ---> Freeze mode ##enabled## \n\n");
	}
}


L1D_Memory_Protection_Fault_Address_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L1D Memory Protection Fault Address Register (L1DMPFAR) ****************************\n\n",,,,,DNUM);
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DMPFAR,31,0);
	
	GEL_TextOut(" FAULT ADDRESS[31:0] ---> %x\n\n",,,,,(unsigned int)reg_field);
}


L1D_Memory_Protection_Fault_Set_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L1D Memory Protection Fault Set Register (L1DMPFSR) ****************************\n\n",,,,,DNUM);
	
	GEL_TextOut(" CACHE_L1DMPFSR ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(CACHE_L1DMPFSR,31,0));
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DMPFSR,1,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" User write access type (UW) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" User write access type (UW) ---> Indicates a User write request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DMPFSR,2,2);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" User read access type (UR) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" User read access type (UR) ---> Indicates a User read request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DMPFSR,4,4);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Supervisor write access type (UW) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" Supervisor write access type (UW) ---> Indicates a Supervisor write request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DMPFSR,5,5);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Supervisor read access type (UR) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" Supervisor read access type (UR) ---> Indicates a Supervisor read request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DMPFSR,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LOCAL ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" LOCAL ---> Access was a 'LOCAL' access.\n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L1DMPFSR,15,9);
	
	GEL_TextOut(" FID[15:9] ---> %x\n\n",,,,,(unsigned char)reg_field);
}


L2_Configuration_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L2 Configuration Register (L2CFG) ****************************\n\n",,,,,DNUM);
	
	GEL_TextOut(" CACHE_L2CFG ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(CACHE_L2CFG,31,0));
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2CFG,2,0);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" L2MODE[2:0] ---> L2 cache disabled\n\n");
	}
	else if(reg_field == 1)
	{
		GEL_TextOut(" L2MODE[2:0] ---> 32K\n\n");
	}
	else if(reg_field == 2)
	{
		GEL_TextOut(" L2MODE[2:0] ---> 64K\n\n");
	}
	else if(reg_field == 3)
	{
		GEL_TextOut(" L2MODE[2:0] ---> 128K\n\n");
	}
	else if(reg_field == 4)
	{
		GEL_TextOut(" L2MODE[2:0] ---> 256K\n\n");
	}
	else if(reg_field == 5)
	{
		GEL_TextOut(" L2MODE[2:0] ---> 512K\n\n");
	}
	else if(reg_field == 6)
	{
		GEL_TextOut(" L2MODE[2:0] ---> 1024K\n\n");
	}
	else if(reg_field == 7)
	{
		GEL_TextOut(" L2MODE[2:0] ---> Maximal cache\n\n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2CFG,3,3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" L2CC[3] ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" L2CC[3] ---> L2 cache frozen \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2CFG,19,16);
	
	GEL_TextOut(" MMID[19:16](C66x CorePac ID number) ---> %x\n",,,,,(unsigned char)reg_field);
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2CFG,27,24);
	
	GEL_TextOut(" NUM MM[27:24](Number of C66x CorePacs minus 1) ---> %x\n\n",,,,,(unsigned char)reg_field);
}

L2_Memory_Protection_Fault_Address_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L2 Memory Protection Fault Address Register (L2MPFAR) ****************************\n\n",,,,,DNUM);
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2MPFAR,31,0);
	
	GEL_TextOut(" FAULT ADDRESS[31:0] ---> %x\n\n",,,,,(unsigned int)reg_field);
}


L2_Memory_Protection_Fault_Set_Register()
{
	unsigned int reg_field,i;
	
	GEL_TextOut(" *************************** Core%d L2 Memory Protection Fault Set Register (L2MPFSR) ****************************\n\n",,,,,DNUM);
	
	GEL_TextOut(" CACHE_L2MPFSR ---> %x \n\n",,,,,(unsigned int)BB_REG_FIELD_READ(CACHE_L2MPFSR,31,0));
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2MPFSR,1,1);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" User write access type (UW) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" User write access type (UW) ---> Indicates a User write request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2MPFSR,2,2);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" User read access type (UR) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" User read access type (UR) ---> Indicates a User read request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2MPFSR,4,4);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Supervisor write access type (UW) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" Supervisor write access type (UW) ---> Indicates a Supervisor write request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2MPFSR,5,5);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Supervisor read access type (UR) ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" Supervisor read access type (UR) ---> Indicates a Supervisor read request \n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2MPFSR,8,8);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" LOCAL ---> Normal operation \n");
	}
	else
	{
		GEL_TextOut(" LOCAL ---> Access was a 'LOCAL' access.\n");
	}
	
	reg_field = BB_REG_FIELD_READ(CACHE_L2MPFSR,15,9);
	
	GEL_TextOut(" FID[15:9] ---> %x\n\n",,,,,(unsigned char)reg_field);
}

L2_Cacheable_Memory_Attribute_Register()
{
	unsigned int reg_field,i;
	
	unsigned int mar_flag = 0;
	
	GEL_TextOut(" *************************** Core%d Memory Attribute Registers (MARn) ****************************\n\n",,,,,DNUM);
	
	reg_field = TSR;
	
	reg_field = ((reg_field >> 6)&0x3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Cacheable Memory Regions:\n\n");
		
		reg_field = BB_REG_FIELD_READ(CACHE_MAR0,0,0);
		
		if(reg_field == 1)
		{
			GEL_TextOut(" MAR0 ---> Local L2 RAM (fixed) \n");
			
			mar_flag = 1;
		}
		
		for(i=0;i<=254;i++)
		{
			reg_field = BB_REG_FIELD_READ((CACHE_MAR1+(i*4)),0,0);
		
			if(reg_field == 1)
			{
				GEL_TextOut(" MAR%d ---> %x to %x \n",,,,,(i+1),(unsigned int)(0x01000000+(i*0x01000000)),(unsigned int)((0x01000000+(i*0x01000000))+0xFFFFFF));
				
				mar_flag = 1;
			}
		}
		
		if(mar_flag == 0)
		{
			GEL_TextOut(" No Cacheable Memory Regions found\n\n");
		}
		
		mar_flag = 0;
	}
	else
	{
		GEL_TextOut(" Current execution mode (TSR.CXM) should be 'Supervisor'\n\n");
	} 
}
	
	
L2_PreFetchable_Memory_Attribute_Register()
{
	unsigned int reg_field,i;
	
	unsigned int mar_flag = 0;
	
	GEL_TextOut(" *************************** Core%d Memory Attribute Registers (MARn) ****************************\n\n",,,,,DNUM);

	reg_field = TSR;
	
	reg_field = ((reg_field >> 6)&0x3);
	
	if(reg_field == 0)
	{
		GEL_TextOut(" Pre-Fetchable Memory Regions:\n\n");
		
		reg_field = BB_REG_FIELD_READ(CACHE_MAR0,3,3);
		
		if(reg_field == 1)
		{
			GEL_TextOut(" MAR0 ---> Local L2 RAM (fixed) \n");
			
			mar_flag = 1;
		}
		
		for(i=0;i<=254;i++)
		{
			reg_field = BB_REG_FIELD_READ((CACHE_MAR1+(i*4)),3,3);
		
			if(reg_field == 1)
			{
				GEL_TextOut(" MAR%d ---> %x to %x \n",,,,,(i+1),(unsigned int)(0x01000000+(i*0x01000000)),(unsigned int)((0x01000000+(i*0x01000000))+0xFFFFFF));
				
				mar_flag = 1;
			}
		}
		
		if(mar_flag == 0)
		{
			GEL_TextOut(" No Pre-Fetchable Memory Regions found\n\n");
		}
		
		mar_flag = 0;
	}
	else
	{
		GEL_TextOut(" Current execution mode (TSR.CXM) should be 'Supervisor'\n\n");
	}
}



#define AIF2_CDMA_GBL_CNTL                         (0x01F14000u)
#define PA_CDMA_GBL_CNTL                           (0x02004000u)
#define FFTC_CDMA_GBL_CNTL                         (0x021F0200u)
#define SRIO_CDMA_GBL_CNTL                         (0x02901000u)
#define QMSS_CDMA_GBL_CNTL                         (0x02A6C000u)

#define PRIO_CNTL  (0x0C)

#define SRIO_PER_SET_CNTL                          (0x02900014u)
#define PCIE_PRIORITY                              (0x2180003Cu)

#define TAC_FE_HEAD_PRIO                           (0x02180080u)
#define TAC_FE_DATA_PRIO                           (0x02180084u)
#define TAC_FE_WARN_PRIO                           (0x02180088u)
#define TAC_FE_CPM_PRIO                            (0x0218008Cu)

#define COREPAC_MDMAARBU                              (0x01841010u)



TCI6614_master_priority_config()
{
	unsigned int bus_priority, cppi_tx_priority, cppi_rx_priority;
	unsigned int tac_header_priority, tac_data_priority, tac_warning_priority, tac_cpm_priority;
	unsigned int urgent_priority, normal_priority;

	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 MASTER VBUSM PRIORITY CONFIGURATION **********************************\n");
	GEL_TextOut(" ************************************PRIORITY-0 (Highest) & PRIORITY-7 (Lowest)********************************\n\n");

	//EDMA3 masters
	
	bus_priority = BB_REG_FIELD_READ((EDMA0_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA0_TC0 Master: Priority-%d\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA0_TPTC1_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA0_TC1 Master: Priority-%d\n\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA1_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA1_TC0 Master: Priority-%d\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA1_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA1_TC1 Master: Priority-%d\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA1_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA1_TC2 Master: Priority-%d\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA1_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA1_TC3 Master: Priority-%d\n\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA2_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA2_TC0 Master: Priority-%d\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA2_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA2_TC1 Master: Priority-%d\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA2_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA2_TC2 Master: Priority-%d\n",,,,,bus_priority);
	
	bus_priority = BB_REG_FIELD_READ((EDMA2_TPTC0_BASE + EDMA_TPTC_POPT),6,4);
	
	GEL_TextOut(" EDMA2_TC3 Master: Priority-%d\n\n",,,,,bus_priority);
	
	
	//AIF2 CPPI Master
	
	cppi_tx_priority = BB_REG_FIELD_READ((AIF2_CDMA_GBL_CNTL + PRIO_CNTL),2,0);
	cppi_rx_priority = BB_REG_FIELD_READ((AIF2_CDMA_GBL_CNTL + PRIO_CNTL),18,16);
	
	GEL_TextOut(" AIF2 PKT DMA Master: TX Priority-%d, RX Priority-%d\n\n",,,,,cppi_tx_priority, cppi_rx_priority);
	
	//PA CPPI Master
	
	cppi_tx_priority = BB_REG_FIELD_READ((PA_CDMA_GBL_CNTL + PRIO_CNTL),2,0);
	cppi_rx_priority = BB_REG_FIELD_READ((PA_CDMA_GBL_CNTL + PRIO_CNTL),18,16);
	
	GEL_TextOut(" PA PKT DMA Master: TX Priority-%d, RX Priority-%d\n\n",,,,,cppi_tx_priority, cppi_rx_priority);
	
	//SRIO CPPI Master
	
	cppi_tx_priority = BB_REG_FIELD_READ((SRIO_CDMA_GBL_CNTL + PRIO_CNTL),2,0);
	cppi_rx_priority = BB_REG_FIELD_READ((SRIO_CDMA_GBL_CNTL + PRIO_CNTL),18,16);
	
	GEL_TextOut(" SRIO PKT DMA Master: TX Priority-%d, RX Priority-%d\n\n",,,,,cppi_tx_priority, cppi_rx_priority);
	
	//FFTC CPPI Master
	
	cppi_tx_priority = BB_REG_FIELD_READ((FFTC_CDMA_GBL_CNTL + PRIO_CNTL),2,0);
	cppi_rx_priority = BB_REG_FIELD_READ((FFTC_CDMA_GBL_CNTL + PRIO_CNTL),18,16);
	
	GEL_TextOut(" FFTC PKT DMA Master: TX Priority-%d, RX Priority-%d\n\n",,,,,cppi_tx_priority, cppi_rx_priority);
	
	//QMSS CPPI Master
	
	cppi_tx_priority = BB_REG_FIELD_READ((QMSS_CDMA_GBL_CNTL + PRIO_CNTL),2,0);
	cppi_rx_priority = BB_REG_FIELD_READ((QMSS_CDMA_GBL_CNTL + PRIO_CNTL),18,16);
	
	GEL_TextOut(" QMSS PKT DMA Master: TX Priority-%d, RX Priority-%d\n\n",,,,,cppi_tx_priority, cppi_rx_priority);
	
	//QM_Second Master
	
	bus_priority = BB_REG_FIELD_READ(BOOTCFG_CHIP_MISC_CTL,2,0);
	
	GEL_TextOut(" QM_Second Master: Priority-%d\n\n",,,,,bus_priority);
	
	//SRIO Master
	
	bus_priority = BB_REG_FIELD_READ(SRIO_PER_SET_CNTL,11,9);
	
	GEL_TextOut(" SRIO Master: Priority-%d\n\n",,,,,bus_priority);
	
	//PCIe Master
	
	bus_priority = BB_REG_FIELD_READ(PCIE_PRIORITY,2,0);
	
	GEL_TextOut(" PCIE Master: Priority-%d\n\n",,,,,bus_priority);
	
	//TAC_FE Master
	
	tac_header_priority = BB_REG_FIELD_READ(TAC_FE_HEAD_PRIO,2,0);
	tac_data_priority = BB_REG_FIELD_READ(TAC_FE_DATA_PRIO,2,0);
	tac_warning_priority = BB_REG_FIELD_READ(TAC_FE_WARN_PRIO,2,0);
	tac_cpm_priority = BB_REG_FIELD_READ(TAC_FE_CPM_PRIO,2,0);
	
	GEL_TextOut(" TAC_FE Master: Header Transfer Priority-%d\n",,,,,tac_header_priority);
	GEL_TextOut("                Data Transfer Priority-%d\n",,,,,tac_data_priority);
	GEL_TextOut("                Warning Transfer Priority-%d\n",,,,,tac_warning_priority);
    GEL_TextOut("                CPM Transfer Priority-%d\n\n",,,,,tac_cpm_priority);
	 
	//Hyperbridge Master
	
	GEL_TextOut(" HYPERBRIDGE Master: Priority at VBUSM is determined according to the priority field value\n");
	GEL_TextOut("                     received from the command word. The pri bit encoding is given below:\n");
	GEL_TextOut("                     pri-0b0 ---> Priority0 on the VBUSM\n");
	GEL_TextOut("                     pri-0b1 ---> Priority4 on the VBUSM\n\n");
	
	// COREPAC0 MDMA
	
	urgent_priority = BB_REG_FIELD_READ(COREPAC_MDMAARBU,26,24);
	normal_priority = BB_REG_FIELD_READ(COREPAC_MDMAARBU,18,16);
	
	GEL_TextOut(" COREPAC%d MDMA Master(For other COREPACs load the GEL on the respective COREPAC): Urgent Priority-%d, Normal Priority-%d\n\n",,,,,DNUM,urgent_priority,normal_priority);
	
	
}

#define QM_STATUS_CONFIG_BASE             (0x02a00000) // TCI6614 Base Address of QM status & config region
#define QM_STATUS_CONFIG_REGA             (0x00)
#define QM_STATUS_CONFIG_REGB             (0x04)
#define QM_STATUS_CONFIG_REGC             (0x08)
#define QM_STATUS_CONFIG_REGD             (0x0C)


menuitem "TCI6614 CPPI Queue Status"; 

dialog TCI6614_cppi_queue_status (start_queue_num "Start Queue Number", end_queue_num "End Queue Number")
{
	unsigned int Threshold, Temp, Entry_Count, Byte_Count, Packet_Size, Queue_Num;
	
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** CPPI QUEUES (%d to %d) STATUS **************************************\n",,,,,start_queue_num,end_queue_num);
	GEL_TextOut("*******************************************************************************************************\n\n");
	
	for (Queue_Num = start_queue_num; Queue_Num <= end_queue_num; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
		Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
		Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
		Threshold 	= (1<<Temp) - 1;
		
		GEL_TextOut("Queue Num: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);

	}
}


TCI6614_edma3TC_status(unsigned int cc_num, unsigned int tc_num)
{
	unsigned int tptc_base_addr,tpcc_base_aadr;
	unsigned int srcactv, wsactv, dstactv;
	
	unsigned int flag=0;
	
	// Identify the TPTC base address
	if(cc_num == 0 && tc_num == 0)
	{
		tpcc_base_aadr = EDMA_TPCC0_BASE;
		
		tptc_base_addr = EDMA0_TPTC0_BASE;
	}
	else if(cc_num == 0 && tc_num == 1)
	{
		tpcc_base_aadr = EDMA_TPCC0_BASE;
		
		tptc_base_addr = EDMA0_TPTC1_BASE;
	}
	else if(cc_num == 1 && tc_num == 0)
	{
		tpcc_base_aadr = EDMA_TPCC1_BASE;
		
		tptc_base_addr = EDMA1_TPTC0_BASE;
	}
	else if(cc_num == 1 && tc_num == 1)
	{
		tpcc_base_aadr = EDMA_TPCC1_BASE;
		
		tptc_base_addr = EDMA1_TPTC1_BASE;
	}
	else if(cc_num == 1 && tc_num == 2)
	{
		tpcc_base_aadr = EDMA_TPCC1_BASE;
		
		tptc_base_addr = EDMA1_TPTC2_BASE;
	}
	else if(cc_num == 1 && tc_num == 3)
	{
		tpcc_base_aadr = EDMA_TPCC1_BASE;
		
		tptc_base_addr = EDMA1_TPTC3_BASE;
	}
	else if(cc_num == 2 && tc_num == 0)
	{
		tpcc_base_aadr = EDMA_TPCC2_BASE;
		
		tptc_base_addr = EDMA2_TPTC0_BASE;
	}
	else if(cc_num == 2 && tc_num == 1)
	{
		tpcc_base_aadr = EDMA_TPCC2_BASE;
		
		tptc_base_addr = EDMA2_TPTC1_BASE;
	}
	else if(cc_num == 2 && tc_num == 2)
	{
		tpcc_base_aadr = EDMA_TPCC2_BASE;
		
		tptc_base_addr = EDMA2_TPTC2_BASE;
	}
	else if(cc_num == 2 && tc_num == 3)
	{
		tpcc_base_aadr = EDMA_TPCC2_BASE;
		
		tptc_base_addr = EDMA2_TPTC3_BASE;
	}

	
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 EDMA%d_TC%d STATUS *****************************************\n",,,,,cc_num,tc_num);
	GEL_TextOut(" *******************************************************************************************************\n\n");
	
	//EDMA TC status
	srcactv = BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_TCSTAT),1,1);
	wsactv = BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_TCSTAT),2,2);
	dstactv = BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_TCSTAT),6,4);
	
	if((dstactv != 0) || (wsactv != 0) || (srcactv != 0))
	{
		if((dstactv != 0) && (wsactv != 0) && (srcactv != 0))
		{
			GEL_TextOut(" EDMA%d TC%d is Busy: Has some pending Transfer Requests (TR)\n",,,,,cc_num,tc_num);
			GEL_TextOut("                    Has some pending Read requests\n");
			GEL_TextOut("                    Has some pending Write requests\n\n");
		}
		
		if((dstactv != 0) && (wsactv != 0) && (srcactv == 0))
		{
			GEL_TextOut(" EDMA%d TC%d is Busy: Has some pending Transfer Requests (TR)\n",,,,,cc_num,tc_num);
			GEL_TextOut("                    No pending Read requests\n");
			GEL_TextOut("                    Has some pending Write requests\n\n");
		}
		
		if((dstactv != 0) && (wsactv == 0) && (srcactv != 0))
		{
			GEL_TextOut(" EDMA%d TC%d is Busy: Has some pending Transfer Requests (TR)\n",,,,,cc_num,tc_num);
			GEL_TextOut("                    Has some pending Read requests\n");
			GEL_TextOut("                    No pending Write requests\n\n");
		}
		
		if((dstactv != 0) && (wsactv == 0) && (srcactv == 0))
		{
			GEL_TextOut(" EDMA%d TC%d is Busy: Has some pending Transfer Requests (TR)\n",,,,,cc_num,tc_num);
			GEL_TextOut("                    No pending Read requests\n");
			GEL_TextOut("                    No pending Write requests\n\n");
		}
		
		if((dstactv == 0) && (wsactv != 0) && (srcactv != 0))
		{
			GEL_TextOut(" EDMA%d TC%d is Busy: No pending Transfer Requests (TR)\n",,,,,cc_num,tc_num);
			GEL_TextOut("                    Has some pending Read requests\n");
			GEL_TextOut("                    Has some pending Write requests\n\n");
		}
		
		if((dstactv == 0) && (wsactv != 0) && (srcactv == 0))
		{
			GEL_TextOut(" EDMA%d TC%d is Busy: No pending Transfer Requests (TR)\n",,,,,cc_num,tc_num);
			GEL_TextOut("                    No pending Read requests\n");
			GEL_TextOut("                    Has some pending Write requests\n\n");
		}
		
		if((dstactv == 0) && (wsactv == 0) && (srcactv != 0))
		{
			GEL_TextOut(" EDMA%d TC%d is Busy: No pending Transfer Requests (TR)\n",,,,,cc_num,tc_num);
			GEL_TextOut("                    Has some pending Read requests\n");
			GEL_TextOut("                    No pending Write requests\n\n");
		}
	}
	else if((dstactv == 0) && (wsactv == 0) && (srcactv == 0))
	{
		GEL_TextOut(" EDMA%d TC%d is Idle: No pending Transfer Requests (TR)\n",,,,,cc_num,tc_num);
		GEL_TextOut("                    No pending Read requests\n");
		GEL_TextOut("                    No pending Write requests\n\n");
		
		flag = 1; 
	}
	
	GEL_TextOut(" *******EDMA%d TC%d EVENT QUEUE STATUS (note: considering default eventQ to TC mapping)********\n\n",,,,,cc_num,tc_num);
	
	GEL_TextOut(" Number of Valid Entries in EDMA%d Queue%d ---> %d\n",,,,,cc_num,tc_num,(unsigned int)BB_REG_FIELD_READ((tpcc_base_aadr + EDMA_TPCC_QSTAT0+(tc_num*4)),12,8));
	
	GEL_TextOut(" Maximum EDMA%d Queue%d Usage (after the latest Reset) ---> %d\n\n",,,,,cc_num,tc_num,(unsigned int)BB_REG_FIELD_READ((tpcc_base_aadr + EDMA_TPCC_QSTAT0+(tc_num*4)),20,16));
	
	
	if(flag != 1)
	{
		// Display the status of TC operation
		
		GEL_TextOut(" *******EDMA%d TC%d OPERATION STATUS********\n\n",,,,,cc_num,tc_num);
		
		GEL_TextOut(" Source address from Program Register Set (PSRC.SADDR): %x\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_PSRC),31,0));
		
		GEL_TextOut(" Source address from Source Active Register Set (SASRC.SADDR): %x\n\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_SASRC),31,0));
		
		GEL_TextOut(" A-CNT from Program Register Set (PCNT.ACNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_PCNT),15,0));
		
		GEL_TextOut(" B-CNT from Program Register Set (PCNT.BCNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_PCNT),31,16));
		
		GEL_TextOut(" Amount of data remaining to be read (SACNT.ACNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_SACNT),15,0));
		
		GEL_TextOut(" Amount of data remaining to be read (SACNT.BCNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_SACNT),31,16));
		
		GEL_TextOut(" Amount of data remaining to be written (DFCNT0.ACNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNT0),15,0));
		GEL_TextOut(" Amount of data remaining to be written (DFCNT0.BCNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNT0),31,16));
		
		GEL_TextOut(" Amount of data remaining to be written (DFCNT1.ACNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNT1),15,0));
		GEL_TextOut(" Amount of data remaining to be written (DFCNT1.BCNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNT1),31,16));
		
		GEL_TextOut(" Amount of data remaining to be written (DFCNT1.ACNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNT2),15,0));
		GEL_TextOut(" Amount of data remaining to be written (DFCNT1.BCNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNT2),31,16));
		
		GEL_TextOut(" Amount of data remaining to be written (DFCNT1.ACNT): %d bytes\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNT3),15,0));
		GEL_TextOut(" Amount of data remaining to be written (DFCNT1.BCNT): %d bytes\n\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNT3),31,16));
		
		GEL_TextOut(" Destination address from Program Register Set (PDST.DADDR): %x\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_PDST),31,0));
		
		GEL_TextOut(" Destination address from Destination FIFO Register Set0 (DFDST0.DADDR): %x\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFDST0),31,0));
		GEL_TextOut(" Destination address from Destination FIFO Register Set1 (DFDST1.DADDR): %x\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFDST1),31,0));
		GEL_TextOut(" Destination address from Destination FIFO Register Set2 (DFDST2.DADDR): %x\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFDST2),31,0));
		GEL_TextOut(" Destination address from Destination FIFO Register Set3 (DFDST3.DADDR): %x\n\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFDST3),31,0));
		
		GEL_TextOut(" B-Idx offset between Source arrays from Program Register Set (PBIDX.SBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_PBIDX),15,0));
		GEL_TextOut(" B-Idx offset between Destination arrays from Program Register Set (PBIDX.DBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_PBIDX),31,16));
		
		GEL_TextOut(" B-Idx offset between Source arrays from Source Active Register Set (SABIDX.SBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_SABIDX),15,0));
		GEL_TextOut(" B-Idx offset between Destination arrays from Source Active Register Set (SABIDX.DBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_SABIDX),31,16));
		
		GEL_TextOut(" B-Idx offset between Source arrays from Destination FIFO Register Set0 (DFBIDX0.SBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFBIDX0),15,0));
		GEL_TextOut(" B-Idx offset between Destination arrays from Destination FIFO Register Set0 (DFBIDX0.DBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFBIDX0),31,16));
		
		GEL_TextOut(" B-Idx offset between Source arrays from Destination FIFO Register Set1 (DFBIDX1.SBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFBIDX1),15,0));
		GEL_TextOut(" B-Idx offset between Destination arrays from Destination FIFO Register Set1 (DFBIDX1.DBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFBIDX1),31,16));
		
		GEL_TextOut(" B-Idx offset between Source arrays from Destination FIFO Register Set2 (DFBIDX2.SBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFBIDX2),15,0));
		GEL_TextOut(" B-Idx offset between Destination arrays from Destination FIFO Register Set2 (DFBIDX2.DBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFBIDX2),31,16));
		
		GEL_TextOut(" B-Idx offset between Source arrays from Destination FIFO Register Set3 (DFBIDX3.SBIDX): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFBIDX3),15,0));
		GEL_TextOut(" B-Idx offset between Destination arrays from Destination FIFO Register Set3 (DFBIDX3.DBIDX): %d\n\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFBIDX3),31,16));
		
		GEL_TextOut(" A-Cnt Reload value from Source Active Register set (SACNTRLD.ACNTRLD): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_SACNTRLD),15,0));
		
		GEL_TextOut(" A-Cnt Reload value from Destination FIFO Register set (DFCNTRLD.ACNTRLD): %d\n",,,,,BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFCNTRLD),15,0));
		
		GEL_TextOut(" Starting address for the array currently being read (SASRCBREF.SADDRBREF): %x\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_SASRCBREF),31,0));
		
		GEL_TextOut(" Starting address for the array currently being written (DFSRCBREF.SADDRBREF): %x\n\n",,,,,(unsigned int)BB_REG_FIELD_READ((tptc_base_addr + EDMA_TPTC_DFSRCBREF),31,0));
	}
}



#define AP_AIF2_TXQ_START                     (512)
#define AP_AIF2_TXQ_END                       (639)

#define AP_PA_TXQ_START                       (640)
#define AP_PA_TXQ_END                         (648)

#define AP_SRIO_TXQ_START                     (672)
#define AP_SRIO_TXQ_END                       (687)

#define AP_FFTC_A_TXQ_START                   (688)
#define AP_FFTC_A_TXQ_END                     (691)

#define AP_FFTC_B_TXQ_START                   (692)
#define AP_FFTC_B_TXQ_END                     (695)

#define AP_QMSS_TXQ_START                     (800)
#define AP_QMSS_TXQ_END                       (831)

#define AP_FFTC_C_TXQ_START                   (864)
#define AP_FFTC_C_TXQ_END                     (867)

#define AP_BCP_TXQ_START                      (868)
#define AP_BCP_TXQ_END                        (875)

TCI6614_cppi_txqueue_status()
{
	unsigned int Threshold, Temp, Entry_Count, Byte_Count, Packet_Size, Queue_Num;
	unsigned int flag = 0;
	
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** CPPI TX QUEUES STATUS **************************************\n");
	GEL_TextOut("*******************************************************************************************************\n\n");
	
	//Scan AIF2 TX Queues
	
	for (Queue_Num = AP_AIF2_TXQ_START; Queue_Num <= AP_AIF2_TXQ_END; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		
		if(Entry_Count != 0)
		{
			if(flag == 0)
			{
				GEL_TextOut(" AIF2 Master: Has pending read requests on SCR_3A (From AIF2 TX Queues)\n");
				GEL_TextOut("              The status of the active AIF2 TX queues are:\n\n");
				
				flag=1;
			}
			
			Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
			Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
			Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
			Threshold 	= (1<<Temp) - 1;
			
			GEL_TextOut("              AIF2 TX QNum: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);
		}
		else if((Queue_Num == AP_AIF2_TXQ_END) && (flag != 1))
		{
			GEL_TextOut(" AIF2 Master: Has No pending read requests on SCR_3A (From AIF2 TX Queues)\n");
		}
	}
	
	GEL_TextOut("\n");
	
	//Reset Flag
	flag = 0;
	
	//Scan PA TX Queues
	
	for (Queue_Num = AP_PA_TXQ_START; Queue_Num <= AP_PA_TXQ_END; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		
		if(Entry_Count != 0)
		{
			if(flag == 0)
			{
				GEL_TextOut(" PA Master: Has pending read requests on SCR_3A (From PA TX Queues)\n");
				GEL_TextOut("              The status of the active PA TX queues are:\n\n");
				
				flag=1;
			}
			
			Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
			Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
			Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
			Threshold 	= (1<<Temp) - 1;
			
			GEL_TextOut("              PA TX QNum: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);
		}
		else if((Queue_Num == AP_PA_TXQ_END) && (flag != 1))
		{
			GEL_TextOut(" PA Master: Has No pending read requests on SCR_3A (From PA TX Queues)\n");
		}
	}
	
	GEL_TextOut("\n");
	
	//Reset Flag
	flag = 0;
	
	//Scan SRIO TX Queues
	
	for (Queue_Num = AP_SRIO_TXQ_START; Queue_Num <= AP_SRIO_TXQ_END; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		
		if(Entry_Count != 0)
		{
			if(flag == 0)
			{
				GEL_TextOut(" SRIO Master: Has pending read requests on SCR_3A (From SRIO TX Queues)\n");
				GEL_TextOut("              The status of the active SRIO TX queues are:\n\n");
				
				flag=1;
			}
			
			Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
			Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
			Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
			Threshold 	= (1<<Temp) - 1;
			
			GEL_TextOut("              SRIO TX QNum: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);
		}
		else if((Queue_Num == AP_SRIO_TXQ_END) && (flag != 1))
		{
			GEL_TextOut(" SRIO Master: Has No pending read requests on SCR_3A (From SRIO TX Queues)\n");
		}
	}
	
	GEL_TextOut("\n");
	
	//Reset Flag
	flag = 0;
	
	//Scan FFTC_A TX Queues
	
	for (Queue_Num = AP_FFTC_A_TXQ_START; Queue_Num <= AP_FFTC_A_TXQ_END; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		
		if(Entry_Count != 0)
		{
			if(flag == 0)
			{
				GEL_TextOut(" FFTC_A Master: Has pending read requests on SCR_3A (From FFTC_A TX Queues)\n");
				GEL_TextOut("              The status of the active FFTC_A TX queues are:\n\n");
				
				flag=1;
			}
			
			Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
			Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
			Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
			Threshold 	= (1<<Temp) - 1;
			
			GEL_TextOut("              FFTC_A TX QNum: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);
		}
		else if((Queue_Num == AP_FFTC_A_TXQ_END) && (flag != 1))
		{
			GEL_TextOut(" FFTC_A Master: Has No pending read requests on SCR_3A (From FFTC_A TX Queues)\n");
		}
	}
	
	GEL_TextOut("\n");
	
	//Reset Flag
	flag = 0;
	
	//Scan FFTC_B TX Queues
	
	for (Queue_Num = AP_FFTC_B_TXQ_START; Queue_Num <= AP_FFTC_B_TXQ_END; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		
		if(Entry_Count != 0)
		{
			if(flag == 0)
			{
				GEL_TextOut(" FFTC_B Master: Has pending read requests on SCR_3A (From FFTC_B TX Queues)\n");
				GEL_TextOut("              The status of the active FFTC_B TX queues are:\n\n");
				
				flag=1;
			}
			
			Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
			Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
			Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
			Threshold 	= (1<<Temp) - 1;
			
			GEL_TextOut("              FFTC_B TX QNum: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);
		}
		else if((Queue_Num == AP_FFTC_B_TXQ_END) && (flag != 1))
		{
			GEL_TextOut(" FFTC_B Master: Has No pending read requests on SCR_3A (From FFTC_B TX Queues)\n");
		}
	}
	
	GEL_TextOut("\n");
	
	//Reset Flag
	flag = 0;
	
	//Scan QMSS TX Queues
	
	for (Queue_Num = AP_QMSS_TXQ_START; Queue_Num <= AP_QMSS_TXQ_END; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		
		if(Entry_Count != 0)
		{
			if(flag == 0)
			{
				GEL_TextOut(" QMSS Master: Has pending read requests on SCR_3A (From QMSS TX Queues)\n");
				GEL_TextOut("              The status of the active QMSS TX queues are:\n\n");
				
				flag=1;
			}
			
			Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
			Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
			Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
			Threshold 	= (1<<Temp) - 1;
			
			GEL_TextOut("              QMSS TX QNum: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);
		}
		else if((Queue_Num == AP_QMSS_TXQ_END) && (flag != 1))
		{
			GEL_TextOut(" QMSS Master: Has No pending read requests on SCR_3A (From QMSS TX Queues)\n");
		}
	}
	
	GEL_TextOut("\n");
	
	//Reset Flag
	flag = 0;
	
	//Scan FFTC_C TX Queues
	
	for (Queue_Num = AP_FFTC_C_TXQ_START; Queue_Num <= AP_FFTC_C_TXQ_END; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		
		if(Entry_Count != 0)
		{
			if(flag == 0)
			{
				GEL_TextOut(" FFTC_C Master: Has pending read requests on SCR_3A (From FFTC_C TX Queues)\n");
				GEL_TextOut("              The status of the active FFTC_C TX queues are:\n\n");
				
				flag=1;
			}
			
			Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
			Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
			Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
			Threshold 	= (1<<Temp) - 1;
			
			GEL_TextOut("              FFTC_C TX QNum: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);
		}
		else if((Queue_Num == AP_FFTC_C_TXQ_END) && (flag != 1))
		{
			GEL_TextOut(" FFTC_C Master: Has No pending read requests on SCR_3A (From FFTC_C TX Queues)\n");
		}
	}
	
	GEL_TextOut("\n");
	
	//Reset Flag
	flag = 0;
	
	//Scan BCP TX Queues
	
	for (Queue_Num = AP_BCP_TXQ_START; Queue_Num <= AP_BCP_TXQ_END; Queue_Num++)
	{
		Entry_Count = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGA)) & 0x0007FFFF;
		
		if(Entry_Count != 0)
		{
			if(flag == 0)
			{
				GEL_TextOut(" BCP Master: Has pending read requests on SCR_3A (From BCP TX Queues)\n");
				GEL_TextOut("              The status of the active BCP TX queues are:\n\n");
				
				flag=1;
			}
			
			Byte_Count 	= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGB)) & 0x0FFFFFFF;
			Packet_Size = *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGC)) & 0x0000001F;
			Temp 		= *((unsigned int*)(QM_STATUS_CONFIG_BASE + (16 * Queue_Num) + QM_STATUS_CONFIG_REGD)) & 0x0000000F;
			Threshold 	= (1<<Temp) - 1;
			
			GEL_TextOut("              BCP TX QNum: %d --> Entry Count %d   Byte Count %d   Packet Size %d   Queue Threshold In terms of Packets %d\n",,,,, Queue_Num, Entry_Count, Byte_Count, Packet_Size, Threshold);
		}
		else if((Queue_Num == AP_BCP_TXQ_END) && (flag != 1))
		{
			GEL_TextOut(" BCP Master: Has No pending read requests on SCR_3A (From BCP TX Queues)\n");
		}
	}
	
	GEL_TextOut("\n");
}



menuitem "TCI6614 BB Error Scan";

hotmenu BB_scr_bridges_scan()
{
	bb_scr_bridges_scan();
}

hotmenu BB_scr_slave_scan()
{
	bb_scr_slave_scan();
}

menuitem "TCI6614 EDMA3 TC Status/EDMA TPCC0";

hotmenu EDMA0_TC0_Status()
{
	TCI6614_edma3TC_status(0, 0);
}

hotmenu EDMA0_TC1_Status()
{
	TCI6614_edma3TC_status(0, 1);
}

menuitem "TCI6614 EDMA3 TC Status/EDMA TPCC1";

hotmenu EDMA1_TC0_Status()
{
	TCI6614_edma3TC_status(1, 0);
}

hotmenu EDMA1_TC1_Status()
{
	TCI6614_edma3TC_status(1, 1);
}

hotmenu EDMA1_TC2_Status()
{
	TCI6614_edma3TC_status(1, 2);
}

hotmenu EDMA1_TC3_Status()
{
	TCI6614_edma3TC_status(1, 3);
}

menuitem "TCI6614 EDMA3 TC Status/EDMA TPCC2";

hotmenu EDMA2_TC0_Status()
{
	TCI6614_edma3TC_status(2, 0);
}

hotmenu EDMA2_TC1_Status()
{
	TCI6614_edma3TC_status(2, 1);
}

hotmenu EDMA2_TC2_Status()
{
	TCI6614_edma3TC_status(2, 2);
}

hotmenu EDMA2_TC3_Status()
{
	TCI6614_edma3TC_status(2, 3);
}

menuitem "TCI6614 CPPI Masters Status";

hotmenu TCI6614_Cppi_Masters_Status()
{
	TCI6614_cppi_txqueue_status();
}

menuitem "TCI6614 Device Level Configuration";

hotmenu TCI6614_Bootstrap_Configuration()
{
	TCI6614_bootstrap_configuration();
}

hotmenu TCI6614_Master_Priority_Config()
{
	TCI6614_master_priority_config();
}

menuitem "TCI6614 PSC Status";

hotmenu TCI6614_Psc_Voltage_Control_Identification()
{
	TCI6614_psc_voltage_control_identification();
}

hotmenu TCI6614_PSC_Pwrdomain_Status()
{
	TCI6614_psc_pwrdomain_status();
}

hotmenu TCI6614_PSC_Clockdomain_Status()
{
	TCI6614_Psc_Clockdomain_Status();
}


menuitem "TCI6614 Device Level Status";

hotmenu TCI6614_Boot_Status()
{
	TCI6614_boot_Status();
}

hotmenu TCI6614_Reset_Status()
{
	TCI6614_reset_status();
}

hotmenu TCI6614_Efuse_Status()
{
	TCI6614_efuse_status();
}


menuitem "TCI6614 SERDES Status";

hotmenu TCI6614_Srio_Serdes_Status()
{
	TCI6614_srio_serdes_status();
}

hotmenu TCI6614_Hyperbridge_Serdes_Status()
{
	TCI6614_hyperbridge_serdes_status();
}

hotmenu TCI6614_Aif2_Serdes_Status()
{
	TCI6614_aif2_serdes_status();
}

hotmenu TCI6614_Sgmii_Serdes_Status()
{
	TCI6614_sgmii_serdes_status();
}

hotmenu TCI6614_Pcie_Serdes_Status()
{
	TCI6614_pcie_serdes_status();
}


menuitem "TCI6614 PCIe SERDES Configuration";

hotmenu Pcie_Serdes_Pll_Config()
{
	TCI6614_pcie_serdes_pll_config();
}

hotmenu Pcie_Serdes_Lane0_Config()
{
	TCI6614_pcie_serdes_lane_config0();
}

hotmenu Pcie_Serdes_Lane1_Config()
{
	TCI6614_pcie_serdes_lane_config1();
}

hotmenu Pcie_Serdes_Config_Snapshot()
{
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 PCIE SERDES SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_pcie_serdes_pll_config();

	TCI6614_pcie_serdes_lane_config0();

	TCI6614_pcie_serdes_lane_config1();
}

menuitem "TCI6614 Sgmii SERDES Configuration/SERDES0";

hotmenu Sgmii_Serdes0_Pll_Config()
{
	TCI6614_sgmii_serdes_pll_config(0);
}

hotmenu Sgmii_Serdes0_Rx_Config()
{
	TCI6614_sgmii_serdes_rx_config(0);
}

hotmenu Sgmii_Serdes0_Tx_Config()
{
	TCI6614_sgmii_serdes_tx_config(0);
}

hotmenu Sgmii_Serdes0_Config_Snapshot()
{
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SGMII SERDES0 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_sgmii_serdes_pll_config(0);

	TCI6614_sgmii_serdes_rx_config(0);

	TCI6614_sgmii_serdes_tx_config(0);
}

menuitem "TCI6614 Sgmii SERDES Configuration/SERDES1";

hotmenu Sgmii_Serdes1_Pll_Config()
{
	TCI6614_sgmii_serdes_pll_config(1);
}

hotmenu Sgmii_Serdes1_Rx_Config()
{
	TCI6614_sgmii_serdes_rx_config(1);
}

hotmenu Sgmii_Serdes1_Tx_Config()
{
	TCI6614_sgmii_serdes_tx_config(1);
}

hotmenu Sgmii_Serdes1_Config_Snapshot()
{

	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SGMII SERDES1 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_sgmii_serdes_pll_config(1);

	TCI6614_sgmii_serdes_rx_config(1);

	TCI6614_sgmii_serdes_tx_config(1);
}

menuitem "TCI6614 Sgmii SERDES Configuration/All SERDES Snapshot";

hotmenu Sgmii_All_Serdes_Config_Snapshot()
{
	unsigned int i;
	
	for(i=0; i<2; i++)
	{
		GEL_TextOut(" *******************************************************************************************************\n");
		GEL_TextOut(" ********************************** TCI6614 SGMII SERDES%d SNAPSHOT ******************************\n",,,,,i);
		GEL_TextOut(" *******************************************************************************************************\n\n");

		TCI6614_sgmii_serdes_pll_config(i);

		TCI6614_sgmii_serdes_rx_config(i);

		TCI6614_sgmii_serdes_tx_config(i);
	}
}





menuitem "TCI6614 Srio SERDES Configuration/SERDES0";

hotmenu Srio_Serdes0_Pll_Config()
{
	TCI6614_srio_serdes_pll_config(0);
}

hotmenu Srio_Serdes0_Rx_Config()
{
	TCI6614_srio_serdes_rx_config(0);
}

hotmenu Srio_Serdes0_Tx_Config()
{
	TCI6614_srio_serdes_tx_config(0);
}

hotmenu Srio_Serdes0_Config_Snapshot()
{
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SRIO SERDES0 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_srio_serdes_pll_config(0);

	TCI6614_srio_serdes_rx_config(0);

	TCI6614_srio_serdes_tx_config(0);
}

menuitem "TCI6614 Srio SERDES Configuration/SERDES1";

hotmenu Srio_Serdes1_Pll_Config()
{
	TCI6614_srio_serdes_pll_config(1);
}

hotmenu Srio_Serdes1_Rx_Config()
{
	TCI6614_srio_serdes_rx_config(1);
}

hotmenu Srio_Serdes1_Tx_Config()
{
	TCI6614_srio_serdes_tx_config(1);
}

hotmenu Srio_Serdes1_Config_Snapshot()
{

	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SRIO SERDES1 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_srio_serdes_pll_config(1);

	TCI6614_srio_serdes_rx_config(1);

	TCI6614_srio_serdes_tx_config(1);
}


menuitem "TCI6614 Srio SERDES Configuration/SERDES2";

hotmenu Srio_Serdes2_Pll_Config()
{
	TCI6614_srio_serdes_pll_config(2);
}

hotmenu Srio_Serdes2_Rx_Config()
{
	TCI6614_srio_serdes_rx_config(2);
}

hotmenu Srio_Serdes2_Tx_Config()
{
	TCI6614_srio_serdes_tx_config(2);
}

hotmenu Srio_Serdes2_Config_Snapshot()
{
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SRIO SERDES2 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_srio_serdes_pll_config(2);

	TCI6614_srio_serdes_rx_config(2);

	TCI6614_srio_serdes_tx_config(2);
}

menuitem "TCI6614 Srio SERDES Configuration/SERDES3";

hotmenu Srio_Serdes3_Pll_Config()
{
	TCI6614_srio_serdes_pll_config(3);
}

hotmenu Srio_Serdes3_Rx_Config()
{
	TCI6614_srio_serdes_rx_config(3);
}

hotmenu Srio_Serdes3_Tx_Config()
{
	TCI6614_srio_serdes_tx_config(3);
}

hotmenu Srio_Serdes3_Config_Snapshot()
{
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 SRIO SERDES3 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_srio_serdes_pll_config(3);

	TCI6614_srio_serdes_rx_config(3);

	TCI6614_srio_serdes_tx_config(3);
}


menuitem "TCI6614 Srio SERDES Configuration/All SERDES Snapshot";

hotmenu Srio_All_Serdes_Config_Snapshot()
{
	unsigned int i;
	
	for(i=0; i<4; i++)
	{
		GEL_TextOut(" *******************************************************************************************************\n");
		GEL_TextOut(" ********************************** TCI6614 SRIO SERDES%d SNAPSHOT ******************************\n",,,,,i);
		GEL_TextOut(" *******************************************************************************************************\n\n");

		TCI6614_srio_serdes_pll_config(i);

		TCI6614_srio_serdes_rx_config(i);

		TCI6614_srio_serdes_tx_config(i);
	}
}


menuitem "TCI6614 Hyperbridge SERDES Configuration/SERDES0";

hotmenu Hyperbridge_Serdes0_Pll_Config()
{
	TCI6614_hyperbridge_serdes_pll_config(0);
}

hotmenu Hyperbridge_Serdes0_Rx_Config()
{
	TCI6614_hyperbridge_serdes_rx_config(0);
}

hotmenu Hyperbridge_Serdes0_Tx_Config()
{
	TCI6614_hyperbridge_serdes_tx_config(0);
}

hotmenu Hyperbridge_Serdes0_Config_Snapshot()
{
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES0 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_hyperbridge_serdes_pll_config(0);

	TCI6614_hyperbridge_serdes_rx_config(0);

	TCI6614_hyperbridge_serdes_tx_config(0);
}

menuitem "TCI6614 Hyperbridge SERDES Configuration/SERDES1";

hotmenu Hyperbridge_Serdes1_Pll_Config()
{
	TCI6614_hyperbridge_serdes_pll_config(1);
}

hotmenu Hyperbridge_Serdes1_Rx_Config()
{
	TCI6614_hyperbridge_serdes_rx_config(1);
}

hotmenu Hyperbridge_Serdes1_Tx_Config()
{
	TCI6614_hyperbridge_serdes_tx_config(1);
}

hotmenu Hyperbridge_Serdes1_Config_Snapshot()
{

	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES1 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_hyperbridge_serdes_pll_config(1);

	TCI6614_hyperbridge_serdes_rx_config(1);

	TCI6614_hyperbridge_serdes_tx_config(1);
}


menuitem "TCI6614 Hyperbridge SERDES Configuration/SERDES2";

hotmenu Hyperbridge_Serdes2_Pll_Config()
{
	TCI6614_hyperbridge_serdes_pll_config(2);
}

hotmenu Hyperbridge_Serdes2_Rx_Config()
{
	TCI6614_hyperbridge_serdes_rx_config(2);
}

hotmenu Hyperbridge_Serdes2_Tx_Config()
{
	TCI6614_hyperbridge_serdes_tx_config(2);
}

hotmenu Hyperbridge_Serdes2_Config_Snapshot()
{
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES2 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_hyperbridge_serdes_pll_config(2);

	TCI6614_hyperbridge_serdes_rx_config(2);

	TCI6614_hyperbridge_serdes_tx_config(2);
}

menuitem "TCI6614 Hyperbridge SERDES Configuration/SERDES3";

hotmenu Hyperbridge_Serdes3_Pll_Config()
{
	TCI6614_hyperbridge_serdes_pll_config(3);
}

hotmenu Hyperbridge_Serdes3_Rx_Config()
{
	TCI6614_hyperbridge_serdes_rx_config(3);
}

hotmenu Hyperbridge_Serdes3_Tx_Config()
{
	TCI6614_hyperbridge_serdes_tx_config(3);
}

hotmenu Hyperbridge_Serdes3_Config_Snapshot()
{
	GEL_TextOut(" *******************************************************************************************************\n");
	GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES3 SNAPSHOT ******************************\n");
	GEL_TextOut(" *******************************************************************************************************\n\n");

	TCI6614_hyperbridge_serdes_pll_config(3);

	TCI6614_hyperbridge_serdes_rx_config(3);

	TCI6614_hyperbridge_serdes_tx_config(3);
}


menuitem "TCI6614 Hyperbridge SERDES Configuration/All SERDES Snapshot";

hotmenu Hyperbridge_All_Serdes_Config_Snapshot()
{
	unsigned int i;
	
	for(i=0; i<4; i++)
	{
		GEL_TextOut(" *******************************************************************************************************\n");
		GEL_TextOut(" ********************************** TCI6614 HYPERBRIDGE SERDES%d SNAPSHOT ******************************\n",,,,,i);
		GEL_TextOut(" *******************************************************************************************************\n\n");

		TCI6614_hyperbridge_serdes_pll_config(i);

		TCI6614_hyperbridge_serdes_rx_config(i);

		TCI6614_hyperbridge_serdes_tx_config(i);
	}
}


menuitem "TCI6614 PLL Configuration";

hotmenu TCI6614_Mainpll_Configuration()
{
	TCI6614_mainpll_config();
}

hotmenu TCI6614_DDRpll_Configuration()
{
	TCI6614_ddrpll_config();
}

hotmenu TCI6614_PApll_Configuration()
{
	TCI6614_papll_config();
}


menuitem "TCI6614 DDR3 EMIF Configuration";

hotmenu SDCFG_SDRAM_Configuration_Register()
{
	SDRAM_Configuration_Register();
}

hotmenu SDRFC_SDRAM_Refresh_Control_Register()
{
	SDRAM_Refresh_Control_Register();
}

hotmenu PMCTL_Power_Management_Control_Register()
{
	Power_Management_Control_Register();
}

hotmenu LAT_CONFIG_Latency_Configuration_Register()
{
	Latency_Configuration_Register();
}


hotmenu ZQCFG_SDRAM_Output_Impedance_Calibration_Configuration_Register()
{
	SDRAM_Output_Impedance_Calibration_Configuration_Register();
}


hotmenu RDWR_LVL_RMP_WIN_Read_Write_Leveling_Ramp_Window_Register()
{
	Read_Write_Leveling_Ramp_Window_Register();
}

hotmenu RDWR_LVL_RMP_CTRL_Read_Write_Leveling_Ramp_Control_Register()
{
	Read_Write_Leveling_Ramp_Control_Register();
}

hotmenu RDWR_LVL_CTRL_Read_Write_Leveling_Control_Register()
{

	Read_Write_Leveling_Control_Register();
}

hotmenu DDR_PHY_CTRL_1_DDR_PHY_Control_1_Register()
{
	DDR_PHY_Control_1_Register();
}

hotmenu READ_IDLE_CTRL_Read_Idle_Control_Register()
{
	Read_Idle_Control_Register();
}


hotmenu PRICOSMAP_Priority_to_Class_Of_Service_Mapping_Register()
{
	Priority_to_Class_Of_Service_Mapping_Register();
}


hotmenu MIDCOS1MAP_Master_ID_to_Class_Of_Service_1_Mapping_Register()
{
	Master_ID_to_Class_Of_Service_1_Mapping_Register();
}

hotmenu MIDCOS2MAP_Master_ID_to_Class_Of_Service_2_Mapping_Register()
{
	Master_ID_to_Class_Of_Service_2_Mapping_Register();
}

hotmenu ECCCTL_ECC_Control_Register()
{
	ECC_Control_Register();
}

hotmenu ECCADDR1_ECC_Address_Range_1_Register()
{
	ECC_Address_Range_1_Register();
}

hotmenu ECCADDR2_ECC_Address_Range_2_Register()
{
	ECC_Address_Range_2_Register();
}

hotmenu RWTHRESH_Read_Write_Execution_Threshold_Register()
{
	Read_Write_Execution_Threshold_Register();
}

hotmenu DDR3EMIF_Config_registers_Snapshot()
{
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** DDR3 EMIF CONFIGURATION SNAPSHOT **************************************\n");
	GEL_TextOut("*******************************************************************************************************\n\n");

	SDRAM_Configuration_Register();

	SDRAM_Refresh_Control_Register();

	Power_Management_Control_Register();

	Latency_Configuration_Register();

	SDRAM_Output_Impedance_Calibration_Configuration_Register();

	Read_Write_Leveling_Ramp_Window_Register();

	Read_Write_Leveling_Ramp_Control_Register();

	Read_Write_Leveling_Control_Register();

	DDR_PHY_Control_1_Register();

	Read_Idle_Control_Register();

	Priority_to_Class_Of_Service_Mapping_Register();

	Master_ID_to_Class_Of_Service_1_Mapping_Register();

	Master_ID_to_Class_Of_Service_2_Mapping_Register();

	ECC_Control_Register();

	ECC_Address_Range_1_Register();

	ECC_Address_Range_2_Register();

	Read_Write_Execution_Threshold_Register();
}


menuitem "TCI6614 DDR3 EMIF Status";

hotmenu DMCSTAT_DDR3_Memory_Controller_Status_Register()
{
	DDR3_Memory_Controller_Status_Register();
}

hotmenu IRQSTATUS_SYS_Interrupt_Status_Register()
{
	Interrupt_Status_Register();
}

hotmenu DDR3EMIF_Status_Snapshot()
{
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** DDR3 EMIF STATUS SNAPSHOT **************************************\n");
	GEL_TextOut("*******************************************************************************************************\n\n");
	
	DDR3_Memory_Controller_Status_Register();

	Interrupt_Status_Register();
}

menuitem "TCI6614 PLL Controller Configuration";

hotmenu PLLCTL_PLL_Control_Register()
{
	PLL_Control_Register();
}

hotmenu PLLM_PLL_Multiplier_Control_Register()
{
	PLL_Multiplier_Control_Register();
}


hotmenu PREDIV_PLL_Pre_Divider_Registers()
{
	PLL_Pre_Divider_Registers();
}


hotmenu PLLDIVn_PLL_Controller_Divider_Register()
{
	PLL_Controller_Divider_Register();
}


hotmenu CKEN_Clock_Enable_Control_Register()
{
	Clock_Enable_Control_Register();
}

hotmenu RSTCTRL_Reset_Control_Register()
{
	Reset_Control_Register();
}

hotmenu RSTCFG_Reset_Configuration_Register()
{
	Reset_Configuration_Register();
}


hotmenu RSISO_Reset_Isolation_Register()
{
	Reset_Isolation_Register();
}

hotmenu POSTDIV_PLL_Post_Divider_Control_Register()
{
	PLL_Post_Divider_Control_Register();
}


hotmenu SECCTL_PLL_Secondary_Control_Register()
{
	PLL_Secondary_Control_Register();
}

hotmenu PLLController_Config_Snapshot()
{
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** PLL CONTROLLER CONFIGURATION SNAPSHOT **************************************\n");
	GEL_TextOut("*******************************************************************************************************\n\n");

	PLL_Control_Register();

	PLL_Multiplier_Control_Register();

	PLL_Pre_Divider_Registers();

	PLL_Controller_Divider_Register();

	Clock_Enable_Control_Register();

	Reset_Control_Register();

	Reset_Configuration_Register();

	Reset_Isolation_Register();

	PLL_Post_Divider_Control_Register();

	PLL_Secondary_Control_Register();
	
}



menuitem "TCI6614 PLL Controller Status";

hotmenu CKSTAT_Clock_Status_Register()
{
	Clock_Status_Register();
}

hotmenu SYSTAT_SYSCLK_Status_Register()
{
	SYSCLK_Status_Register();
}

hotmenu RSTYPE_Reset_Type_Status_Register()
{
	Reset_Type_Status_Register();
}

hotmenu PLLController_Status_Snapshot()
{
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** PLL CONTROLLER STATUS SNAPSHOT **************************************\n");
	GEL_TextOut("*******************************************************************************************************\n\n");

	Clock_Status_Register();

	SYSCLK_Status_Register();

	Reset_Type_Status_Register();
}


menuitem "TCI6614 Cache Configuration/L1P Cache";

hotmenu L1PCFG_L1P_Configuration_Register()
{
	L1P_Configuration_Register();
}


hotmenu L1PCC_L1P_Cache_Control_Register()
{
	L1P_Cache_Control_Register();
}


hotmenu L1PMPFAR_L1P_Memory_Protection_Fault_Address_Register()
{
	L1P_Memory_Protection_Fault_Address_Register();
}


hotmenu L1PMPFSR_L1P_Memory_Protection_Fault_Set_Register()
{
	L1P_Memory_Protection_Fault_Set_Register();
}

hotmenu L1P_Config_Snapshot()
{
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** CORE%d L1P CACHE CONFIGURATION SNAPSHOT **************************************\n",,,,,DNUM);
	GEL_TextOut("*******************************************************************************************************\n\n");

	L1P_Configuration_Register();

	L1P_Cache_Control_Register();

	L1P_Memory_Protection_Fault_Address_Register();

	L1P_Memory_Protection_Fault_Set_Register();
}

menuitem "TCI6614 Cache Configuration/L1D Cache";

hotmenu L1DCFG_L1D_Configuration_Register()
{
	L1D_Configuration_Register();
}


hotmenu L1DCC_L1D_Cache_Control_Register()
{
	L1D_Cache_Control_Register();
}


hotmenu L1DMPFAR_L1D_Memory_Protection_Fault_Address_Register()
{
	L1D_Memory_Protection_Fault_Address_Register();
}


hotmenu L1DMPFSR_L1D_Memory_Protection_Fault_Set_Register()
{
	L1D_Memory_Protection_Fault_Set_Register();
}


hotmenu L1D_Config_Snapshot()
{
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** CORE%d L1D CACHE CONFIGURATION SNAPSHOT **************************************\n",,,,,DNUM);
	GEL_TextOut("*******************************************************************************************************\n\n");

	L1D_Configuration_Register();

	L1D_Cache_Control_Register();

	L1D_Memory_Protection_Fault_Address_Register();

	L1D_Memory_Protection_Fault_Set_Register();
}


menuitem "TCI6614 Cache Configuration/L2 Cache";

hotmenu L2CFG_L2_Configuration_Register()
{
	L2_Configuration_Register();
}

hotmenu L2MPFAR_L2_Memory_Protection_Fault_Address_Register()
{
	L2_Memory_Protection_Fault_Address_Register();
}

hotmenu L2MPFSR_L2_Memory_Protection_Fault_Set_Register()
{
	L2_Memory_Protection_Fault_Set_Register();
}

hotmenu L2_Config_Snapshot()
{
	GEL_TextOut("*******************************************************************************************************\n");
	GEL_TextOut("********************************** CORE%d L2 CACHE CONFIGURATION SNAPSHOT **************************************\n",,,,,DNUM);
	GEL_TextOut("*******************************************************************************************************\n\n");

	L2_Configuration_Register();

	L2_Memory_Protection_Fault_Address_Register();

	L2_Memory_Protection_Fault_Set_Register();
}

menuitem "TCI6614 Cache Configuration/Memory Attribute Regions (MARs)";

hotmenu Get_Cacheable_mememory_regions()
{
	L2_Cacheable_Memory_Attribute_Register();
}

hotmenu Get_PreFetchable_mememory_regions()
{
	L2_PreFetchable_Memory_Attribute_Register();
}


menuitem "TCI6614 APIs";

dialog generic_EDMA3_transfer_request_fn(cc_num "Channel Controller Num (0, 1 and 2)", tc_num "Transfer Controller Num (0, 1, 2 and 3)", src_addr "Source Global Addr", dst_addr "Destination Global Addr", byte_count "Byte Count")
{
	unsigned int tpcc_base_addr;
	unsigned int result;
	
	unsigned int param_save0;
    unsigned int param_save1;
    unsigned int param_save2;
    unsigned int param_save3;
    unsigned int param_save4;
    unsigned int param_save5;
    unsigned int param_save6;
    unsigned int param_save7;

    unsigned int dchmap_save;
    unsigned int dchmap_addr;
    unsigned int esr_addr;
    unsigned int esr_mask;
    unsigned int dmaqnum_save;
    unsigned int dmaqnum_addr;
    unsigned int dmaqnum_mask;
    unsigned int dmaqnum_val;
    int errCnt;
	
	unsigned int chan_num;
	unsigned int param_num;
	unsigned int temp = 0;
	
	// Identify the TPCC base address
	if(cc_num == 0)
	{
		tpcc_base_addr = EDMA_TPCC0_BASE;
		chan_num = EDMA_TPCC0_CHAN_NUM;
		param_num = EDMA_TPCC0_PARAM_NUM;
	}
	else if(cc_num == 1)
	{
		tpcc_base_addr = EDMA_TPCC1_BASE;
		chan_num = EDMA_TPCC1_CHAN_NUM;
		param_num = EDMA_TPCC1_PARAM_NUM;
	}
	else if(cc_num == 2)
	{
		tpcc_base_addr = EDMA_TPCC2_BASE;
		chan_num = EDMA_TPCC2_CHAN_NUM;
		param_num = EDMA_TPCC2_PARAM_NUM;
	}
	
	
	dchmap_addr = (tpcc_base_addr + EDMA_TPCC_DCHMAP0) + (4 * chan_num);
	
	dmaqnum_addr = (tpcc_base_addr + EDMA_TPCC_DMAQNUM0) + 4 * (chan_num >> 3);
    dmaqnum_mask = 15 << (4*(chan_num % 8));
    dmaqnum_val  = (tc_num) << (4*(chan_num % 8));
	
	// Save info which needs to be re-instated
	
    param_save0  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0),31,0);
	param_save1  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4),31,0);
	param_save2  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8),31,0);
	param_save3  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12),31,0);
	param_save4  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16),31,0);
	param_save5  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20),31,0);
	param_save6  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24),31,0);
	param_save7  = BB_REG_FIELD_READ((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28),31,0);
	dchmap_save  = BB_REG_FIELD_READ(dchmap_addr,31,0); // DCHMAPx 
	dmaqnum_save = BB_REG_FIELD_READ(dmaqnum_addr,31,0); // DMAQNUMx 
	
	// Setup EDMA Param entry
	
	// OPT: STATIC, A-Sync
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0), 31, 0, 0x00000008);
	
	//SRC
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4), 31, 0, src_addr);
	
	temp = (1 << 16) | byte_count;
	
	//ACNT = 8 and BCNT = 1
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8), 31, 0, temp);
	
	//DST
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12), 31, 0, dst_addr);
	
	//BIDX
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16), 31, 0, 0x00000000);
	
	//LINK
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20), 31, 0, 0x00000000);
	
	//CIDX
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24), 31, 0, 0x00000000);

    //CCNT = 1
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28), 31, 0, 0x00000001);
	
	
	//Setup param to channel mapping
	BB_REG_FIELD_WRITE(dchmap_addr, 31, 0, (tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20)));
	
	BB_REG_FIELD_WRITE(dmaqnum_addr, 31, 0, ((dmaqnum_save & (~dmaqnum_mask)) | dmaqnum_val));
	
	
	//Trigger EDMA transfer
	
	if (chan_num < 32) 
	{
		esr_addr = (tpcc_base_addr + EDMA_TPCC_ESR);
		
		BB_REG_FIELD_WRITE(esr_addr, chan_num, chan_num, 0x1);
	} 
	else 
	{
		esr_addr = (tpcc_base_addr + EDMA_TPCC_ESRH);
		
		BB_REG_FIELD_WRITE(esr_addr, (chan_num-32), (chan_num-32), 0x1);
	}
	
	//Give some delay for transfer to complete
	BB_Delay(10000);
	
	//Re-instate the saved info
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 0), 31, 0, param_save0);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 4), 31, 0, param_save1);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 8), 31, 0, param_save2);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 12), 31, 0, param_save3);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 16), 31, 0, param_save4);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 20), 31, 0, param_save5);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 24), 31, 0, param_save6);
	BB_REG_FIELD_WRITE((tpcc_base_addr + EDMA_TPCC_PARAM_BASE + (param_num*0x20) + 28), 31, 0, param_save7);
	BB_REG_FIELD_WRITE(dchmap_addr, 31, 0, dchmap_save);
	BB_REG_FIELD_WRITE(dmaqnum_addr, 31, 0, dmaqnum_save);
	
	//Print Status to the console
	GEL_TextOut( "EDMA3 Transfer Request completed successfully\n\n");
}


dialog PSC_Power_Domain_Switch_Fn(power_domain_num "Power Domain Number (0 to 17)", switch_input "On/Off (On -> 1, Off -> 0)")
{
	//Wait for any previous transitions to complete
	while((BB_REG_FIELD_READ(BB_PSC_PTSTAT,power_domain_num,power_domain_num)));
	
	//Write Switch input into the corresponding PDCTL register
	BB_REG_FIELD_WRITE((PSC_PDCTL0+(power_domain_num*4)),0,0,switch_input);
	
	//Write PTCMD to start the transistion
	BB_REG_FIELD_WRITE(BB_PSC_PTCMD,power_domain_num,power_domain_num,0x1);
	
	//wait for the transistion to complete
	while((BB_REG_FIELD_READ(BB_PSC_PTSTAT,power_domain_num,power_domain_num)));
	
	//Print Status to the console
	GEL_TextOut( "PSC Power Domain Switch completed successfully\n\n");
}

hotmenu TCI6614_Enable_all_Power_Clock_Domains()
{
	TCI6614_enable_all_power_clock_domains();
}

dialog PSC_Clock_Domain_Switch_Fn(power_domain_num "Power Domain Number(should be ON) (0 to 17)", clock_domain_num "Clock Domain Number (0 to 29)",switch_input "On/SwRstDisable (On -> 0x3, SwRstDisable state. -> 0x0)")
{
	//Wait for any previous transitions to complete
	while((BB_REG_FIELD_READ(BB_PSC_PTSTAT,power_domain_num,power_domain_num)));
	
	//Write Switch input into the corresponding PDCTL register
	BB_REG_FIELD_WRITE((PSC_MDCTL0+(clock_domain_num*4)),4,0,switch_input);
	
	//Write PTCMD to start the transistion
	BB_REG_FIELD_WRITE(BB_PSC_PTCMD,power_domain_num,power_domain_num,0x1);
	
	//wait for the transistion to complete
	while((BB_REG_FIELD_READ(BB_PSC_PTSTAT,power_domain_num,power_domain_num)));
	
	//Print Status to the console
	GEL_TextOut( "PSC Clock Domain Switch completed successfully\n\n");
}

hotmenu Device_Config_State_Snapshot ()
{

	TCI6614_Bootstrap_Configuration();
	TCI6614_Master_Priority_Config();
	TCI6614_Psc_Voltage_Control_Identification();
	TCI6614_PSC_Pwrdomain_Status();
	TCI6614_PSC_Clockdomain_Status();
	TCI6614_Boot_Status();
	TCI6614_Reset_Status();
	TCI6614_Efuse_Status();
	TCI6614_Mainpll_Configuration();
	PLLController_Config_Snapshot();
	PLLController_Status_Snapshot();

}

hotmenu TCI6614_Srio_Serdes_Status_Poll ()
{

	unsigned int i;
	
	for(i=0;i<10;i++)
	{
		TCI6614_Srio_Serdes_Status();
	}	

}


